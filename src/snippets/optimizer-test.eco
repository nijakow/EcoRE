{
    static with inherited _ = std Module;

    optimizer <- (std os files here / '..' / 'modules' / 'ecosphere' / 'optimizer' / '_.eco') import Init;

    f(x) => [ x * x ] value;
    g(x) => 42;
    h(x) => [ (std io out << 'Hi!') newline commit ] repeat;
    i(x) => [ [ [ a ] repeat. [ b ] repeat ] repeat ] value;
    j(x) => [ foo ] value;
    k(x) => [ condition ] while: [ body ];
    mega(x) => (
        [
            | i <- 0 |
            [ i < 42 ] while: [
                (std io out << i) newline commit.
            ]
        ] repeat
    );
    giga => [ [ [a] while: [b] ] repeat ] value;
    iter => (
        [
            | i <- 0 |
            [ i < 10 ] while: [
                (std io out << i) newline commit.
                i <- i + 1.
            ]
        ] repeat.
    );
    regs(x) => (
        |
            v <- 0,
            i <- 21,
            j <- i * 2,
            k <- i + i
        |
      ^ [ :xx | j * k + x + xx ] value
    );
    layoutInPlace => (
                shrinkToFit.

                |
                    lower  <- 0,
                    higher <- bounds dimensionForOrientation: orientation,
                    diff   <- higher - lower,

                    flexCount <- 0,
                    reservedF <- 0,
                    reservedN <- 0,
                    budget    <- 0
                |

                childrenDo: [ :c |
                    (c layoutForOrientation: orientation) isFlexible
                      ~   if: [ flexCount <- flexCount + 1.
                                reservedF <- reservedF + (c minExtentForOrientation: orientation) ]
                        else: [ reservedN <- reservedN + (c minExtentForOrientation: orientation) ].
                ].

                budget <- (bounds dimensionForOrientation: orientation) max: (reservedF + reservedN).

                |
                    offset <- 0
                |

                childrenDo: [ :c |
                    |
                        minSpace <- c minExtentForOrientation: orientation,
                        spaceForM
                    |
                    (c layoutForOrientation: orientation) isFlexible if: [
                        | available <- (budget - reservedN) - (reservedF - minSpace) |
                        spaceForM <- (budget - reservedN) / flexCount.
                        (spaceForM > available) -> [ spaceForM <- available ].
                        (spaceForM < minSpace)  -> [ spaceForM <- minSpace  ].
                        flexCount <- flexCount - 1.
                        reservedF <- reservedF - minSpace.
                    ] else: [
                        spaceForM <- minSpace.
                        reservedN <- reservedN - spaceForM.
                    ].

                    |
                        heightForM
                    |
                    
                    (c layoutForOrientation: orientation opposite) isFlexible if: [
                        heightForM <- extentForOrientation: orientation opposite
                    ] else: [
                        heightForM <- c minExtentForOrientation: orientation opposite
                    ].

                    orientation
                      ~ ifHorizontal: [ c boundsX: offset Y: 0 W: spaceForM H: heightForM ]
                          ifVertical: [ c boundsX: 0 Y: offset W: heightForM H: spaceForM ].
                    
                    offset <- offset + spaceForM.
                    budget <- budget - spaceForM.
                ].

                childrenDo: [ :c | c layoutInPlaceIfNeeded ].
                layoutIsNowOkay.
            );

    Main => (
        |
            answer <- optimizer BuildAST: (optimizer Disassemble: #'regs' In: self)
        |
        "((optimizer ast Printer) clone initWithWriter: std io out) print: answer."
        (std io out << answer) newline commit.
    );
} Main.
