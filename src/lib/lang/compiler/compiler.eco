
#=lang/compiler/Scope: {
    shared, parent_scope, bindings;

    initWithShared: s => (
        shared <- s.
      ^ initWithParent: self
    );

    initWithParent: p => (
        shared <- p shared.
        parent_scope <- p.
        bindings <- std util newMap.
      ^ self
    );

    createSubscope => (#<:lang/compiler/NormalScope> clone) initWithParent: self Lexical: getLexicalScope;

    getParentScope => parent_scope;

    bindVariable: varname WithInfo: info => bindings at: varname put: info;

    with inherited parent = #<:std/Clonable>;
},


#=lang/compiler/ValueType: {
    Register = {
        number, depth, writer;

        initWithNumber: n Depth: d Writer: w => (
            number <- n.
            depth <- d.
            writer <- w.
          ^ self
        );

        initWithNumber: n Writer: w => initWithNumber: n Depth: 0 Writer: w;

        drop => self;
        push => writer writePushReg: number;
        storeIn: r => writer writeReg: number Depth: depth ToReg: r;
    },
    Stack = {
        writer;

        initWithWriter: w => (
          writer <- w.
          ^ self
        );

        drop => writer writeDrop;
        push => self;
        storeIn: r => writer writePopReg: r;
    },
    Constant = {
        constantValue, writer;

        initWithValue: v Writer: w => (
            constantValue <- v.
            writer <- w.
          ^ self
        );

        drop => self;
        push => writer writePushConst: constantValue;
        storeIn: r => writer writeConst: constantValue;
    }
},

#=lang/compiler/Compiler: {
    writer, lastValue;

    initWithWriter: w => (
        writer <- w.
      ^ self
    );

    lastValue: nv => (lastValue drop. lastValue <- nv);

    constantValue: c => "TODO";
    registerValue: n => "TODO";
    stackTopValue => "TODO";

    loadSelf => loadRegister: 0;
    loadConstant: c => lastValue: (constantValue: c);
    loadRegister: r => lastValue: (registerValue: r);
    storeRegister: r => lastValue storeIn: r;

    push => lastValue push;
    pop => lastValue: stackTopValue;
    drop => loadSelf;

    builtinWithMessage: msg ArgCount: args Varargs: varargs => (
        writer writeBuiltin: msg Args: args Varargs: varargs.
        lastValue: stackTopValue
    );
    builtinWithMessage: msg ArgCount: args => (
        builtinWithMessage: msg ArgCount: args Varargs: false
    );

    sendWithMessage: msg ArgCount: args Varargs: varargs => (
        writer writeSend: msg Args: args varargs: varargs
        lastValue: stackTopValue
    );
    sendWithMessage: msg ArgCount: args => (
        sendWithMessage: msg ArgCount: args Varargs: false
    );

    assignWithKey: key => (
        writer writeAssign: key.
        lastValue: stackTopValue
    );

    returnWithDepth: depth => (
      lastValue push.
      writer writeReturn: depth
    );

    with inherited parent = #<:std/Clonable>;
},

#=lang/compiler/ScopeSharedInfo: {
    lexical_parent_scope;

    init => (
        lexical_parent_scope <- self.
      ^ self
    );

    initWithLexicalParentScope: l => (
        lexical_parent_scope <- l.
      ^ self
    );

    with inherited parent = #<:std/Clonable>;
},

#=lang/compiler/ScopedCompiler: {
    scopes;

    init => (
        scopes <- newScope;
      ^ self
    );

    newBlockContextWithParent: p => (#<:lang/compiler/ScopeSharedInfo> clone) initWithLexicalParentScope: l;
    newBlockContext => (#<:lang/compiler/ScopeSharedInfo> clone) init;
    newScopeFromBlockContext: bc => (#<:lang/compiler/BlockScope> clone) initWithShared: bc;
    newScope => newScopeFromBlockContext: newBlockContext;

    pushNormalScope => scopes <- scopes createSubscope;
    pushBlockScope => scopes <- newBlockContextWithParent: scopes;
    popScope => scopes <- scopes getParentScope;

    loadVariable: name IfNotPresent: block => "TODO";
    storeVariable: name IfNotPresent: block => "TODO";
    storeVariable: name => storeVariable: name IfNotPresent: [];
},


#=lang/compiler: {
    Bytecodes = #<:lang/compiler/Bytecodes>;
    CodeWriter = #<:lang/compiler/CodeWriter>;
    Visitor = #<:lang/compiler/Visitor>;
    Compiler = #<:lang/compiler/Compiler>;
}
