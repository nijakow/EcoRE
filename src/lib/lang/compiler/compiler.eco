
#=lang/compiler/RegisterAllocator: {
    freeSet, counter;

    init => (
        freeSet <- std util newSet.
        counter <- 0.
      ^ self
    );

    allocate => (
        (freeSet isEmpty) if: [ allocateN: 1 ]
                        else: [ freeSet take ]
    );
    allocateN: n => ( | c <- counter | counter <- counter + n. ^ c );
    deallocate: r => freeSet addElement: r;
    withAllocatedRegister: block => (
        "TODO: Unwind-Protect!"
        |
          v <- allocate.
          r <- v let: block
        |
        deallocate: v.
      ^ r
    );
},

#=lang/compiler/ValueType: {
    Register = {
        number, depth;

        initWithNumber: n Depth: d => (
            number <- n.
            depth <- d.
          ^ self
        );

        initWithNumber: n => initWithNumber: n Depth: 0;

        ifRegister: r ifConstant: c ifStack: s => r value;
    },
    Stack = {
        ifRegister: r ifConstant: c ifStack: s => s value;
    },
    Constant = {
        constantValue;

        initWithValue: v => (
            constantValue <- v.
          ^ self
        );

        ifRegister: r ifConstant: c ifStack: s => c value;
    }
},

#=lang/compiler/Compiler: {
    writer, lastValue;

    initWithWriter: w => (
        writer <- w.
      ^ self
    );
    init => initWithWriter: (#<:lang/compiler/CodeWriter> new);

    lastValue: nv => (dropLastValue. lastValue <- nv);
    dropLastValue => lastValue isStack if: [ writer writeDrop ];
    pushLastValue => (
        lastValue ifRegister: [ (lastValue depth isZero)
                                     if: [ writer writePushReg: lastValue number ]
                                   else: [ "TODO" ] ]
                  ifConstant: [ writer writePushConst: lastValue constantValue ]
                     ifStack: []
    );
    moveLastValueToReg: r Depth: d => (
        /"
          TODO: registerAllocator withAllocatedRegister: [ :r | ... ].
         "/
        lastValue ifRegister: [ (lastValue depth isZero)
                                     if: [ writer writeReg: (lastValue number) ToReg: r Depth: d ]
                                   else: [ "TODO" ] ]
                  ifConstant: [ (lastValue depth isZero)
                                     if: [ writer writeConst: lastValue constantValue ]
                                   else: [ "TODO" ] ]
                     ifStack: [ (lastValue depth isZero)
                                     if: [ writer writePopReg: lastValue number ]
                                   else: [ "TODO" ].
                                loadRegister: r Depth: d ]
    );
    moveLastValueToReg: r => moveLastValueToReg: r Depth: 0;

    constantValue: c => (#<:lang/compiler/ValueType> Constant) clone initWithValue: c;
    registerValue: n Depth: d => (#<:lang/compiler/ValueType> Register) clone initWithNumber: n Depth: d;
    stackTopValue => (#<:lang/compiler/ValueType> Stack) clone;

    loadSelf => loadRegister: 0;
    loadConstant: c => lastValue: (constantValue: c);
    loadRegister: r Depth: d => lastValue: (registerValue: r Depth: d);
    loadRegister: r => loadRegister: r Depth: 0;

    push => pushLastValue;
    drop => loadSelf;

    builtinWithMessage: msg ArgCount: args Varargs: varargs => (
        writer writeBuiltin: msg Args: args Varargs: varargs.
        lastValue: stackTopValue
    );
    builtinWithMessage: msg ArgCount: args => (
        builtinWithMessage: msg ArgCount: args Varargs: false
    );

    sendWithMessage: msg ArgCount: args Varargs: varargs => (
        writer writeSend: msg Args: args varargs: varargs
        lastValue: stackTopValue
    );
    sendWithMessage: msg ArgCount: args => (
        sendWithMessage: msg ArgCount: args Varargs: false
    );

    assignWithKey: key => (
        writer writeAssign: key.
        lastValue: stackTopValue
    );

    returnWithDepth: depth => (
      lastValue push.
      writer writeReturn: depth
    );

    with inherited parent = #<:std/Clonable>;
},

#=lang/compiler/ScopeSharedInfo: {
    lexicalParent, compiler;

    initWithMaybeLexicalParent: ml => (
        lexicalParent <- ml.
        compiler <- #<:lang/compiler/Compiler> new.
      ^ self
    );
    initWithLexicalParent: l => initWithMaybeLexicalParent: (Yes: l);
    init => initWithMaybeLexicalParent: No;

    with inherited parent = #<:std/Clonable>;
},

#=lang/compiler/Scope: {
    shared, parent_scope, bindings;

    initWithShared: s => (
        shared <- s.
      ^ initWithParent: self
    );

    initWithParent: p => (
        shared <- p shared.
        parent_scope <- p.
        bindings <- std util newMap.
      ^ self
    );

    createSubscope => (#<:lang/compiler/NormalScope> clone) initWithParent: self Lexical: getLexicalScope;

    parentScope => parent_scope;
    compiler => shared compiler;

    bindVariable: varname WithInfo: info => bindings at: varname put: info;

    findVariable: varname IfFound: found IfNotFound: notfound Depth: depth => (
        bindings at: varname do: [ :info | ^ found value(info, depth) ].
        (parentScope is: self) if: [
          (shared lexicalParent) yes: [
             :lex | lex findVariable: varname
                             IfFound: found
                          IfNotFound: notfound
                               Depth: (depth + 1)
          ] no: [ ^ notfound value ]
        ].
      ^ parentScope findVariable: varname IfFound: found IfNotFound: notfound Depth: depth
    );

    findVariable: varname IfFound: found IfNotFound: notfound => (
        findVariable: varname IfFound: found IfNotFound: notfound Depth: 0
    );

    with inherited parent = #<:std/Clonable>;
},

#=lang/compiler/ScopedCompiler: {
    scopes;

    init => (
        scopes <- newScope;
      ^ self
    );

    newBlockContextWithParent: p => (#<:lang/compiler/ScopeSharedInfo> clone) initWithLexicalParent: l;
    newBlockContext => (#<:lang/compiler/ScopeSharedInfo> clone) init;
    newScopeFromBlockContext: bc => (#<:lang/compiler/BlockScope> clone) initWithShared: bc;
    newScope => newScopeFromBlockContext: newBlockContext;

    pushNormalScope => scopes <- scopes createSubscope;
    pushBlockScope => scopes <- newBlockContextWithParent: scopes;
    popScope => scopes <- scopes parentScope;

    loadVariable: name IfNotPresent: block => (
        scopes findVariable: name
                    IfFound: [ :info, :depth | scopes compiler loadRegister: (info index) Depth: depth ]
                 IfNotFound: block
    );
    storeVariable: name IfNotPresent: block => (
        scopes findVariable: name
                    IfFound: [ :info, :depth | scopes compiler storeRegister: (info index) Depth: depth ]
                 IfNotFound: block
    );
    storeVariable: name => storeVariable: name IfNotPresent: [];
},


#=lang/compiler: {
    Bytecodes = #<:lang/compiler/Bytecodes>;
    RegisterAllocator = #<:lang/compiler/RegisterAllocator>;
    CodeWriter = #<:lang/compiler/CodeWriter>;
    Visitor = #<:lang/compiler/Visitor>;
    Compiler = #<:lang/compiler/Compiler>;
}
