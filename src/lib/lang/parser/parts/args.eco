
#=lang/parser/Parser/Args: {
    parseArgdef => (
        | type <- parseOptionalType,
          name <- (expect: TokenType IDENTIFIER) payload |
      ^ type & name
    );

    parseArgdefs => (
        | defs <- std util newVector |
        [ check: TokenType RPAREN ] until: [
            (check: TokenType ELLIPSIS) if: [
                expect: TokenType RPAREN.
              ^ defs & true
            ].
            defs append: parseArgdef.
            (check: TokenType RPAREN) if: [ ^ defs & false ].
            expect: TokenType SEPARATOR
        ].
      ^ defs & false
    );

    parseOptionalArgdefs => (
        (check: TokenType LPAREN) if: [ parseArgdefs ]
                                else: [ std util newVector & false ]
    );

    parseMethodDeclaration => (
        ([ check: TokenType KEY ] or: [ checkUnaryIdentifier ]) when: [
            :tok |  | lst <- parseOptionalArgdefs |
            ^ (tok payload) & (lst first) & (lst second)
        ].

        checkBinaryIdentifier when: [
            :tok |  | args <- std util newVector |
            args append: parseArgdef.
          ^ (tok payload) & args & false
        ].

        |
            name <- '',
            args <- std util newVector
        |

        [
            | ident <- checkNAryIdentifier |

            ident unless: [ ^ (name asKey) & args & false ].
            name <- name + (ident payload asString).
            args append: parseArgdef.
        ] repeat
    );

    parseArglist => (
        | exprs <- std util newVector |
        [ check: TokenType RPAREN ] until: [
            (check: TokenType ELLIPSIS) if: [
                expect: TokenType RPAREN.
              ^ exprs & true
            ].
            exprs append: parseExpression.
            (check: TokenType RPAREN) if: [ ^ exprs & false ].
            expect: TokenType SEPARATOR
        ].
      ^ exprs & false
    );

    parseOptionalArglist => (
        (check: TokenType LPAREN) if: [ parseArglist ]
                                else: [ std util newVector & false ]
    );
}
