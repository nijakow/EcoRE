#=lang/tokenizer: {

    StringReader = {
        charVector, index;

        with inherited trait = {
            init: str => (
                charVector <- str asVector.
                index <- 0.
              ^ self
            );

            hasNext  => index < (charVector size);
            advance  => index <- index + 1;
            peekChar => charVector at: index;
            readChar => ( | c <- peekChar | advance. ^ c );
            peeks: s => (
                | i <- index |
                s do: [ :c |
                    hasNext unless: [ index <- i. ^ false ].
                    (c != readChar) if: [ index <- i. ^ false ]
                ].
              ^ true
            );
        };

        with inherited parent = #<:std/Clonable>;
    },

    Token = {
        tokenizer, type, payload;

        with inherited trait = {
            writeOn: writer => writer << 'Token: ' << type.

            tokenizer: tok type: t payload: p => (
                tokenizer <- tok.
                type <- t.
                payload <- p.
              ^ self
            );

            hasType: t => type is: t;
            fail => tokenizer unread: self;
        },

        with inherited parent = #<:std/Clonable>;
    },
    
    Tokenizer = {
        in, pushbacks;

        init: reader => (
            in <- reader.
            pushbacks <- std util newVector.
          ^ self
        );

        unread: token => pushbacks push: token;

        IsSpace(c) => (
            (c == (char space))   if: [ ^ true ].
            (c == (char tab))     if: [ ^ true ].
            (c == (char newline)) if: [ ^ true ].
            (c == (char return))  if: [ ^ true ].
          ^ false
        );

        IsSpecial(c) => [ '()[]{}.,;|^' contains: c ] or: [ IsSpace(c) ];

        skipWhitespace => (
            [ [ in hasNext ] and: [ IsSpace(in peekChar) ] ] while: [ in advance ]
        );

        peeks: str => in peeks: str;

        newTokenWithType: type Payload: pl => (lang tokenizer Token) new tokenizer: self type: type payload: pl;
        newTokenWithType: type => newTokenWithType: type Payload: false;

        parseString: terminator => (
            | sb <- (std util StringBuilder) new |

            [ in peekChar == terminator ] until: [
                sb append: (in readChar)
            ].

            in readChar.

          ^ sb asString
        );

        nextToken => (
            (pushbacks isEmpty) unless: [ ^ pushbacks pop ].

            skipWhitespace.

            (in hasNext) unless: [ ^ newTokenWithType: TokenType EOF ].
            (peeks: '...') if: [ ^ newTokenWithType: TokenType ELLIPSIS   ].
            (peeks: '<-')  if: [ ^ newTokenWithType: TokenType ASSIGNMENT ].
            (peeks: '->')  if: [ ^ newTokenWithType: TokenType DELEGATE   ].
            (peeks: '=>')  if: [ ^ newTokenWithType: TokenType RARROW     ].
            (peeks: '(')   if: [ ^ newTokenWithType: TokenType LPAREN     ].
            (peeks: ')')   if: [ ^ newTokenWithType: TokenType RPAREN     ].
            (peeks: '[')   if: [ ^ newTokenWithType: TokenType LBRACK     ].
            (peeks: ']')   if: [ ^ newTokenWithType: TokenType RBRACK     ].
            (peeks: '{')   if: [ ^ newTokenWithType: TokenType LCURLY     ].
            (peeks: '}')   if: [ ^ newTokenWithType: TokenType RCURLY     ].
            (peeks: '#(')  if: [ ^ newTokenWithType: TokenType HASHLPAREN ].
            (peeks: '%[')  if: [ ^ newTokenWithType: TokenType PERCLBRACK ].
            (peeks: '.')   if: [ ^ newTokenWithType: TokenType SEPARATOR  ].
            (peeks: ',')   if: [ ^ newTokenWithType: TokenType SEPARATOR  ].
            (peeks: ';')   if: [ ^ newTokenWithType: TokenType SEPARATOR  ].
            (peeks: ':')   if: [ ^ newTokenWithType: TokenType COLON      ].
            (peeks: '~')   if: [ ^ newTokenWithType: TokenType TILDE      ].
            (peeks: '|')   if: [ ^ newTokenWithType: TokenType BAR        ].
            (peeks: '^')   if: [ ^ newTokenWithType: TokenType CARET      ].
            (peeks: '\'')  if: [ ^ newTokenWithType: TokenType STRING Payload: (parseString: #\') ].
            (peeks: '#\'') if: [ ^ newTokenWithType: TokenType KEY    Payload: ((parseString: #\') asKey) ].
            (peeks: '#=')  if: [ ^ newTokenWithType: TokenType LABEL  Payload: (parseString: #\:) ].
            (peeks: '#<')  if: [ ^ newTokenWithType: TokenType PROXY  Payload: (parseString: #\>) ].
            (peeks: '#\\') if: [ ^ newTokenWithType: TokenType CHARACTER  Payload: (in nextChar) ].
            (peeks: '"')   if: [ parseString: #\". ^ nextToken ].
            
            | sb <- (std util StringBuilder) new |

            [ [ in hasNext ] and: [ IsSpecial(in peekChar) not ] ] while: [
                sb append: (in readChar).
            ].

            sb <- sb asString.

            "TODO: Number parsing"

            (sb equals: '')          if: [ ^ newTokenWithType: TokenType EOF        ].
            (sb equals: 'self')      if: [ ^ newTokenWithType: TokenType SELF       ].
            (sb equals: 'as')        if: [ ^ newTokenWithType: TokenType AS         ].
            (sb equals: 'with')      if: [ ^ newTokenWithType: TokenType WITH       ].
            (sb equals: 'inherited') if: [ ^ newTokenWithType: TokenType INHERITED  ].
            (sb equals: 'own')       if: [ ^ newTokenWithType: TokenType OWN        ].
            (sb equals: '=')         if: [ ^ newTokenWithType: TokenType ASSIGNMENT ].
          ^ newTokenWithType: (TokenType IDENTIFIER) Payload: (sb asKey)
        );

        with inherited shared = #<:lang/parser/SharedBehavior>;
        with inherited parent = #<:std/Clonable>;
    }
}
