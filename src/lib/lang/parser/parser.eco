#=lang/parser/Parser/ASTConstruction: {

  newASTSelf => "TODO";

  newASTConstantWithValue: value => "TODO";
  newASTArrayWithExpressions: exprs => "TODO";
  newASTInterfaceBuilder => "TODO";
  newASTObjectBuilder => "TODO";

  newASTBuiltinWithName: name Args: args HasVarargs: varargs => "TODO";

  newASTCallWithSubject: subject Args: args HasVarargs: varargs => "TODO";

  newASTSendWithSubject: subject Message: msg Args: args HasVarargs: varargs => "TODO";

  newASTAssignmentWithLHS: lhs RHS: rhs => "TODO";

  newASTBarWithType: type Var: var Value: value Followup: followup => "TODO";

  newASTCompoundWithInstructions: instructions => "TODO";

  newASTBlockWithArgs: args Body: body => "TODO";

  newASTReturnWithValue: value => "TODO";

  newASTAsWithLHS: lhs RHS: rhs => "TODO";
},

#=lang/parser/Parser/Checks: {
    error: msg => "TODO";

    check: type => check: type withProperty: [ :token | true ];
    check: type withProperty: block => (
        | t <- tokenizer nextToken |
        ([t hasType: type] and: [block value(t)]) if: [t] else: [ t fail. false ]
    );

    checkIdentifier => check: TokenType IDENTIFIER;
    checkDotIdentifier => (
        check: TokenType IDENTIFIER withProperty: [
            :token | (token payload asString asVector last) == #\:
        ]
    );
    checkBinaryIdentifier => (
        check: TokenType IDENTIFIER withProperty: [
            :token | (token payload asString asVector last) let: [
                :c | [ IsBin(c) ] and: [ c != #\: ]
            ]
        ]
    );
    checkNAryIdentifier => (
        check: TokenType IDENTIFIER withProperty: [
            :token | IsBin(token payload asString asVector last)
        ]
    );
    checkUnaryIdentifier => (
        check: TokenType IDENTIFIER withProperty: [
            :token | IsBin(token payload asString asVector last) not
        ]
    );

    expect: type => (
        (check: type) when: [ :v | ^ v ].
        error: 'Expected a different token!'
    );
},

#=lang/parser/Parser/StringChecks: {
    IsBin(c) => (
        "TODO: Rework this function!"
        ([
            [
                [ [ c >= #\a ] and: [ c <= #\z ] ] or: [ [ c >= #\A ] and: [ c <= #\Z ] ]
            ] or: [ [ c >= #\0 ] and: [ c <= #\9 ] ]
        ] or: [ c == #\_ ]) not
    );
},

#=lang/parser/Parser/Expression: {
    parseExpression => parseExpressionWithFollowups: true;
    parseExpressions => parseExpressionsWithTerminator: TokenType RPAREN;

    parseSimpleExpressionWithFollowups: followups => (
        (check: TokenType SELF)       if: [ ^ newASTSelf     ].
        (check: TokenType LPAREN)     if: [ ^ parseCompound  ].
        (check: TokenType LBRACK)     if: [ ^ parseBlock     ].
        (check: TokenType LCURLY)     if: [ ^ parseObject    ].
        (check: TokenType HASHLPAREN) if: [ ^ parseArray     ].
        (check: TokenType PERCLBRACK) if: [ ^ parseInterface ].

        (check: TokenType KEY) when: [ :kw |
            (check: TokenType LPAREN) if: [
                parseArglist let: [ :arglist |
                  ^ newASTBuiltinWithName: (kw payload)
                                     Args: (arglist first)
                               HasVarargs: (arglist second)
                ]
            ].
          ^ kw payload
        ].

        (check: TokenType STRING) when: [ :kw | ^ newASTConstantWithValue: (kw payload) ].

        (check: TokenType NUMBER) when: [ :kw | ^ newASTConstantWithValue: (kw payload) ].

        (check: TokenType CHARACTER) when: [ :kw | ^ newASTConstantWithValue: (kw payload) ].

      ^ newASTSelf
    );

    parseExpressionWithFollowups: followups => (
        ([ followups ] and: [ check: TokenType CARET ]) if: [
          ^ newASTReturnWithValue: (parseExpressionWithFollowups: followups)
        ].
        ([ followups ] and: [ check: TokenType BAR ]) if: [ ^ parseBar ].

        |
            ast <- parseSimpleExpressionWithFollowups: followups,
            next <- false
        |

        [
            next <- ast.
            ast  <- parseSendWithAST: ast Followups: followups.
            begin
              if: [ check: TokenType LPAREN ] then: [
                parseArglist let: [
                  :arglist | ast <- newASTCallWithSubject: (ast)
                                                     Args: (arglist first)
                                               HasVarargs: (arglist second)
                ]
              ] ~
              if: [ check: TokenType AS ] then: [
                  ast <- newASTAsWithLHS: (ast)
                                     RHS: (parseExpressionWithFollowups: false)
              ] ~
              if: [ check: TokenType ASSIGNMENT ] then: [
                  ast <- newASTAssignmentWithLHS: (ast)
                                             RHS: (parseExpressionWithFollowups: followups)
              ] ~
              if: [ check: TokenType TILDE ] then: [

              ] ~
              if: [ ast is: next ] then: [
                ^ ast
              ] ~
            default: []
        ] repeat.
    );

    parseExpressionsWithTerminator: terminator => (
        | exprs <- (std util Vector) new |
        [ check: terminator ] until: [
            exprs append: parseExpression.
            (check: terminator) if: [ ^ exprs ].
            expect: TokenType SEPARATOR
        ].
      ^ exprs
    );
},

#=lang/parser/Parser/Send: {
    tryParseNArySendWithAST: ast => (
        ( | ident <- checkNAryIdentifier |
            ident if: [
                |
                    nameStr <- '',
                    arglist <- (std util Vector) new
                |

                [
                    nameStr <- nameStr + (ident payload asString).
                    arglist append: parseArgdef.
                    ident <- checkNAryIdentifier.
                    ident unless: [
                      ^ newASTSendWithSubject: ast
                                      Message: nameStr asKey
                                         Args: arglist
                                      Varargs: false
                    ]
                ] repeat
            ]
        ).
      ^ ast
    );

    parseSendWithAST: ast Followups: followups => (
        ( | ident <- checkUnaryIdentifier |
            ident if: [
                | arglist <- parseOptionalArglist |
              ^ newASTSendWithSubject: ast
                              Message: ident payload
                                 Args: arglist first
                              Varargs: arglist second
            ]
        ).

        followups unless: [ ^ ast ].

        ( | ident <- checkBinaryIdentifier |
            ident if: [
                | args <- (std util Vector) new |
                args append: (parseExpressionWithFollowups: false).
              ^ newASTSendWithSubject: ast
                              Message: ident payload
                                 Args: args
                              Varargs: false
            ]
        ).

      ^ tryParseNArySendWithAST: ast
    );
},

#=lang/parser/Parser/Compounds: {
    parseCompound => parseCompoundWithTerminator: TokenType RPAREN;
    
    parseCompoundWithTerminator: terminator => (
      ^ newASTCompoundWithInstructions: (parseExpressionsWithTerminator: terminator)
    );

    parseBlock => (
        |
            parameters <- (std util Vector) new,
            varargs    <- false,
            the_type,
            key
        |
        [
          begin
            if: [check: TokenType COLON] then: [
              the_type <- parseOptionalType.
              key      <- (expect: TokenType IDENTIFIER) payload.
              parameters append: (key & the_type).
              (check: TokenType BAR) unless: [
                  expect: TokenType SEPARATOR
              ]
            ] ~
            if: [check: TokenType ELLIPSIS] then: [
                varargs <- true.
                expect: TokenType BAR.
              ^ newASTBlockWithArgs: (parameters)
                         HasVarargs: (varargs)
                               Body: (parseCompoundWithTerminator: TokenType RBRACK)
            ] ~
            default: [
              ^ newASTBlockWithArgs: (parameters)
                         HasVarargs: (varargs)
                               Body: (parseCompoundWithTerminator: TokenType RBRACK)
            ]
        ] repeat.
    );
},

#=lang/parser/Parser/Optionals: {
    parseOptionalType => (
        | the_type <- false |  "TODO: Find a better value (maybe 'any')"
        (check: TokenType LBRACK) if: [
            the_type <- parseExpression.
            expect: TokenType RBRACK
        ].
      ^ the_type
    );

    parseKeyOrIdentifier => (
        | t |
        t <- check: TokenType KEY.
        t if: [ ^ t payload ].
        t <- check: TokenType IDENTIFIER.
        t if: [ ^ t payload ].
        error: 'Expected key or identifier!'
    );
},

#=lang/parser/Parser/Args: {
    parseArgdef => (
        | type <- parseOptionalType,
          name <- (expect: TokenType IDENTIFIER) payload |
      ^ type & name
    );

    parseArgdefs => (
        ([ check: TokenType KEY ] or: [ check: TokenType IDENTIFIER ]) when: [
            :tok |  | lst <- parseOptionalArglist |
            ^ (tok payload) & (lst first) & (lst second)
        ].

        checkBinaryIdentifier when: [
            :tok |  | args <- (std util Vector) new |
            args append: parseArgdef.
          ^ (tok payload) & args & false
        ].

        |
            name <- '',
            args <- (std util Vector) new
        |

        [
            | ident <- checkNAryIdentifier |

            ident unless: [ ^ (name asKey) & args & false ].
            name <- name + (ident payload asString).
            args append: parseArgdef.
        ] repeat
    );

    parseArglist => (
        | exprs <- (std util Vector) new |
        [ check: TokenType RPAREN ] until: [
            (check: TokenType ELLIPSIS) if: [
                expect: TokenType RPAREN.
              ^ exprs & true
            ].
            exprs append: (parseExpression).
            (check: TokenType RPAREN) if: [ ^ exprs & false ].
            expect: TokenType SEPARATOR
        ].
      ^ exprs & false
    );

    parseOptionalArglist => (
        (check: TokenType LPAREN) if: [ parseArglist ]
                                else: [ ^ (std util Vector) new & false ]
    );
},

#=lang/parser/Parser/SimpleObjects: {
    parseArray => (
        newASTArrayWithExpressions: parseExpressions
    );

    parseInterface => (
        | builder <- newASTInterfaceBuilder |
        [ check: TokenType RBRACK ] until: [
            (check: TokenType WITH) if: [
                builder addParent: parseExpression
            ] else: [
              |
                type <- parseOptionalType,
                name <- parseKeyOrIdentifier,
                "TODO: Arglist"
              |
              "TODO: Create entry"
            ].
            (check: TokenType RBRACK) if: [ ^ builder commit ].
            expect: TokenType SEPARATOR
        ].
      ^ builder commit
    );
},

#=lang/parser/Parser/Molecule: {
    parseObjectSlotFlags: flags => (
        [
            begin
              if: [ check: TokenType WITH      ] then: [ flags setWith      ] ~
              if: [ check: TokenType OWN       ] then: [ flags setOwn       ] ~
              if: [ check: TokenType INHERITED ] then: [ flags setInherited ] ~
            default: [ ^ flags ]
        ] repeat
    );

    parseObject => (
        | builder <- newASTObjectBuilder |
        [ check: TokenType RCURLY ] until: [
            (check: TokenType CARET) if: [
                builder addParent: parseExpression
            ] else: [
                | flags <- builder openFlags |
                parseObjectSlotFlags: flags.

                |
                    argdefs  <- parseArgdefs,
                    slotname <- argdefs first,
                    arglist  <- argdefs second,
                    varargs  <- argdefs third
                |

                (check: TokenType RARROW) if: [
                    | body <- parseExpression |
                    builder openCodeSlotWithFlags: flags
                                             Name: slotname
                                             Args: arglist
                                          Varargs: varargs
                                             Body: body
                ] else: [
                    | value |
                    (check: TokenType ASSIGNMENT) if: [ value <- parseExpression ]
                                                else: [ value <- newASTSelf ].
                    builder openSlotWithFlags: flags
                                         Name: slotname
                                        Value: value
                ]
            ].
            (check: TokenType RBRACK) if: [ ^ builder commit ].
            expect: TokenType SEPARATOR
        ]
    );
},

#=lang/parser/Parser/Instructions: {
    parseBarAssignmentValue => (
        (check: TokenType ASSIGNMENT)
              if: [ ^ parseExpression ]
            else: [ ^ newASTSelf      ]
    );

    parseBar => (
        |
            type    <- parseOptionalType,
            varname <- (expect: TokenType IDENTIFIER) payload,
            value   <- parseBarAssignmentValue
        |

        check: TokenType SEPARATOR.

        (check: TokenType BAR) if: [
          ^ newASTBarWithType: type
                          Var: varname
                        Value: value
                     Followup: parseExpression
        ] else: [
          ^ newASTBarWithType: type
                          Var: varname
                        Value: value
                     Followup: parseBar
        ]
    );
},

#=lang/parser: {

    Parser = {
        tokenizer;

        init: _tokenizer => (
            tokenizer <- _tokenizer.
          ^ self
        );

        with inherited construction = #<:lang/parser/Parser/ASTConstruction>;
        with inherited checks = #<:lang/parser/Parser/Checks>;
        with inherited stringchecks = #<:lang/parser/Parser/StringChecks>;
        with inherited expression = #<:lang/parser/Parser/Expression>;
        with inherited send = #<:lang/parser/Parser/Send>;
        with inherited compounds = #<:lang/parser/Parser/Compounds>;
        with inherited optionals = #<:lang/parser/Parser/Optionals>;
        with inherited args = #<:lang/parser/Parser/Args>;
        with inherited simpleobjects = #<:lang/parser/Parser/SimpleObjects>;
        with inherited molecule = #<:lang/parser/Parser/Molecule>;
        with inherited instructions = #<:lang/parser/Parser/Instructions>;
        with inherited shared = #<:lang/parser/SharedBehavior>;
        with inherited parent = #<:std/Clonable>;
    }
}
