#=lang/parser/ASTConstruction: {

  newASTSelf => "TODO";

  newASTConstantWithValue: value => "TODO";
  newASTArrayWithExpressions: exprs => "TODO";

  newASTBuiltinWithName: name Args: args HasVarargs: varargs => "TODO";

  newASTCallWithSubject: subject Args: args HasVarargs: varargs => "TODO";

  newASTSendWithSubject: subject Message: msg Args: args HasVarargs: varargs => "TODO";

  newASTAssignmentWithLHS: lhs RHS: rhs => "TODO";

  newASTBarWithType: type Var: var Value: value Followup: followup => "TODO";

  newASTCompoundWithInstructions: instructions => "TODO";

  newASTBlockWithArgs: args Body: body => "TODO";

  newASTReturnWithValue: value => "TODO";

  newASTAsWithLHS: lhs RHS: rhs => "TODO";
},

#=lang/parser: {

    Parser = {
        tokenizer;

        IsBin(c) => false;  "TODO"

        parseExpression => parseExpressionWithFollowups: true;
        parseExpressions => parseExpressionsWithTerminator: TokenType RPAREN;
        parseCompound => parseCompoundWithTerminator: TokenType RPAREN;

        parseOptionalType => (
            | the_type <- false |  "TODO: Find a better value (maybe 'any')"
            (check: TokenType LBRACK) if: [
                the_type <- parseExpression.
                expect: TokenType RBRACK
            ].
          ^ the_type
        );

        parseBar => (
            |
              type    <- parseOptionalType,
              varname <- (expect: TokenType IDENTIFIER) payload,
              value
            |

            (check: TokenType ASSIGNMENT) if: [
                value <- parseExpression
            ] else: [
                value <- newASTSelf
            ].

            check: TokenType SEPARATOR.

            (check: TokenType BAR) if: [
              ^ newASTBarWithType: type
                              Var: varname
                            Value: value
                         Followup: parseExpression
            ] else: [
              ^ newASTBarWithType: type
                              Var: varname
                            Value: value
                         Followup: parseBar
            ]
        );

        parseCompoundWithTerminator: terminator => (
          ^ newASTCompoundWithInstructions: (parseExpressionsWithTerminator: terminator)
        );

        parseBlock => (
            |
                parameters <- (std util Vector) new,
                varargs    <- false,
                the_type,
                key
            |
            [
              begin
                if: [check: TokenType COLON] then: [
                  the_type <- parseOptionalType.
                  key      <- (expect: TokenType IDENT) payload.
                  parameters append: (key & the_type).
                  (check: TokenType BAR) unless: [
                      expect: TokenType SEPARATOR
                  ]
                ] ~
                if: [check: TokenType ELLIPSIS] then: [
                    varargs <- true.
                    expect: TokenType BAR
                ] ~
                default: [
                  ^ newASTBlockWithArgs: (parameters)
                             HasVarargs: (varargs)
                                   Body: (parseCompoundWithTerminator: TokenType RBRACK)
                ]
            ] repeat.
        );

        parseArray => (
            newASTArrayWithExpressions: parseExpressions
        );

        parseInterface => "TODO";
        parseObject => "TODO";

        parseSimpleExpressionWithFollowups: followups => (
            | kw |

            (check: TokenType SELF)       if: [ ^ newASTSelf     ].
            (check: TokenType LPAREN)     if: [ ^ parseCompound  ].
            (check: TokenType LBRACK)     if: [ ^ parseBlock     ].
            (check: TokenType LCURLY)     if: [ ^ parseObject    ].
            (check: TokenType HASHLPAREN) if: [ ^ parseArray     ].
            (check: TokenType PERCLBRACK) if: [ ^ parseInterface ].

            kw <- check: TokenType KEY.
            kw if: [
                (check: TokenType LPAREN) if: [
                    parseArglist let: [ :arglist |
                      ^ newASTBuiltinWithName: (kw payload)
                                         Args: (arglist first)
                                   HasVarargs: (arglist second)
                    ]
                ].
              ^ kw payload
            ].

            kw <- check: TokenType STRING.
            kw if: [ ^ newASTConstantWithValue: (kw payload) ].

            kw <- check: TokenType NUMBER.
            kw if: [ ^ newASTConstantWithValue: (kw payload) ].

            kw <- check: TokenType CHARACTER.
            kw if: [ ^ newASTConstantWithValue: (kw payload) ].

          ^ newASTSelf
        );

        parseSendWithAST: ast Followups: followups => (
            |
                name    <- '',
                args    <- (std util Vector) new,
                varargs <- false,
                bin     <- false,
                kw      <- check: TokenType IDENTIFIER
            |

            kw unless: [ ^ ast ].

            [ kw ] while: [
                name <- name + (kw payload asString).
                | lastchar <- name asVector at: -1 |
                IsBin(lastchar) if: [
                    bin <- true.
                    allow_followups if: [
                        args append: (parseExpressionWithFollowups: false)
                    ] else: [
                        kw fail.
                      ^ ast
                    ].
                ].
                (lastchar != #\:) if: [
                    kw <- false
                ] else: [
                    kw <- check: TokenType IDENTIFIER
                ]
            ].

            ([ bin not ] and: [ check: TokenType LPAREN ]) if: [
                parseArglist let: [ :arglist |
                    arglist first do: [ :e | args append: e ].
                    varargs <- arglist second
                ]
            ].

          ^ newASTSendWithSubject: (ast)
                          Message: (name asKey)
                             Args: (args)
                       HasVarargs: (arglist second)
        );

        parseExpressionWithFollowups: followups => (
            ([ allow_followups ] and: [ check: TokenType CARET ]) if: [
              ^ newASTReturnWithValue: (parseExpressionWithFollowups: followups)
            ].
            ([ allow_followups ] and: [ check: TokenType BAR ]) if: [ ^ parseBar ].

            |
                ast <- parseSimpleExpressionWithFollowups: followups,
                next <- false
            |

            [
                next <- ast.
                ast  <- parseSendWithAST: ast Followups: followups.
                begin
                  if: [ check: TokenType LPAREN ] then: [
                    parseArglist let: [
                      :arglist | ast <- newASTCallWithSubject: (ast)
                                                         Args: (arglist first)
                                                   HasVarargs: (arglist second)
                    ]
                  ] ~
                  if: [ check: TokenType AS ] then: [
                      ast <- newASTAsWithLHS: (ast)
                                         RHS: (parseExpressionWithFollowups: false)
                  ] ~
                  if: [ check: TokenType ASSIGNMENT ] then: [
                      ast <- newASTAssignmentWithLHS: (ast)
                                                 RHS: (parseExpressionWithFollowups: followups)
                  ] ~
                  if: [ check: TokenType TILDE ] then: [

                  ] ~
                  if: [ ast is: next ] then: [
                    ^ ast
                  ] ~
                default: []
            ] repeat.
        );

        parseExpressionsWithTerminator: terminator => (
            | exprs <- (std util Vector) new |
            [ check: terminator ] until: [
                exprs append: parseExpression.
                (check: terminator) if: [ ^ exprs ].
                expect: TokenType SEPARATOR
            ].
          ^ exprs
        );

        parseArglist => (
            | exprs <- (std util Vector) new |
            [ check: TokenType RPAREN ] until: [
                (check: TokenType ELLIPSIS) if: [
                    expect: TokenType RPAREN.
                  ^ exprs & true
                ].
                exprs append: (parseExpression).
                (check: TokenType RPAREN) if: [ ^ exprs & false ].
                expect: TokenType SEPARATOR
            ].
          ^ exprs & false
        );

        with inherited construction = #<:lang/parser/ASTConstruction>;
        with inherited shared = #<:lang/parser/SharedBehavior>;
        with inherited parent = #<:std/Clonable>;
    }
}
