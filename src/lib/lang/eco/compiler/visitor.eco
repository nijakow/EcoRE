
#=lang/eco/compiler/AssignmentVisitor: {
    compiler, rhs, visitor;

    initWithCompiler: _compiler RHS: _rhs Visitor: v => (
       compiler <- _compiler.
       rhs      <- _rhs.
       visitor  <- v.
      ^ self
    );

    visitUnknown: ast => ( io out << 'Visiting unknown AST for assignment'. io out newline. io out commit );

    visitSend: ast => (
        (ast subject isSelfAST) if: [
            (compiler isLocal: ast message) if: [
                rhs acceptVisitor: visitor.
                compiler storeVariable: ast message
                             IfPresent: [ ^ ]
                          IfNotPresent: [
                              io out << 'Local bound and not bound at the same time!'.
                              io out newline.
                              io out commit.
                            ^
                          ]
            ]
        ].
        ast subject acceptVisitor: visitor.
        compiler push.
        rhs acceptVisitor: visitor.
        compiler push.
        compiler assignWithKey: ast message
    );

    with inherited parent = #<:std/Clonable>;
},


#=lang/eco/compiler/Visitor: {
    compiler, environment;

    initWithCompiler: _compiler Environment: _env => (
       compiler    <- _compiler.
       environment <- _env.
      ^ self
    );

    visitUnknown: ast => ( io out << 'Visiting unknown AST'. io out newline. io out commit );
    
    visitSelf: ast => compiler loadSelf;
    
    visitConstant: ast => compiler loadConstant: ast constantValue;

    visitCompound: ast => (
        compiler pushNormalScope.
        ast getExprs do: [ :e | e acceptVisitor: self ].
        compiler popScope.
    );

    visitBlock: ast => (
        compiler pushBlockScope.
        ast getArgs do: [ :arg | compiler addParameter: (arg getName) ].
        ast hasVarargs if: [ compiler enableVarargs ].
        ast getBody acceptVisitor: self.
        compiler popBlockScope
    );

    visitBuiltin: ast => (
        | args <- ast getArgs |
        args do: [ :arg | arg acceptVisitor: self. compiler push ].
        compiler builtinWithMessage: ast getName ArgCount: args size Varargs: ast getVarargs
    );

    visitCall: ast => (
        | args <- ast getArgs |
        ast subject acceptVisitor: self.
        compiler push.
        args do: [ :arg | arg acceptVisitor: self. compiler push ].
        compiler sendWithMessage: #'value' ArgCount: args size + 1 Varargs: ast getVarargs
    );

    visitSend: ast => (
        | args <- ast getArgs |

        (ast subject isSelfAST) if: [
            compiler loadVariable: ast message IfPresent: [ ^ ] IfNotPresent: []
        ].
        ast subject acceptVisitor: self.
        compiler push.
        args do: [ :arg | arg acceptVisitor: self. compiler push ].
        compiler sendWithMessage: ast message ArgCount: args size + 1 Varargs: ast getVarargs
    );

    visitReturn: ast => (
        ast returnValue acceptVisitor: self.
        compiler fullReturn
    );

    visitVariableDeclaration: ast => (
        compiler bindVariable: ast getName.
        ast getValue acceptVisitor: self.
        compiler storeVariable: ast getName.
        ast getFollowup acceptVisitor: self
    );

    visitAssignment: ast => (
        | v <- (AssignmentVisitor clone) initWithCompiler: compiler RHS: ast rhs Visitor: self |
        ast lhs acceptVisitor: v
    );

    visitAs: ast => (
        "TODO"
        lhs acceptVisitor: self
    );

    visitArray: ast => (
        | array <- std util newArray: ast exprs size |
        ast exprs forEach: [ :i, :v | array at: i put: (v evaluateInEnv: environment) ].
        compiler loadConstant: array
    );

    visitInterface: ast => (
        | i <- %[] |
        "TODO, FIXME, XXX: Move this builtin to a different place!"
        ast parents do: [ :p | i <- i addParent: (p evaluateInEnv: environment) ].
        ast entries do: [ :e | i <- e addToInterface: i WithEnv: environment ].
        compiler loadConstant: i
    );

    visitMolecule: ast => (
        | m <- #'ecosphere.ecore.clone'({}) |  "TODO: Use a different mechanism, maybe Clone: obj"
        "TODO: Parent entries"
        ast slots do: [ :e | e addToMolecule: m WithEnv: environment ].
        compiler loadConstant: m
    );

    "TODO: Implements interface lang/eco/ast/IVisitor"
    with inherited parent = #<:std/Clonable>;
    with inherited module = #<:lang/eco/compiler>;
} 
