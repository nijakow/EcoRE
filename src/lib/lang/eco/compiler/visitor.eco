
#=lang/eco/compiler/AssignmentVisitor: {
    with inherited parent = #<:std/Clonable>;

    compiler, rhs, visitor;

    initWithCompiler: _compiler RHS: _rhs Visitor: v => (
       compiler <- _compiler.
       rhs      <- _rhs.
       visitor  <- v.
      ^ self
    );

    visitUnknown: ast => ( io out << 'Visiting unknown AST for assignment'. io out newline. io out commit );

    visitSend: ast => (
        (ast subject isImplicitAST) if: [
            (compiler isLocal: ast message) if: [
                compiler storeVariable: ast message
                             Interlude: [ rhs acceptVisitor: visitor ]
                             IfPresent: [ ^ ]
                          IfNotPresent: [
                              io out << 'Local bound and not bound at the same time!'.
                              io out newline.
                              io out commit.
                            ^
                          ]
            ]
        ].
        ast subject acceptVisitor: visitor.
        compiler push.
        rhs acceptVisitor: visitor.
        compiler push.
        compiler assignWithKey: ast message
    );
},


#=lang/eco/compiler/Visitor: {
    "TODO: Implements interface lang/eco/ast/IVisitor"
    static with inherited parent = #<:std/Clonable>;
    with inherited module = #<:lang/eco/compiler>;

    compiler, environment, host, nexthost;

    initWithCompiler: _compiler Environment: _env => initWithCompiler: _compiler Environment: _env Host: lobby;
    initWithCompiler: _compiler Environment: _env Host: host => initWithCompiler: _compiler Environment: _env Host: host NextHost: host;

    initWithCompiler: _compiler Environment: _env Host: _host NextHost: _nexthost => (
       compiler    <- _compiler.
       environment <- _env.
       host        <- _host.
       nexthost    <- _nexthost.
     ^ self
    );

    protected EvaluateExpression: expr => expr evaluateInEnv: environment Host: nexthost;

    visitUnknown: ast => ( io out << 'Visiting unknown AST'. io out newline. io out commit );

    visitImplicit: ast => compiler loadSelf;
    
    visitSelf: ast => compiler loadSelf;

    visitMy: ast => compiler loadMy;

    visitHostRef: ast => compiler loadConstant: host;

    visitResend: ast => ast resendValue acceptVisitor: self; "TODO!"
    
    visitConstant: ast => compiler loadConstant: ast constantValue;

    visitCompound: ast => (
        compiler pushNormalScope.
        ast getExprs do: [ :e | e acceptVisitor: self ].
        compiler popScope.
    );

    visitBlock: ast => (
        compiler pushBlockScope.
        ast getArgs do: [ :arg | compiler addParameter: (arg getName) ].
        ast hasVarargs if: [ compiler enableVarargs ].
        ast getBody acceptVisitor: self.
        compiler popBlockScope
    );

    visitBuiltin: ast => (
        | args <- ast getArgs |
        args do: [ :arg | arg acceptVisitor: self. compiler push ].
        compiler builtinWithMessage: ast getName ArgCount: args size Varargs: ast getVarargs
    );

    visitCall: ast => (
        | args <- ast getArgs |
        ast subject acceptVisitor: self.
        compiler push.
        args do: [ :arg | arg acceptVisitor: self. compiler push ].
        compiler sendWithMessage: #'value' ArgCount: args size + 1 Varargs: ast getVarargs
    );

    visitSend: ast => (
        | args <- ast getArgs |

        (ast subject isImplicitAST) if: [
            compiler loadVariable: ast message IfPresent: [ ^ ] IfNotPresent: []
        ].
        ast subject acceptVisitor: self.
        compiler push.
        args do: [ :arg | arg acceptVisitor: self. compiler push ].
        ast subject isResendAST
            if: [ compiler resendWithMessage: ast message ArgCount: args size + 1 Varargs: ast getVarargs ]
          else: [ compiler   sendWithMessage: ast message ArgCount: args size + 1 Varargs: ast getVarargs ]
    );

    visitReturn: ast => (
        ast returnValue acceptVisitor: self.
        compiler fullReturn
    );

    visitVariableDeclaration: ast => (
        compiler bindVariable: ast name Type: (EvaluateExpression: ast type).
        compiler storeVariable: ast name Interlude: [ ast getValue acceptVisitor: self ].
        ast getFollowup acceptVisitor: self
    );

    visitAssignment: ast => (
        | v <- (AssignmentVisitor clone) initWithCompiler: compiler RHS: ast rhs Visitor: self |
        ast lhs acceptVisitor: v
    );

    visitAs: ast => (
        "TODO"
        lhs acceptVisitor: self
    );

    visitArray: ast => (
        | array <- std util newArray: ast exprs size |
        ast exprs forEach: [ :i, :v | array at: i put: (EvaluateExpression: v) ].
        compiler loadConstant: array
    );

    visitInterface: ast => (
        | i <- %[] |
        "TODO, FIXME, XXX: Move this builtin to a different place!"
        ast parents do: [ :p | i <- i addParent: (EvaluateExpression: p) ].
        ast entries do: [ :e | i <- e addToInterface: i WithEnv: environment Host: nexthost ].
        compiler loadConstant: i
    );

    visitMolecule: ast => (
        | m <- #'ecosphere.ecore.clone'({}) |  "TODO: Use a different mechanism, maybe Clone: obj"
        "TODO: Parent entries"
        ast slots do: [ :e | e addToMolecule: m WithEnv: environment Host: nexthost ].
        compiler loadConstant: m
    );
} 
