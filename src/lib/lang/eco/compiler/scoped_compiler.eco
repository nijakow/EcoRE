
#=lang/eco/compiler/ScopedCompiler: {
    scopes;

    init => (
        scopes     <- newScope.
        addParameter: #'self'.
      ^ self
    );

    private newBlockContextWithParent: p => (#<:lang/eco/compiler/ScopeSharedInfo> clone) initWithLexicalParent: p;
    private newBlockContext => #<:lang/eco/compiler/ScopeSharedInfo> new;
    private newScopeFromBlockContext: bc => (#<:lang/eco/compiler/Scope> clone) initWithShared: bc;
    private newScope => newScopeFromBlockContext: newBlockContext;

    private localCompiler => scopes compiler;

    pushNormalScope => scopes <- scopes createSubscope;
    pushBlockScope => (
        scopes <- newScopeFromBlockContext: (newBlockContextWithParent: scopes).
        addParameter: #'self'
    );
    popScope => scopes <- scopes parentScope;
    popBlockScope => (
        | c <- finish |
        scopes lexicalParentScope yes: [ :lp | scopes <- lp ]
                                   no: [ "TODO: Error" ].
        loadClosure: c
    );

    finish => scopes finish;

    loadSelf => localCompiler loadSelf;
    loadConstant: c => localCompiler loadConstant: c;
    loadClosure: c => localCompiler loadClosure: c;

    push => localCompiler push;

    sendWithMessage: msg ArgCount: args Varargs: varargs => (
        localCompiler sendWithMessage: msg ArgCount: args Varargs: varargs
    );
    builtinWithMessage: msg ArgCount: args Varargs: varargs => (
        localCompiler builtinWithMessage: msg ArgCount: args Varargs: varargs
    );
    assignWithKey: key => localCompiler assignWithKey: key;

    returnWithDepth: depth => localCompiler returnWithDepth: depth;
    fullReturn => returnWithDepth: scopes depth;

    addParameter: name => scopes addParameter: name;
    enableVarargs => scopes enableVarargs;

    bindVariable: name => scopes bindVariable: name;
    loadVariable: name IfPresent: present IfNotPresent: notpresent => (
        scopes findVariable: name
                    IfFound: [ :info, :depth |
                                localCompiler loadRegister: (info index) Depth: depth.
                                present value
                             ]
                 IfNotFound: notpresent
    );
    storeVariable: name IfPresent: present IfNotPresent: notpresent => (
        scopes findVariable: name
                    IfFound: [ :info, :depth |
                                localCompiler moveLastValueToReg: (info index) Depth: depth.
                                present value
                             ]
                 IfNotFound: notpresent
    );
    storeVariable: name => storeVariable: name IfPresent: [] IfNotPresent: [];
    isLocal: name => scopes findVariable: name IfFound: [ :info, :depth | ^ true ] IfNotFound: [ ^ false ];

    with inherited parent = #<:std/Clonable>;
}
