
#=lang/eco/compiler/Compiler: {
    static with inherited parent = #<:std/Clonable>;
    with inherited module = #<:lang/eco/compiler>;

    writer, depth, regAlloc, lastValue;

    initWithWriter: w Depth: d => (
        writer    <- w.
        depth     <- d.
        regAlloc  <- RegisterAllocator new.
        lastValue <- selfValue.
      ^ self
    );
    initWithDepth: d => initWithWriter: (CodeWriter new) Depth: d;

    finishWithArgs: args Varargs: varargs => (
        returnWithDepth: 0.
      ^ writer finishWithArgs: args Varargs: varargs
    );

    lastValue: nv => (dropLastValue. lastValue <- nv);
    dropLastValue => lastValue isStack if: [ writer writeDrop ];
    pushLastValue => (
        lastValue ifRegister: [ writer writeLoad: lastValue details bcIndex Depth: lastValue depth.
                                writer writePush.
                              ]
                  ifConstant: [ writer writeConst: lastValue constantValue.
                                writer writePush.
                              ]
                   ifClosure: [ writer writeClosure: (lastValue closureValue).
                                writer writePush.
                              ]
                     ifStack: [].
        lastValue <- selfValue
    );
    moveLastValueToReg: r Depth: d => (
        lastValue ifRegister: [ writer writeLoad: lastValue details bcIndex Depth: lastValue depth.
                                writer writeStore: r bcIndex Depth: d.
                              ]
                  ifConstant: [ writer writeConst: (lastValue constantValue).
                                writer writeStore: r bcIndex Depth: d.
                              ]
                   ifClosure: [ writer writeClosure: (lastValue closureValue).
                                writer writeStore: r bcIndex Depth: d.
                              ]
                     ifStack: [ writer writePop.
                                writer writeStore: r bcIndex Depth: d.
                              ].
        lastValue <- registerValue: r Depth: d
    );
    moveLastValueToReg: r => moveLastValueToReg: r Depth: 0;

    selfValue => registerValue: (ValueType Arg: 0) Depth: 0;
    constantValue: c => (ValueType Constant) clone initWithValue: c;
    closureValue: c => (ValueType Closure) clone initWithValue: c;
    registerValue: details Depth: d => (ValueType Register) clone initWithDetails: details Depth: d;
    stackTopValue => (ValueType Stack) clone;

    loadSelf => lastValue: selfValue;
    loadConstant: c => lastValue: (constantValue: c);
    loadClosure: c => lastValue: (closureValue: c);
    loadRegister: r Depth: d => lastValue: (registerValue: r Depth: d);
    loadRegister: r => loadRegister: r Depth: 0;

    push => pushLastValue;
    drop => loadSelf;

    builtinWithMessage: msg ArgCount: args Varargs: varargs => (
        writer writeBuiltin: msg Args: args Varargs: varargs.
        lastValue <- stackTopValue
    );
    builtinWithMessage: msg ArgCount: args => (
        builtinWithMessage: msg ArgCount: args Varargs: false
    );

    sendWithMessage: msg ArgCount: args Varargs: varargs => (
        writer writeSend: msg Args: args Varargs: varargs.
        lastValue <- stackTopValue
    );
    sendWithMessage: msg ArgCount: args => (
        sendWithMessage: msg ArgCount: args Varargs: false
    );

    resendWithMessage: msg ArgCount: args Varargs: varargs => (
        writer writeResend: msg Args: args Varargs: varargs.
        lastValue <- stackTopValue
    );
    resendWithMessage: msg ArgCount: args => (
        resendWithMessage: msg ArgCount: args Varargs: false
    );

    assignWithKey: key => (
        writer writeAssign: key.
        lastValue <- stackTopValue
    );

    returnWithDepth: depth => (
        pushLastValue.
        writer writeReturn: depth
    );
}
