
#=lang/eco/compiler/Compiler: {
    static with inherited parent = #<:std/Clonable>;
    with inherited module = #<:lang/eco/compiler>;

    writer, depth, regAlloc, lastValue;

    initWithWriter: w Depth: d => (
        writer    <- w.
        depth     <- d.
        regAlloc  <- RegisterAllocator new.
        lastValue <- selfValue.
      ^ self
    );
    initWithDepth: d => initWithWriter: (CodeWriter new) Depth: d;

    finishWithArgs: args Varargs: varargs => (
        returnWithDepth: 0.
      ^ writer finishWithArgs: args Varargs: varargs
    );

    lastValue: nv => (dropLastValue. lastValue <- nv);
    dropLastValue => lastValue isStack if: [ writer writeDrop ];
    pushLastValue => (
        lastValue ifRegister: [ (lastValue depth isZero)
                                     if: [ writer writePushReg: lastValue details bcIndex ]
                                   else: [ regAlloc withAllocatedRegister: [
                                             :r | moveLastValueToReg: r.
                                                  pushLastValue
                                           ]
                                         ]
                              ]
                  ifConstant: [ writer writePushConst: lastValue constantValue ]
                   ifClosure: [ regAlloc withAllocatedRegister: [
                                  :r | moveLastValueToReg: r.
                                       pushLastValue
                                ]
                              ]
                     ifStack: [].
        lastValue <- selfValue
    );
    moveLastValueToReg: r Depth: d => (
        lastValue ifRegister: [ (lastValue depth isZero)
                                     if: [ writer writeReg: (lastValue details bcIndex) ToReg: (r bcIndex) Depth: d ]
                                   else: [ (d isZero) if: [
                                              writer writeReg: (lastValue details bcIndex) Depth: (lastValue depth) ToReg: (r bcIndex)
                                           ] else: [
                                              regAlloc withAllocatedRegister: [
                                                :tmpReg | moveLastValueToReg: tmpReg.
                                                          moveLastValueToReg: r Depth: d
                                              ]
                                           ]
                                         ]
                              ]
                  ifConstant: [ (d isZero)
                                     if: [ writer writeConst: (lastValue constantValue) ToReg: (r bcIndex) ]
                                   else: [ regAlloc withAllocatedRegister: [
                                             :tmpReg | moveLastValueToReg: tmpReg.
                                                       moveLastValueToReg: r Depth: d
                                           ]
                                         ]
                              ]
                   ifClosure: [ (d isZero)
                                     if: [ writer writeClosure: (lastValue closureValue) ToReg: (r bcIndex) ]
                                   else: [ regAlloc withAllocatedRegister: [
                                             :tmpReg | moveLastValueToReg: tmpReg.
                                                       moveLastValueToReg: r Depth: d
                                           ]
                                         ]
                              ]
                     ifStack: [ (d isZero)
                                     if: [ writer writePopReg: (r bcIndex) ]
                                   else: [ regAlloc withAllocatedRegister: [
                                             :tmpReg | moveLastValueToReg: tmpReg.
                                                       moveLastValueToReg: r Depth: d
                                           ]
                                         ]
                              ].
        lastValue <- registerValue: r Depth: d
    );
    moveLastValueToReg: r => moveLastValueToReg: r Depth: 0;

    selfValue => registerValue: (ValueType Arg: 0) Depth: 0;
    constantValue: c => (ValueType Constant) clone initWithValue: c;
    closureValue: c => (ValueType Closure) clone initWithValue: c;
    registerValue: details Depth: d => (ValueType Register) clone initWithDetails: details Depth: d;
    stackTopValue => (ValueType Stack) clone;

    loadSelf => lastValue: selfValue;
    loadConstant: c => lastValue: (constantValue: c);
    loadClosure: c => lastValue: (closureValue: c);
    loadRegister: r Depth: d => lastValue: (registerValue: r Depth: d);
    loadRegister: r => loadRegister: r Depth: 0;

    push => pushLastValue;
    drop => loadSelf;

    builtinWithMessage: msg ArgCount: args Varargs: varargs => (
        writer writeBuiltin: msg Args: args Varargs: varargs.
        lastValue <- stackTopValue
    );
    builtinWithMessage: msg ArgCount: args => (
        builtinWithMessage: msg ArgCount: args Varargs: false
    );

    sendWithMessage: msg ArgCount: args Varargs: varargs => (
        writer writeSend: msg Args: args Varargs: varargs.
        lastValue <- stackTopValue
    );
    sendWithMessage: msg ArgCount: args => (
        sendWithMessage: msg ArgCount: args Varargs: false
    );

    assignWithKey: key => (
        writer writeAssign: key.
        lastValue <- stackTopValue
    );

    returnWithDepth: depth => (
      pushLastValue.
      writer writeReturn: depth
    );
}
