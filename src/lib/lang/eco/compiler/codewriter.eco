
#=lang/eco/compiler/CodeWriter: {
    bytes, constants, closures, maxRegister;

    init => (
        bytes       <- std util newVector.
        constants   <- std util newVector.
        closures    <- std util newVector.
        maxRegister <- 0.
      ^ self
    );

    finishWithArgs: args Varargs: varargs => (
        /"
            termio out << 'Dumping newly created code object...'. termio out newline.
            termio out << bytes. termio out newline.
            termio out << constants. termio out newline.
            termio out << closures. termio out newline.
            termio out << 'Registers: ' << (maxRegister + 1) << ' Args: ' << args << ' Varargs: ' << varargs. termio out newline.
            termio out commit.
        "/
        #'ecosphere.ecore.object.code.new'(bytes asBlob,
                                           constants asArray,
                                           closures asArray,
                                           maxRegister + 1,
                                           args,
                                           varargs if: 1 else: 0)
    );

    private introduceRegister: r => maxRegister <- maxRegister max: r;

    writeU8: b => bytes append: b;
    writeU16: s => (
        writeU8: (s bitAnd: 0xff).
        writeU8: ((s rshift: 8) bitAnd: 0xff)
    );
    addConstant: c => (
        writeU16: constants size.
        constants append: c
    );
    addClosure: c => (
        (closures find: c)
            yes: [ :i | writeU16: i         ]
             no: [ writeU16: closures size.
                   closures append: c       ]
    );

    writeNOOP => writeU8: Bytecodes NOOP;

    writeConst: c ToReg: r => (
        introduceRegister: r.
        writeU8: Bytecodes CONST.
        writeU8: r.
        addConstant: c
    );

    writePushConst: c => (
        writeU8: Bytecodes PUSHC.
        addConstant: c
    );

    writeClosure: c ToReg: r => (
        introduceRegister: r.
        writeU8: Bytecodes CLOSURE.
        writeU8: r.
        addClosure: c
    );

    writePushReg: r => (
        introduceRegister: r.
        writeU8: Bytecodes PUSH.
        writeU8: r
    );

    writePopReg: r => (
        introduceRegister: r.
        writeU8: Bytecodes POP.
        writeU8: r
    );

    writeDrop => writeU8: Bytecodes DROP;

    writeDup => writeU8: Bytecodes DUP;

    writeReg: src ToReg: dst => (
        introduceRegister: src.
        introduceRegister: dst.
        writeU8: Bytecodes R2R.
        writeU8: dst.
        writeU8: src
    );

    writeReg: src ToReg: dst Depth: depth => (
        (depth isZero)
              if: [ writeReg: src ToReg: dst ]
            else: [ introduceRegister: src.
                    writeU8: Bytecodes R2L.
                    writeU8: dst.
                    writeU8: depth.
                    writeU8: src             ]
    );

    writeReg: src Depth: depth ToReg: dst => (
        (depth isZero)
              if: [ writeReg: src ToReg: dst ]
            else: [ introduceRegister: dst.
                    writeU8: Bytecodes L2R.
                    writeU8: dst.
                    writeU8: src.
                    writeU8: depth           ]
    );

    writeBuiltin: key Args: args Varargs: varargs => (
        (varargs) if: [ writeU8: Bytecodes BUILTINV ]
                else: [ writeU8: Bytecodes BUILTIN  ].
        writeU8: args.
        addConstant: key
    );

    writeBuiltin: key Args: args => writeBuiltin: key Args: args Varargs: false;

    writeSend: message Args: args Varargs: varargs => (
        (varargs) if: [ writeU8: Bytecodes SENDV ]
                else: [ writeU8: Bytecodes SEND  ].
        writeU8: args.
        addConstant: message
    );

    writeSend: message Args: args => writeSend: message Args: args Varargs: false;

    writeAssign: key => (
        writeU8: Bytecodes ASSIGN.
        addConstant: key
    );

    writeAs => writeU8: Bytecodes AS;

    writeReturn: depth => (
        writeU8: Bytecodes RETURN.
        writeU8: depth
    );

    Bytecodes = #<:lang/eco/compiler/Bytecodes>;
    with inherited parent = #<:std/Clonable>;
}
