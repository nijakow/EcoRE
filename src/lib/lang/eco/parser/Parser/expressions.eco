#=lang/eco/parser/Parser/Followups: {
    all = { level => 2, dec => #<:lang/eco/parser/Parser/Followups> binary },
    binary = { level => 1, dec => #<:lang/eco/parser/Parser/Followups> unary },
    unary = { level => 0, dec => self }
},

#=lang/eco/parser/Parser/Expression: {
    parseExpression => parseExpressionWithFollowups: #<:lang/eco/parser/Parser/Followups> all;
    parseExpressions => parseExpressionsWithTerminator: TokenType RPAREN;

    parseResend => (
        | v <- parseExpression |
        expect: TokenType RPAREN.
      ^ newASTResendWithValue: v
    );

    parseSimpleExpressionWithFollowups: followups => (
        (check: TokenType SELF)       if: [ ^ newASTSelf     ].
        (check: TokenType MY)         if: [ ^ newASTMy       ].
        (check: TokenType LPAREN)     if: [ ^ parseCompound  ].
        (check: TokenType LBRACK)     if: [ ^ parseBlock     ].
        (check: TokenType LCURLY)     if: [ ^ parseMolecule  ].
        (check: TokenType HASHLPAREN) if: [ ^ parseArray     ].
        (check: TokenType PERCLBRACK) if: [ ^ parseInterface ].
        (check: TokenType DOLLAR)     if: [ ^ newASTHostRef  ].
        (check: TokenType RESEND)     if: [ ^ parseResend    ].

        (check: TokenType KEY) when: [ :kw |
            (check: TokenType LPAREN) if: [
                parseArglist let: [ :arglist |
                  ^ newASTBuiltinWithName: (kw payload)
                                     Args: (arglist first)
                               HasVarargs: (arglist second)
                ]
            ].
          ^ newASTConstantWithValue: kw payload
        ].

        (check: TokenType STRING) when: [ :kw | ^ newASTConstantWithValue: (kw payload) ].

        (check: TokenType NUMBER) when: [ :kw | ^ newASTConstantWithValue: (kw payload) ].

        (check: TokenType CHARACTER) when: [ :kw | ^ newASTConstantWithValue: (kw payload) ].

      ^ newASTImplicit
    );

    parseExpressionWithFollowups: followups => (
        ([ followups level > 1 ] and: [ check: TokenType CARET ]) if: [
          ^ newASTReturnWithValue: (parseExpressionWithFollowups: followups)
        ].
        ([ followups level > 1 ] and: [ check: TokenType BAR ]) if: [ ^ parseBar ].

        |
            ast <- parseSimpleExpressionWithFollowups: followups,
            next <- false
        |

        [
            next <- ast.
            ast  <- parseSendWithAST: ast Followups: followups.
            begin
              if: [ check: TokenType LPAREN ] then: [
                parseArglist let: [
                  :arglist | ast <- newASTCallWithSubject: (ast)
                                                     Args: (arglist first)
                                               HasVarargs: (arglist second)
                ]
              ] ~
              if: [ check: TokenType AS ] then: [
                  ast <- newASTAsWithLHS: (ast)
                                     RHS: (parseExpressionWithFollowups: false)
              ] ~
              if: [ check: TokenType ASSIGNMENT ] then: [
                  ast <- newASTAssignmentWithLHS: (ast)
                                             RHS: (parseExpressionWithFollowups: followups)
              ] ~
              if: [ [ followups level > 1 ] and: [ check: TokenType TILDE ] ] then: [
              ] ~
              if: [ ast is: next ] then: [
                ^ ast
              ] ~
            default: []
        ] repeat.
    );

    parseExpressionsWithTerminator: terminator => (
        | exprs <- std util newVector |
        [ check: terminator ] until: [
            exprs append: parseExpression.
            (check: terminator) if: [ ^ exprs ].
            expect: TokenType SEPARATOR
        ].
      ^ exprs
    );
}
