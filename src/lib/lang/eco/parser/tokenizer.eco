#=lang/eco/tokenizer: {
    static with inherited _ = #<:std/Module>;

    Token = {
        static with inherited parent = #<:std/Clonable>;

        tokenizer, type, payload;

        with inherited trait = {
            writeOn: writer => writer << 'Token: ' << type.

            tokenizer: tok type: t payload: p => (
                tokenizer <- tok.
                type <- t.
                payload <- p.
              ^ self
            );

            hasType: t => type is: t;
            fail => tokenizer unread: self;
        },
    },
    
    Tokenizer = {
        static with inherited parent = #<:std/Clonable>;
        with inherited shared = #<:lang/eco/parser/SharedBehavior>;

        in, pushbacks;

        init: reader => (
            in <- reader.
            pushbacks <- std util newStack.
          ^ self
        );

        unread: token => pushbacks push: token;

        IsSpace(c) => (
            (c == (char space))   if: [ ^ true ].
            (c == (char tab))     if: [ ^ true ].
            (c == (char newline)) if: [ ^ true ].
            (c == (char return))  if: [ ^ true ].
          ^ false
        );

        IsSpecial(c) => [ '()[]{}.,;|^' contains: c ] or: [ IsSpace(c) ];

        skipWhitespace => (
            [ [ in has ] and: [ IsSpace(in current) ] ] while: [ in forward ]
        );

        peeks: str => in peek: str;

        newTokenWithType: type Payload: pl => (#<:lang/eco/tokenizer> Token) new tokenizer: self type: type payload: pl;
        newTokenWithType: type => newTokenWithType: type Payload: false;

        StringToChar: str => (
            (str size == 1) -> [ ^ str at: 0 ].
            (str equals: '') -> [ ^ $'?' "TODO" ].
            (str equals: 'newline') -> [ ^ $'newline' ].
            (str equals: 'tab') -> [ ^ $'tab' ].
            (str equals: 'escape') -> [ ^ $'escape' ].
          ^ str at: 0
        );

        parseChar => (
            | c <- in next |
            (c == #\\\) if: [
                | n <- in next |
                begin
                    if: [ n == #\\\       ] then: [ ^ n          ] ~
                    if: [ n == #\n        ] then: [ ^ #\\n       ] ~
                    if: [ n == #\'        ] then: [ ^ #\'        ] ~
                    if: [ n == #\"        ] then: [ ^ #\"        ] ~
                default: [ 'Invalid escaped character!' throw ]
            ] else: [
                ^ c
            ].
        );

        parseString: terminator => (
            | sb <- (std io StringWriter) new |

            [ in current == terminator ] until: [
                sb char<< parseChar
            ].

            in forward.

          ^ sb commit
        );

        nextToken => (
            (pushbacks isEmpty) unless: [ ^ pushbacks pop ].

            skipWhitespace.

            (in hasNext) unless: [ ^ newTokenWithType: TokenType EOF ].
            (peeks: '...') if: [ ^ newTokenWithType: TokenType ELLIPSIS   ].
            (peeks: '<-')  if: [ ^ newTokenWithType: TokenType ASSIGNMENT ].
            (peeks: '=>')  if: [ ^ newTokenWithType: TokenType RARROW     ].
            (peeks: '(')   if: [ ^ newTokenWithType: TokenType LPAREN     ].
            (peeks: ')')   if: [ ^ newTokenWithType: TokenType RPAREN     ].
            (peeks: '[')   if: [ ^ newTokenWithType: TokenType LBRACK     ].
            (peeks: ']')   if: [ ^ newTokenWithType: TokenType RBRACK     ].
            (peeks: '{')   if: [ ^ newTokenWithType: TokenType LCURLY     ].
            (peeks: '}')   if: [ ^ newTokenWithType: TokenType RCURLY     ].
            (peeks: '#(')  if: [ ^ newTokenWithType: TokenType HASHLPAREN ].
            (peeks: '%[')  if: [ ^ newTokenWithType: TokenType PERCLBRACK ].
            (peeks: '$(')  if: [ ^ newTokenWithType: TokenType RESEND     ].
            (peeks: '.')   if: [ ^ newTokenWithType: TokenType SEPARATOR  ].
            (peeks: ',')   if: [ ^ newTokenWithType: TokenType SEPARATOR  ].
            (peeks: ';')   if: [ ^ newTokenWithType: TokenType SEPARATOR  ].
            (peeks: ':')   if: [ ^ newTokenWithType: TokenType COLON      ].
            (peeks: '|')   if: [ ^ newTokenWithType: TokenType BAR        ].
            (peeks: '^')   if: [ ^ newTokenWithType: TokenType CARET      ].
            (peeks: '\'')  if: [ ^ newTokenWithType: TokenType STRING Payload: (parseString: #\') ].
            (peeks: '#\'') if: [ ^ newTokenWithType: TokenType KEY    Payload: ((parseString: #\') asKey) ].
            (peeks: '#=')  if: [ ^ newTokenWithType: TokenType LABEL  Payload: (parseString: #\:) ].
            (peeks: '#<')  if: [ ^ newTokenWithType: TokenType PROXY  Payload: (parseString: #\>) ].
            (peeks: '#\\') if: [ ^ newTokenWithType: TokenType CHARACTER  Payload: parseChar      ].
            (peeks: '$\'') if: [ ^ newTokenWithType: TokenType CHARACTER  Payload: (StringToChar: (parseString: #\')) ].
            (peeks: '$')   if: [ ^ newTokenWithType: TokenType DOLLAR     ].
            (peeks: '"')   if: [ parseString: #\". ^ nextToken ].

            (std text parsing number ParseNumberFromStream: in)
                yes: [ :n | ^ newTokenWithType: TokenType NUMBER Payload: n ].
            
            | sb <- (std io StringWriter) new |

            [ [ in has ] and: [ IsSpecial(in current) not ] ] while: [
                sb char<< (in next).
            ].

            sb <- sb commit.

            (sb equals: '')            if: [ ^ newTokenWithType: TokenType EOF        ].
            (sb equals: 'self')        if: [ ^ newTokenWithType: TokenType SELF       ].
            (sb equals: 'my')          if: [ ^ newTokenWithType: TokenType MY         ].
            (sb equals: 'as')          if: [ ^ newTokenWithType: TokenType AS         ].
            (sb equals: 'with')        if: [ ^ newTokenWithType: TokenType WITH       ].
            (sb equals: 'inherited')   if: [ ^ newTokenWithType: TokenType INHERITED  ].
            (sb equals: 'own')         if: [ ^ newTokenWithType: TokenType OWN        ].
            (sb equals: 'static')      if: [ ^ newTokenWithType: TokenType STATIC     ].
            (sb equals: 'protected')   if: [ ^ newTokenWithType: TokenType PROTECTED  ].
            (sb equals: 'private')     if: [ ^ newTokenWithType: TokenType PRIVATE    ].
            (sb equals: 'final')       if: [ ^ newTokenWithType: TokenType FINAL      ].
            (sb equals: '@deprecated') if: [ ^ newTokenWithType: TokenType DEPRECATED ].
            (sb equals: '=')           if: [ ^ newTokenWithType: TokenType ASSIGNMENT ].
            (sb equals: '~')           if: [ ^ newTokenWithType: TokenType TILDE      ].
          ^ newTokenWithType: (TokenType IDENTIFIER) Payload: (sb asKey)
        );
    }
}
