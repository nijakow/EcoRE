#=lang/eco/tokenizer: {

    PortReader = #<:lang/eco/tokenizer/PortReader>,

    Token = {
        tokenizer, type, payload;

        with inherited trait = {
            writeOn: writer => writer << 'Token: ' << type.

            tokenizer: tok type: t payload: p => (
                tokenizer <- tok.
                type <- t.
                payload <- p.
              ^ self
            );

            hasType: t => type is: t;
            fail => tokenizer unread: self;
        },

        with inherited parent = #<:std/Clonable>;
    },
    
    Tokenizer = {
        in, pushbacks;

        init: reader => (
            in <- reader.
            pushbacks <- std util newVector.
          ^ self
        );

        unread: token => pushbacks push: token;

        IsSpace(c) => (
            (c == (char space))   if: [ ^ true ].
            (c == (char tab))     if: [ ^ true ].
            (c == (char newline)) if: [ ^ true ].
            (c == (char return))  if: [ ^ true ].
          ^ false
        );

        IsSpecial(c) => [ '()[]{}.,;|^' contains: c ] or: [ IsSpace(c) ];

        skipWhitespace => (
            [ [ in has ] and: [ IsSpace(in current) ] ] while: [ in advance ]
        );

        peeks: str => in peeks: str;

        newTokenWithType: type Payload: pl => (#<:lang/eco/tokenizer> Token) new tokenizer: self type: type payload: pl;
        newTokenWithType: type => newTokenWithType: type Payload: false;

        parseString: terminator => (
            | sb <- (std io StringWriter) new |

            [ in current == terminator ] until: [
                | c <- in next |
                (c == #\\) if: [
                    | n <- in next |
                    begin
                      if: [ n == #\\        ] then: [ sb char<< n          ] ~
                      if: [ n == terminator ] then: [ sb char<< terminator ] ~
                    default: [ sb char<< c. sb char<< n ]
                ] else: [
                    sb char<< c
                ].
            ].

            in advance.

          ^ sb commit
        );

        nextToken => (
            (pushbacks isEmpty) unless: [ ^ pushbacks pop ].

            skipWhitespace.

            (in hasNext) unless: [ ^ newTokenWithType: TokenType EOF ].
            (peeks: '...') if: [ ^ newTokenWithType: TokenType ELLIPSIS   ].
            (peeks: '<-')  if: [ ^ newTokenWithType: TokenType ASSIGNMENT ].
            (peeks: '=>')  if: [ ^ newTokenWithType: TokenType RARROW     ].
            (peeks: '(')   if: [ ^ newTokenWithType: TokenType LPAREN     ].
            (peeks: ')')   if: [ ^ newTokenWithType: TokenType RPAREN     ].
            (peeks: '[')   if: [ ^ newTokenWithType: TokenType LBRACK     ].
            (peeks: ']')   if: [ ^ newTokenWithType: TokenType RBRACK     ].
            (peeks: '{')   if: [ ^ newTokenWithType: TokenType LCURLY     ].
            (peeks: '}')   if: [ ^ newTokenWithType: TokenType RCURLY     ].
            (peeks: '#(')  if: [ ^ newTokenWithType: TokenType HASHLPAREN ].
            (peeks: '%[')  if: [ ^ newTokenWithType: TokenType PERCLBRACK ].
            (peeks: '$')   if: [ ^ newTokenWithType: TokenType DOLLAR     ].
            (peeks: '.')   if: [ ^ newTokenWithType: TokenType SEPARATOR  ].
            (peeks: ',')   if: [ ^ newTokenWithType: TokenType SEPARATOR  ].
            (peeks: ';')   if: [ ^ newTokenWithType: TokenType SEPARATOR  ].
            (peeks: ':')   if: [ ^ newTokenWithType: TokenType COLON      ].
            (peeks: '|')   if: [ ^ newTokenWithType: TokenType BAR        ].
            (peeks: '^')   if: [ ^ newTokenWithType: TokenType CARET      ].
            (peeks: '\'')  if: [ ^ newTokenWithType: TokenType STRING Payload: (parseString: #\') ].
            (peeks: '#\'') if: [ ^ newTokenWithType: TokenType KEY    Payload: ((parseString: #\') asKey) ].
            (peeks: '#=')  if: [ ^ newTokenWithType: TokenType LABEL  Payload: (parseString: #\:) ].
            (peeks: '#<')  if: [ ^ newTokenWithType: TokenType PROXY  Payload: (parseString: #\>) ].
            (peeks: '#\\') if: [ ^ newTokenWithType: TokenType CHARACTER  Payload: (in readChar) ].
            (peeks: '"')   if: [ parseString: #\". ^ nextToken ].
            
            | sb <- (std io StringWriter) new |

            [ [ in has ] and: [ IsSpecial(in current) not ] ] while: [
                sb char<< (in next).
            ].

            sb <- sb commit.

            sb parseInt yes: [ :v | ^ newTokenWithType: TokenType NUMBER Payload: v ].

            (sb equals: '')            if: [ ^ newTokenWithType: TokenType EOF        ].
            (sb equals: 'self')        if: [ ^ newTokenWithType: TokenType SELF       ].
            (sb equals: 'as')          if: [ ^ newTokenWithType: TokenType AS         ].
            (sb equals: 'with')        if: [ ^ newTokenWithType: TokenType WITH       ].
            (sb equals: 'inherited')   if: [ ^ newTokenWithType: TokenType INHERITED  ].
            (sb equals: 'own')         if: [ ^ newTokenWithType: TokenType OWN        ].
            (sb equals: 'static')      if: [ ^ newTokenWithType: TokenType STATIC     ].
            (sb equals: 'protected')   if: [ ^ newTokenWithType: TokenType PROTECTED  ].
            (sb equals: 'private')     if: [ ^ newTokenWithType: TokenType PRIVATE    ].
            (sb equals: 'final')       if: [ ^ newTokenWithType: TokenType FINAL      ].
            (sb equals: '@deprecated') if: [ ^ newTokenWithType: TokenType DEPRECATED ].
            (sb equals: '=')           if: [ ^ newTokenWithType: TokenType ASSIGNMENT ].
            (sb equals: '~')           if: [ ^ newTokenWithType: TokenType TILDE      ].
          ^ newTokenWithType: (TokenType IDENTIFIER) Payload: (sb asKey)
        );

        with inherited shared = #<:lang/eco/parser/SharedBehavior>;
        with inherited parent = #<:std/Clonable>;
    }
}
