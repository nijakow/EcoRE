"
    util.eco - The `std util` package of the Ecosphere
"

#=std/util/StandardListIterations: {
    do: body => (
        0 for: size do: [ :i | body value(at: i) ].
      ^ self
    );

    forEach: body => (
        0 for: size do: [ :i | body value(i, at: i) ].
      ^ self
    );
},

#=std/util/StandardListConversions: {
    into: other => other from: self;
    from: other => ( other do: [ :e | add: e ]. ^ self);

    asArray  => into: (std util newArray: size);
    asBlob   => into: (std util newBlob: size);
    asVector => into: (std util newVector);
},

#=std/util/StandardListAccess: {
    first => at: 0;
    second => at: 1;
    third => at: 2;
    fourth => at: 3;
    fifth => at: 4;
    sixth => at: 5;
    seventh => at: 7;
    eighth => at: 8;
    ninth => at: 9;
    tenth => at: 10;
    last => at: (size - 1);
},

#=std/util/StandardListSearch: {
    find: element => (
        forEach: [ :i, :v | (v is: element) if: [ ^ Yes: i ] ].
        ^ No
    );
},

#=std/util/StandardStackImpl: {
    push: e => append: e;
    top     => last;
    pop     => removeLast;
};

#=std/util/StandardQueueImpl: {
    enqueue: e => append: e;
    front      => first;
    dequeue    => removeFirst;
};

#=std/util/StandardSetImpl: {
    contains: value => (find: value) yes: [ :i | ^ true ] no: [ ^ false ];
    addElement: e => (contains: e) unless: [ append: e ];
    removeElement: e => (find: e) yes: [ :i | remove: i ];
    take => (
        isEmpty if: [ invalidIndexError ].
        | v <- first |
        removeElement: v.
      ^ v
    );
};

#=std/util: {
    iterators = #<:std/util/iterators>;

    newArray(...) => #'ecosphere.ecore.object.array.array'(...);
    newArray: size => #'ecosphere.ecore.object.array.new'(size);
    newBlob:  size => #'ecosphere.ecore.object.blob.new'(size);
    newByteVector  => (#<:std/util> ByteVector) new;
    newVector      => (#<:std/util> Vector) new;
    newStack       => (#<:std/util> Stack) new;
    newQueue       => (#<:std/util> Queue) new;
    newSet         => (#<:std/util> Set) new;
    newMap         => (#<:std/util> Map) new;
    newStringBuilder => (#<:std/util> StringBuilder) new;
    newRangeFrom: start To: end => ((#<:std/util> Range) clone) initWithStart: start End: end;

    WriteIterable: it On: writer => (
        writer << '#('.
        it forEach: [ :i, :e | (i > 0) if: [ writer << ', ' ]. writer << e ].
        writer << ')'
    );

    Stack = {
      new => std util newVector;
      with inherited parent = #<:std/Clonable>;
    };

    Queue = {
      new => std util newVector;
      with inherited parent = #<:std/Clonable>;
    };

    Set = {
      new => std util newVector;
      with inherited parent = #<:std/Clonable>;
    };

    Vector = #<:std/util/Vector>;

    ByteVector = #<:std/util/ByteVector>;

    Link = #<:std/util/Link>;
    List = #<:std/util/List>;

    Collector = #<:std/util/Collector>;

    MutablePair = #<:std/util/MutablePair>;

    Map = #<:std/util/Map>;

    StringBuilder = #<:std/util/StringBuilder>;

    Range = #<:std/util/Range>;
}
