
#=std/util/iterators: {

    IteratorTrait = #=std/util/iterators/IteratorTrait: {
        hasNext => has;
        next => [ forward ] returns: current;
        forEach: block => (
            | i <- 0 |
            [ hasNext ] while: [ block value(i, next). i <- i + 1 ]
        );
        do: block => [ hasNext ] while: [ block value(next) ];
        into: acceptor => acceptor from: self;
        check: elem => ([ has ] and: [ current == elem ]) -> [ forward. true ];
        peek: sequence => (
            withReset: [ :reset |
                sequence do: [ :element |
                    ([ has not ] or: [ (current == element) not ]) -> [ reset value. ^ false ].
                    forward.
                ]
            ].
          ^ true
        );
        writeOn: w => w << 'an iterator';
    };

    BiIteratorTrait = #=std/util/iterators/BiIteratorTrait: {
        with inherited parent = #<:std/util/iterators/IteratorTrait>;
        previous => ( backward. current );
    };

    IndexIterator = {
        static with inherited parent = #<:std/Clonable>;

        protected blob,
        protected index;

        with inherited trait = {
            with inherited iteratorTrait = #<:std/util/iterators/BiIteratorTrait>;
            
            init: _blob => (
                blob  <- _blob.
                index <- 0.
              ^ self
            );

            forward => ( index <- index + 1. self );
            backward => ( index <- index - 1. self );

            has => index < blob size;
            hasPrevious => index > 0;

            current => blob at: index;

            withReset: block => (
                | resetIndex <- index |
              ^ block value([ index <- resetIndex ])
            );
        };
    };

    segmented = #<:std/util/iterators/segmented>;
}
