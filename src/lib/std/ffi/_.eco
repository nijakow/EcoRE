
#=std/ffi: {
    private with std = #<:std>;
    
    types = {
        private GetTypeByIndex: index => #'ecosphere.ecore.ffi.type.by_index'(index);

        void => GetTypeByIndex: 0;

        bool => int8;

        uint8 => GetTypeByIndex: 1;
        sint8 => GetTypeByIndex: 2;
        int8  => sint8;
        byte  => int8;

        uint16 => GetTypeByIndex: 3;
        sint16 => GetTypeByIndex: 4;
        int16  => sint16;

        uint32 => GetTypeByIndex: 5;
        sint32 => GetTypeByIndex: 6;
        int32  => sint32;

        uint64 => GetTypeByIndex: 7;
        sint64 => GetTypeByIndex: 8;
        int64  => sint64;

        float => GetTypeByIndex: 9;
        double => GetTypeByIndex: 10;

        uchar => GetTypeByIndex: 11;
        schar => GetTypeByIndex: 12;
        char  => schar;

        ushort => GetTypeByIndex: 13;
        sshort => GetTypeByIndex: 14;
        short  => sshort;

        uint => GetTypeByIndex: 15;
        sint => GetTypeByIndex: 16;
        int  => sint;

        ulong => GetTypeByIndex: 17;
        slong => GetTypeByIndex: 18;
        long  => slong;

        longdouble => GetTypeByIndex: 19;
        
        pointer => GetTypeByIndex: 20;
    };

    null => (
        | b <- allocType: (types pointer) |
        0 to: (b size) do: [ :i | b at: i put: 0 ].
      ^ b
    );

    allocBytes: bytes => std util newBlob: bytes;
    allocType: type => allocBytes: (type sizeof);
    address: object => ( | b <- allocType (types pointer) | b at: 0 PutPtr: object. b );
    dereference: object type: type => object ptrAt: 0 Size: (type sizeof);

    ForeignFunction = {
        private name,
        private ptr,
        type;

        with inherited trait = {
            initWithName: _name Ptr: _ptr Type: _type => (
                name <- _name.
                ptr  <- _ptr.
                type <- _type.
              ^ self
            );

            value(...) => type invoke(ptr, ...);

            writeOn: w => w << 'the foreign function ' << name;
        };

        with inherited parent = #<:std/Clonable>;
    };

    SharedLibrary = {
        private name,
        private library;

        with inherited trait = {
            initWithName: _name Library: _library => (
                name    <- _name.
                library <- _library.
              ^ self
            );

            getSymbol: name => (
                #'ecosphere.ecore.object.blob.dlsym'(library, name) when: [ :sym |
                  ^ Yes: sym
                ].
              ^ No
            );

            getFunction: name Type: t => (
                (getSymbol: name)
                    yes: [ :sym | Yes: (((std ffi ForeignFunction) clone) initWithName: name Ptr: sym Type: t) ]
                     no: [ No ]
            );

            writeOn: w => w << 'the shared library ' << name;
        };

        with inherited parent = #<:std/Clonable>;
    };

    DLOpen: path => (
        #'ecosphere.ecore.object.blob.dlopen'(path) when: [ :lib |
          ^ Yes: ((SharedLibrary clone) initWithName: path Library: lib)
        ].
      ^ No
    );

    DLSymbol: name => (
        #'ecosphere.ecore.object.blob.dlsym'(name) when: [ :sym |
          ^ Yes: sym
        ].
      ^ No
    );

    DLFunction: name Type: t => (
        (DLSymbol: name)
            yes: [ :sym | Yes: (((std ffi ForeignFunction) clone) initWithName: name Ptr: sym Type: t) ]
             no: [ No ]
    );
}
