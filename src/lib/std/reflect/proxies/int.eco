
#=std/reflect/proxies/Int: {

    with inherited basic_math = {
        +    other => #'ecosphere.ecore.math.add'(self itself, other itself);
        -    other => #'ecosphere.ecore.math.sub'(self itself, other itself);
        *    other => #'ecosphere.ecore.math.mul'(self itself, other itself);
        /    other => #'ecosphere.ecore.math.div'(self itself, other itself);
        mod: other => #'ecosphere.ecore.math.mod'(self itself, other itself);
    };

    with inherited bit_ops = {
        bitOr:  other => #'ecosphere.ecore.math.bit_or'(self itself, other itself);
        bitAnd: other => #'ecosphere.ecore.math.bit_and'(self itself, other itself);
        bitXOR: other => #'ecosphere.ecore.math.bit_xor'(self itself, other itself);
        lshift: other => #'ecosphere.ecore.math.bitshift_left'(self itself, other itself);
        rshift: other => #'ecosphere.ecore.math.bitshift_right'(self itself, other itself);
        shift:  other => (other isNegative) if: [ ^ self rshift: (other negate) ] else: [ ^ self lshift: other ];
    };

    with inherited comparisons = {
        < other    => #'ecosphere.ecore.math.less'(self itself, other itself);
        == other   => #'ecosphere.ecore.is'(self itself, other itself);
        != other   => (self == other) not;
        <= other   => [ self < other ] or: [ self == other ];
        > other    => (self <= other) not;
        >= other   => (self < other) not;
    };

    with inherited min_max = {
        min: other => (self < other) if: [ self  ] else: [ other ];
        max: other => (self < other) if: [ other ] else: [ self  ];
    };

    with inherited checks = {
        isZero        => (self == 0);
        isNotZero     => isZero not;
        isNegative    => self < 0;
        isNotNegative => isNegative not;
        isPositive    => self > 0;
    };

    with inherited misc = {
        negate => (0 - self);
    };

    with inherited conversions = {
        isInt  => true;
        asChar => #'ecosphere.ecore.int.as_char'(self itself);
    };

    with inherited ranged_loops = {
        for: upper do: body => (
            | i <- self |
            [ i < upper ] while: [
                body value(i).
                i <- i + 1.
            ]
        );
        to: upper do: body => for: (upper + 1) do: body;
    };

    with inherited counting_loops = {
        do: block => 0 for: self do: block;
        times: block => do: [ :i | block value ];
        countUp: block => (
            | i <- self |
            [ block value(i). i <- i + 1 ] repeat
        );
        countDown: block => (
            | i <- self |
            [ i isPositive ] while: [
                block value(i).
                i <- i - 1
            ]
        );
    };

    writeOn: writer => (
        |
            lib <- {
                Digit(n) => ((#\0 asInt) + n) asChar;
                WriteNumLoop(writer, num, base, digit_func) => (
                    (num isZero) unless: [
                        WriteNumLoop(writer, num / base, base, digit_func).
                        writer << digit_func(num mod: base).
                    ].
                );
                WriteNum(writer, num) => (
                    (num isNegative) if:   [ writer << #\-. num <- num negate ].
                    (num isZero)     if:   [ writer << #\0 ]
                                     else: [ WriteNumLoop(writer, num, 10, [ :i, Digit(i) ]) ]
                );
            }
        |
        lib WriteNum(writer, self);
    );
    
    with inherited parent = #<:std/Clonable>;
}
