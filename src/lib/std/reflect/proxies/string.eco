
#=std/reflect/proxies/String/Iterator: {
    private string,
    private index;

    with inherited trait = {
        init: _string => (
            string <- _string.
            index  <- 0.
          ^ self
        );

        forward => ( index <- index + 1. self );
        backward => ( index <- index - 1. self );

        has => index < string byteSize;
        hasPrevious => index > 0;

        current => string byteAt: index;

        withReset: block => (
            | resetIndex <- index |
          ^ block value([ index <- resetIndex ])
        );

        with inherited iteratorTrait = #<:std/util/iterators/BiIteratorTrait>;
    };
    static with inherited parent = #<:std/Clonable>;
},

#=std/reflect/proxies/String: {
    size => #'ecosphere.ecore.object.string.char_length'(self);
    byteSize => #'ecosphere.ecore.object.string.byte_length'(self);
    byteAt: index => #'ecosphere.ecore.object.string.byte_at'(self, index);
    at: index => #'ecosphere.ecore.object.string.at_byte'(self, index);
    do: body => (
        | i <- 0. s <- byteSize. |
        [ i < s ] while: [
            body value(#'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    forEach: body => (
        | i <- 0. s <- byteSize. |
        [ i < s ] while: [
            body value(i, #'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    equals: other => (
        (other isString)       unless: [ ^ false ].
        (size == (other size)) unless: [ ^ false ].
        forEach: [ :index, :value |
            (value == (other at: index)) unless: [ ^ false ]
        ].
      ^ true
    );
    contains: character => (
        do: [ :c | (c == character) if: [ ^ true ] ].
      ^ false
    );
    + other => (
        | vec <- asVector |
        other do: [ :c | vec append: c ].
      ^ vec asString
    );
    splitOnChar: char => (
        "TODO: Generate an iterator"
        |
            tokens <- std util newVector,
            token  <- std util newVector
        |
        do: [ :c |
            (c == char) if: [ (token isEmpty) unless: [ tokens append: (token asString). token clear ] ]
                      else: [ token append: c ]
        ].
        (token isEmpty) unless: [ tokens append: (token asString). token clear ].
      ^ tokens asArray
    );
    * count => (
        | vec <- std util newVector |
        count times: [
            do: [ :c | vec append: c ]
        ].
      ^ vec asString
    );
    isString => true;
    asBlob => (
        | blob <- std util newBlob: byteSize |
        0 for: byteSize do: [ :i | blob at: i put: (byteAt: i) ].
      ^ blob
    );
    asVector => (
        | v <- std util newVector |
        do: [ :c | v append: c ].
      ^ v
    );
    asArray => asVector asArray;
    asList => asVector asList;
    asKey => #'ecosphere.ecore.object.string.as_key'(self);
    parseInt => (
        | v <- 0, sign <- 1 |
        (size isZero) if: [ ^ No ].
        forEach: [ :i, :c |
            (c == #\-) if: [ ( [ i isZero ] and: [ size > 1 ] ) if: [ sign <- -1 ] else: [ ^ No ] ]
                     else: [
                ([ (c asInt) >= (#\0 asInt) ] and: [ (c asInt) <= (#\9 asInt) ]) unless: [ ^ No ].
                v <- (v * 10) + ((c asInt) - (#\0 asInt))
            ]
        ].
        Yes: (v * sign)
    );
    parse => (
        |
            reader <- ((lang eco tokenizer StringReader) clone) init: self,
            tok    <- ((lang eco tokenizer Tokenizer) clone) init: reader,
            parser <- ((lang eco parser Parser) clone) init: tok
        |
      ^ parser parseExpression
    );
    iterator => ((std text utf8 UTF8Iterator) clone) init: ((#<:std/reflect/proxies/String/Iterator> clone) init: self);
    writeOn: writer => do: [ :c | writer << c ];
    static with inherited parent = #<:std/Clonable>;
}
