
#=std/reflect/proxies/String/Iterator: {
    private string,
    private index;

    with inherited trait = {
        init: _string => (
            string <- _string.
            index  <- 0.
          ^ self
        );

        forward => ( index <- index + 1. self );
        backward => ( index <- index - 1. self );

        has => index < string byteSize;
        hasPrevious => index > 0;

        current => string byteAt: index;

        withReset: block => (
            | resetIndex <- index |
          ^ block value([ index <- resetIndex ])
        );

        with inherited iteratorTrait = #<:std/util/iterators/BiIteratorTrait>;
    };
    static with inherited parent = #<:std/Clonable>;
},

#=std/reflect/proxies/String: {
    size => #'ecosphere.ecore.object.string.char_length'(self);
    byteSize => #'ecosphere.ecore.object.string.byte_length'(self);
    byteAt: index => #'ecosphere.ecore.object.string.byte_at'(self, index);
    at: index => #'ecosphere.ecore.object.string.at_byte'(self, index);
    do: body => (
        | i <- 0. s <- byteSize. |
        [ i < s ] while: [
            body value(#'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    forEach: body => (
        | i <- 0. s <- byteSize. |
        [ i < s ] while: [
            body value(i, #'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    equals: other => (
        (other isString)       unless: [ ^ false ].
        (size == (other size)) unless: [ ^ false ].
        forEach: [ :index, :value |
            (value == (other at: index)) unless: [ ^ false ]
        ].
      ^ true
    );
    contains: character => (
        do: [ :c | (c == character) if: [ ^ true ] ].
      ^ false
    );
    + other => (
        | vec <- asVector |
        other do: [ :c | vec append: c ].
      ^ vec asString
    );
    splitOnChar: char => (
        "TODO: Generate an iterator"
        |
            tokens <- std util newVector,
            token  <- std util newVector
        |
        do: [ :c |
            (c == char) if: [ (token isEmpty) unless: [ tokens append: (token asString). token clear ] ]
                      else: [ token append: c ]
        ].
        (token isEmpty) unless: [ tokens append: (token asString). token clear ].
      ^ tokens asArray
    );
    * count => (
        | vec <- std util newVector |
        count times: [
            do: [ :c | vec append: c ]
        ].
      ^ vec asString
    );
    isString => true;
    asBlob => (
        | blob <- std util newBlob: byteSize |
        0 for: byteSize do: [ :i | blob at: i put: (byteAt: i) ].
      ^ blob
    );
    asKey => #'ecosphere.ecore.object.string.as_key'(self);
    parse => (
        |
            tok    <- ((lang eco tokenizer Tokenizer) clone) init: iterator,
            parser <- ((lang eco parser Parser) clone) init: tok
        |
      ^ parser parseExpression
    );
    iterator => ((std text utf8 UTF8Iterator) clone) init: ((#<:std/reflect/proxies/String/Iterator> clone) init: self);
    writeOn: writer => do: [ :c | writer << c ];
    with inherited standard_list_conversions = #<:std/util/StandardListConversions>;
    static with inherited parent = #<:std/Clonable>;
}
