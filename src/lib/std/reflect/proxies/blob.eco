
#=std/reflect/proxies/Blob/ByteIterator: {
    private blob,
    private index;

    with inherited trait = {
        init: _blob => (
            blob  <- _blob.
            index <- 0.
          ^ self
        );

        forward => ( index <- index + 1. self );
        backward => ( index <- index - 1. self );

        has => index < blob size;
        hasNext => index < (blob size - 1);
        hasPrevious => index > 0;

        current => blob at: index;
        next => [ forward ] returns: current;
        previous => ( backward. current );

        writeOn: w => w << 'a byte iterator';
    };

    with inherited parent = #<:std/Clonable>;
},

#=std/reflect/proxies/Blob: {
    size => #'ecosphere.ecore.object.blob.size'(self);
    isEmpty => size isZero;
    at: index => int8at: index;
    int8at: index => #'ecosphere.ecore.object.blob.at_int8'(self, index);
    int16at: index => #'ecosphere.ecore.object.blob.at_int16'(self, index);
    int32at: index => #'ecosphere.ecore.object.blob.at_int32'(self, index);
    ptrAt: index Offset: offset Size: size => #'ecosphere.ecore.object.blob.at_ptr'(self, index, offset, size);
    ptrAt: index Size: size => ptrAt: index Offset: 0 Size: size;
    anyAt: index => #'ecosphere.ecore.object.blob.at_any'(self, index);
    at: index put: value => at: index PutInt8: value;
    at: index PutInt8: value => #'ecosphere.ecore.object.blob.at_put_int8'(self, index, value);
    at: index PutInt16: value => #'ecosphere.ecore.object.blob.at_put_int16'(self, index, value);
    at: index PutInt32: value => #'ecosphere.ecore.object.blob.at_put_int32'(self, index, value);
    at: index PutPtr: value Offset: offset => #'ecosphere.ecore.object.blob.at_put_ptr'(self, index, value, offset);
    at: index PutPtr: value => at: index PutPtr: value Offset: 0;
    at: index PutAny: value => #'ecosphere.ecore.object.blob.at_put_any'(self, index, value);

    from: collection => ( collection forEach: [ :i, :v | at: i put: v ]. ^ self );

    with inherited iterations = #<:std/util/StandardListIterations>;
    with inherited conversions = #<:std/util/StandardListConversions>;
    with inherited access = #<:std/util/StandardListAccess>;
    with inherited search = #<:std/util/StandardListSearch>;

    iterator => (#<:std/reflect/proxies/Blob/ByteIterator> clone) init: self;

    writeOn: writer => (
        (size < 128) if: [
            writer << '#['.
            forEach: [ :i, :e | (i > 0) if: [ writer << ', ' ]. writer << e ].
            writer << ']'.
        ] else: [
            writer << '<blob: ' << size << '>'
        ]
    );

    with inherited parent = #<:std/Clonable>;
}
