
#=std/reflect/ffi: {
    with std = #<:std>;
    
    types = {
        private GetTypeByIndex: index => #'ecosphere.ecore.ffi.type.by_index'(index);

        void => GetTypeByIndex: 0;

        uint8 => GetTypeByIndex: 1;
        sint8 => GetTypeByIndex: 2;
        int8  => sint8;

        uint16 => GetTypeByIndex: 3;
        sint16 => GetTypeByIndex: 4;
        int16  => sint16;

        uint32 => GetTypeByIndex: 5;
        sint32 => GetTypeByIndex: 6;
        int32  => sint32;

        uint64 => GetTypeByIndex: 7;
        sint64 => GetTypeByIndex: 8;
        int64  => sint64;

        float => GetTypeByIndex: 9;
        double => GetTypeByIndex: 10;

        uchar => GetTypeByIndex: 11;
        schar => GetTypeByIndex: 12;
        char  => schar;

        ushort => GetTypeByIndex: 13;
        sshort => GetTypeByIndex: 14;
        short  => sshort;

        uint => GetTypeByIndex: 15;
        sint => GetTypeByIndex: 16;
        int  => sint;

        ulong => GetTypeByIndex: 17;
        slong => GetTypeByIndex: 18;
        long  => slong;

        longdouble => GetTypeByIndex: 19;
        
        pointer => GetTypeByIndex: 20;
    };

    MakeFunctionWithReturnType: type Args: args => #'ecosphere.ecore.ffi.function.new'(type, args);

    SharedLibrary = {
        private library;

        with inherited trait = {
            init: lib => (
                library <- lib.
              ^ self
            );

            getSymbol: name => (
                #'ecosphere.ecore.object.blob.dlsym'(library, name) when: [ :sym |
                  ^ Yes: sym
                ].
              ^ No
            );

            writeOn: w => w << 'a shared library';
        };

        with inherited parent = #<:std/Clonable>;
    };

    DLOpen: path => (
        #'ecosphere.ecore.object.blob.dlopen'(path) when: [ :lib |
          ^ Yes: ((SharedLibrary clone) init: lib)
        ].
      ^ No
    );
}
