"
    util.eco - The `std util` package of the Ecosphere
"

#=std/util/StandardListIterations: {
    do: body => (
        0 for: size do: [ :i | body value(at: i) ].
      ^ self
    );

    forEach: body => (
        0 for: size do: [ :i | body value(i, at: i) ].
      ^ self
    );
},

#=std/util/StandardListConversions: {
    asArray => (
        | v <- std util newArray: size |
        forEach: [ :index, :value | v at: index put: value ].
      ^ v
    );

    asVector => (
        | v <- std util newVector |
        do: [ :value | v append: value ].
      ^ v
    );

    asList => (
        | v <- std util newList |
        do: [ :value | v append: value ].
      ^ v
    );

    asBlob => (
        | b <- std util newBlob: size |
        forEach: [ :i, :v | b at: i put: v ].
      ^ b
    );
},

#=std/util/StandardListAccess: {
    first => at: 0;
    second => at: 1;
    third => at: 2;
    fourth => at: 3;
    fifth => at: 4;
    sixth => at: 5;
    seventh => at: 7;
    eighth => at: 8;
    ninth => at: 9;
    tenth => at: 10;
    last => at: (size - 1);
},

#=std/util/StandardStackImpl: {
    push: e => append: e;
    peek    => last;
    pop     => removeLast;
};

#=std/util/StandardQueueImpl: {
    enqueue: e => append: e;
    front      => first;
    dequeue    => removeFirst;
};

#=std/util/StandardSetImpl: {
    contains: value => (find: value) yes: [ :i | ^ true ] no: [ ^ false ];
    addElement: e => (contains: e) unless: [ append: e ];
    removeElement: e => (find: e) yes: [ :i | remove: i ];
    take => (
        isEmpty if: [ invalidIndexError ].
        | v <- first |
        removeElement: v.
      ^ v
    );
};

#=std/util: {
    Array(size) => #'ecosphere.ecore.object.array.new'(size);

    newArray: size => #'ecosphere.ecore.object.array.new'(size);
    newBlob:  size => #'ecosphere.ecore.object.blob.new'(size);
    newVector      => (#<:std/util> Vector) new;
    newStack       => (#<:std/util> Stack) new;
    newQueue       => (#<:std/util> Queue) new;
    newSet         => (#<:std/util> Set) new;
    newList        => (#<:std/util> List) new;
    newMap         => (#<:std/util> Map) new;
    newStringBuilder => (#:<std/util> StringBuilder) new;

    WriteIterable: it On: writer => (
        writer << '#('.
        it forEach: [ :i, :e | (i > 0) if: [ writer << ', ' ]. writer << e ].
        writer << ')'
    );

    Stack = {
      new => std util newVector;
      with inherited parent = #<:std/Clonable>;
    };

    Queue = {
      new => std util newVector;
      with inherited parent = #<:std/Clonable>;
    };

    Set = {
      new => std util newVector;
      with inherited parent = #<:std/Clonable>;
    };

    Vector = {
        size = 0,
        own elements = #();

        with inherited trait = {
            capacity => elements size;
            isEmpty => size isZero;

            at: index => elements at: index;
            at: index put: value => elements at: index put: value;  "TODO: Index >= capacity"

            with inherited iterations = #<:std/util/StandardListIterations>;
            with inherited conversions = #<:std/util/StandardListConversions>;
            with inherited access = #<:std/util/StandardListAccess>;
            with inherited stack = #<:std/util/StandardStackImpl>;
            with inherited queue = #<:std/util/StandardQueueImpl>;
            with inherited set = #<:std/util/StandardSetImpl>;

            asString => asArray asString;

            resize: cap => (
                | new_elements = std util newArray: cap |
                (cap < capacity) if: [
                    0 for: cap do: [ :i | new_elements at: i put: (at: i) ]
                ] else: [
                    forEach: [ :index, :value | new_elements at: index put: value ]
                ].
                elements <- new_elements.
              ^ self
            );

            resizeToAtLeast: cap => (
                (cap > capacity) if: [ resize: cap ].
              ^ self
            );

            append: element => (
                resizeToAtLeast: (size + 1).
                elements at: size put: element.
                size <- size + 1.
              ^ self
            );

            remove: index => (
                | elem <- at: index |
                index to: (size - 2) do: [ :i | at: i put: (at: i + 1) ].
                size <- size - 1.
              ^ elem
            );

            find: element => (
                forEach: [ :i, :v | (v is: element) if: [ ^ Yes: i ] ].
              ^ No
            );

            writeOn: writer => (std util) WriteIterable: self On: writer;

            removeFirst => remove: 0;
            removeLast  => remove: (size - 1);
        };

        with inherited parent = #<:std/Clonable>;
    },

    Link = {
        own next,
        own prev,
        value;

        with inherited trait = {
            init => (next: self prev: self) value: self;
            next: value => ( next <- value. ^ self );
            prev: value => ( prev <- value. ^ self );
            next: nv prev: pv => (next: nv) prev: pv;
            value: nv => ( value <- nv. ^ self );
        };

        with inherited parent = #<:std/Clonable>;
    },

    List = {
        own elements;

        with inherited trait = {
            init => ( elements <- (std util Link) clone init. ^ self );
            size => (
                | s <- 0, p <- elements next |
                [ p != elements ] while: [ s <- s inc. p <- p next. ].
              ^ s
            );
            isEmpty => size isZero;
            do: block => (
                | p <- elements next |
                [ p != elements ] while: [ block value(p value). p <- p next. ].
              ^ self
            );
            at: i => (
                do: [ :e | (i isZero) if: [ ^ e ]. i <- i - 1 ].
                invalidIndexError
            );
            append: value => (
                | link <- (std util Link) clone init |
                link value: value.
                link next: elements prev: elements prev.
                (elements prev) next: link.
                elements prev: link.
              ^ self
            );

            with inherited conversions = #<:std/util/StandardListConversions>;
            with inherited access = #<:std/util/StandardListAccess>;
        };

        with inherited parent = #<:std/Clonable>;
    },

    Collector = {
        prev,
        index = 0,
        value;

        with inherited trait = {
            init: v => (
                prev <- self.
                index <- 0.
                value <- v.
              ^ self
            );
            & v => (
                | next <- (std util Collector) clone init: v |
                next prev: self.
                next index: index inc.
              ^ next
            );
            prev:  p => ( prev  <- p. ^ self );
            index: i => ( index <- i. ^ self );
            value: v => ( value <- v. ^ self );
            size => index + 1;
            do: block => (
                (prev == self) unless: [ prev do: block ].
                block value(value).
            );
            forEach: block => (
                | i <- 0 |
                do: [ :e | block value(i, e). i <- i + 1. ]
            );
            at: index => (
                forEach: [ :i, :v | (i == index) if: [ ^ v ] ].
                invalidIndexError
            );

            writeOn: writer => (
                (index == 0) if: [ writer << value ]
                           else: [
                    writer << prev << ' & ' << value
                ]
            );

            with inherited conversions = #<:std/util/StandardListConversions>;
            with inherited access = #<:std/util/StandardListAccess>;
        };

        with inherited parent = #<:std/Clonable>;
    },

    MutablePair = {
        first, second;

        with inherited trait = {
            initWithFirst: f Second: s => (
                first: f second: s.
              ^ self
            );

            first: f => first <- f;
            second: s => second <- s;

            first: f second: s => (
                first: f. second: s.
            );
        };

        with inherited parent = #<:std/Clonable>;
    },

    Map = {
        values;

        with inherited trait = {
            init => (
                values <- std util newVector.
              ^ self
            );

            forEach: block => values do: [ :v | block value(v first, v second) ];
            do: block => forEach: [ :k, :v | block value(k) ];

            at: index do: found else: notfound => ( forEach: [ :k, :v | (k == index) if: [ ^ found value(v) ] ]. ^ notfound value );
            at: index do: found => at: index do: found else: [];
            at: index else: notfound => at: index do: [ :v | ^ v ] else: notfound;
            at: index default: def => at: index else: [ ^ def ];
            at: index => at: index else: [ invalidIndexError ];

            at: index put: value => (
                values do: [ :p | (p first == index) if: [ p second: value. ^ self ] ].
                values append: (index cons: value).
              ^ self
            );
        };

        with inherited parent = #<:std/Clonable>;
    },

    StringBuilder = {
        chars;

        with inherited trait = {
            init => (
                chars <- std util newVector.
              ^ self
            );

            append: c => (
                chars append: c.
              ^ self
            );

            asString => chars asString;
        };

        with inherited parent = #<:std/Clonable>;
    }
}
