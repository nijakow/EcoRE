"
    util.eco - The `std util` package of the Ecosphere
"

#=std/util/StandardListIterations: {
    do: body => (
        0 for: size do: [ :i | body value(at: i) ].
      ^ self
    );

    forEach: body => (
        0 for: size do: [ :i | body value(i, at: i) ].
      ^ self
    );
},

#=std/util/StandardListConversions: {
    asArray => (
        | v <- std util Array(size) |
        forEach: [ :index, :value | v at: index put: value ].
      ^ v
    );

    asVector => (
        | v <- (std util Vector) new |
        do: [ :value | v append: value ].
      ^ v
    );

    asList => (
        | v <- (std util List) new |
        do: [ :value | v append: value ].
      ^ v
    );
},

#=std/util: {
    Array(size) => #'ecosphere.ecore.object.array.new'(size);

    Vector = {
        size = 0,
        own elements = #();

        with inherited trait = {
            capacity => elements size;
            isEmpty => size isZero;

            at: index => elements at: index;
            at: index put: value => elements at: index put: value;

            with inherited iterations = #<:std/util/StandardListIterations>;
            with inherited conversions = #<:std/util/StandardListConversions>;

            asString => asArray asString;

            resize: cap => (
                | new_elements = std util Array(cap) |
                (cap < capacity) if: [
                    0 for: cap do: [ :i | new_elements at: i put: (at: i) ]
                ] else: [
                    forEach: [ :index, :value | new_elements at: index put: value ]
                ].
                elements <- new_elements.
              ^ self
            );

            resizeToAtLeast: cap => (
                (cap > capacity) if: [ resize: cap ].
              ^ self
            );

            append: element => (
                resizeToAtLeast: (size + 1).
                elements at: size put: element.
                size <- size + 1.
              ^ self
            );
        };

        with inherited parent = #<:std/Clonable>;
    },

    Link = {
        own next,
        own prev,
        value;

        with inherited trait = {
            init => (next: self prev: self) value: self;
            next: value => ( next <- value. ^ self );
            prev: value => ( prev <- value. ^ self );
            next: nv prev: pv => (next: nv) prev: pv;
            value: nv => ( value <- nv. ^ self );
        };

        with inherited parent = #<:std/Clonable>;
    },

    List = {
        own elements;

        with inherited trait = {
            init => ( elements <- (std util Link) clone init. ^ self );
            size => (
                | s <- 0, p <- elements next |
                [ p != elements ] while: [ s <- s inc. p <- p next. ].
              ^ s
            );
            isEmpty => size isZero;
            do: block => (
                | p <- elements next |
                [ p != elements ] while: [ block value(p value). p <- p next. ].
              ^ self
            );
            at: i => (
                | p <- elements next |
                [ i isZero ] until: [
                    "TODO: Error if (p == elements)"
                    p <- p next.
                    i <- i - 1.
                ].
              ^ p value
            );
            append: value => (
                | link <- (std util Link) clone init |
                link value: value.
                link next: elements prev: elements prev.
                (elements prev) next: link.
                elements prev: link.
              ^ self
            );

            with inherited conversions = #<:std/util/StandardListConversions>;
        };

        with inherited parent = #<:std/Clonable>;
    },

    Collector = {
        prev,
        index = 0,
        value;

        with inherited trait = {
            init: v => (
                prev <- self.
                index <- 0.
                value <- v.
              ^ self
            );
            & v => (
                | next <- (std util Collector) clone init: v |
                next prev: self.
                next index: index inc.
              ^ next
            );
            prev:  p => ( prev  <- p. ^ self );
            index: i => ( index <- i. ^ self );
            value: v => ( value <- v. ^ self );
            size => index + 1;
            do: block => (
                (prev == self) unless: [ prev do: block ].
                block value(value).
            );
            forEach: block => (
                | i <- 0 |
                do: [ :e | block value(i, e). i <- i + 1. ]
            );

            with inherited conversions = #<:std/util/StandardListConversions>;
        };

        with inherited parent = #<:std/Clonable>;
    },

    StringBuilder = {
        chars;

        with inherited trait = {
            init => (
                chars <- std util Vector new.
              ^ self
            );

            append: c => (
                chars append: c.
              ^ self
            );

            asString => chars asString;
        };

        with inherited parent = #<:std/Clonable>;
    }
}
