
#=init/block_proxy: {
    value(...) => #'ecosphere.ecore.flow.value'(self, ...).
    repeat     => ( self value. #'ecosphere.ecore.flow.reset'() ).
    while: b   => ( (self value) false: [ ^ #<:std/bool/false> ]. b value. #'ecosphere.ecore.flow.reset'() ).
    until: b   => ( (self value) true:  [ ^ #<:std/bool/true> ]. b value. #'ecosphere.ecore.flow.reset'() ).
    and:   b   => (
        | v <- self value |
        v if: [ ^ b value ] else: [ ^ v ]
    );
    or:    b   => (
        | v <- self value |
        v if: [ ^ v ] else: [ ^ b value ]
    );
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/integer_proxy: {
    + other    => #'ecosphere.ecore.math.add'(self, other);
    - other    => #'ecosphere.ecore.math.sub'(self, other);
    * other    => #'ecosphere.ecore.math.mul'(self, other);
    / other    => #'ecosphere.ecore.math.div'(self, other);
    mod: other => #'ecosphere.ecore.math.mod'(self, other);
    bitOr: other => #'ecosphere.ecore.math.bit_or'(self, other);
    bitAnd: other => #'ecosphere.ecore.math.bit_and'(self, other);
    bitXOR: other => #'ecosphere.ecore.math.bit_xor'(self, other);
    shift:  other => #'ecosphere.ecore.math.shift'(self, other);
    < other    => #'ecosphere.ecore.math.less'(self, other);
    == other   => #'ecosphere.ecore.is'(self, other);
    != other   => (self == other) not;
    <= other   => [ self < other ] or: [ self == other ];
    > other    => (self <= other) not;
    >= other   => (self < other) not;
    isZero     => (self == 0);
    isNotZero  => isZero not;
    isNegative => (self < 0);
    isNotNegative => isNegative not;
    negate     => (0 - self);
    asChar     => #'ecosphere.ecore.int.as_char'(self);
    for: upper do: body => (
        | i <- self |
        [ i < upper ] while: [
            body value(i).
            i <- i + 1.
        ].
    );
    to: upper do: body => for: (upper + 1) do: body;
    writeOn: writer => (
        |
            lib <- {
                Digit(n) => ((#\0 asInt) + n) asChar;
                WriteNumLoop(writer, num, base, digit_func) => (
                    (num isZero) unless: [
                        WriteNumLoop(writer, num / base, base, digit_func).
                        writer << digit_func(num mod: base).
                    ].
                );
                WriteNum(writer, num) => (
                    (num isNegative) if:   [ writer << #\-. num <- num negate ].
                    (num isZero)     if:   [ writer << #\0 ]
                                     else: [ WriteNumLoop(writer, num, 10, [ :i, Digit(i) ]) ]
                );
            }
        |
        lib WriteNum(writer, self);
    );
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/character_proxy: {
    asInt           => #'ecosphere.ecore.char.as_int'(self);
    writeOn: writer => writer char<< self;
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/key_proxy: {
    asString => #'ecosphere.ecore.object.key.as_string'(self);
    writeOn: writer => (
        writer << #\#.
        writer << #\'.
        writer << asString.
        writer << #\'.
    );
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/string_proxy: {
    size => #'ecosphere.ecore.object.string.byte_length'(self);
    at: index => #'ecosphere.ecore.object.string.at_byte'(self, index);
    do: body => (
        | i <- 0. s <- size. |
        [ i < s ] while: [
            body value(#'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    asVector => (
        | v <- #() clone |
        self do: [ :c | v append: c ].
      ^ v
    );
    writeOn: writer => do: [ :c | writer << c ];
    asKey => #'ecosphere.ecore.object.string.as_key'(self);
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/vector_proxy: {
    size => #'ecosphere.ecore.object.vector.size'(self);
    isEmpty => size isZero;
    at: index => #'ecosphere.ecore.object.vector.at'(self, _norm(index));
    at: index put: value => #'ecosphere.ecore.object.vector.at_put'(self, _norm(index), value);
    at: index insert: value => #'ecosphere.ecore.object.vector.insert'(self, _nnorm(index), value);
    append: value => at: size insert: value;
    remove: index => #'ecosphere.ecore.object.vector.remove'(self, _norm(index));
    do: body => (
        0 for: size do: [ :i => body value(at: i) ].
      ^ self
    );
    asString => #'ecosphere.ecore.object.vector.to_string'(self);
    _norm(i) => (i isNegative) if: [ size + i ] else: [ i ];
    _nnorm(i) => (i isNegative) if: [ size + i + 1 ] else: [ i ];
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/port_proxy: {
    char<< c  => (#'ecosphere.ecore.object.port.write_char'(self, c). ^ self);
    << object => ( object writeOn: self; ^ self );
    flush     => #'ecosphere.ecore.object.port.flush_output'(self);
    readByte  => (
        | b <- #'ecosphere.ecore.object.port.read_byte'(self) |
        [ b asBool ] until: [
            #'ecosphere.ecore.object.port.notify_me'(self).
            b <- #'ecosphere.ecore.object.port.read_byte'(self)
        ].
      ^ b
    );
    readChar => (
        | b <- readByte, bytes, v |
        if ((b bitAnd: 0b10000000) isZero) {
            ^ b asChar
        } else if ((b bitAnd: 0b11100000) == 0b11000000) {
            v <- b bitAnd: 0b00011111.
            bytes <- 1.
        } else if ((b bitAnd: 0b11110000) == 0b11100000) {
            v <- b bitAnd: 0b00001111.
            bytes <- 2.
        } else if ((b bitAnd: 0b11111000) == 0b11110000) {
            v <- b bitAnd: 0b00000111.
            bytes <- 3.
        } else {
            ^ 0xfffd asChar
        }.
        1 to: bytes do: [ :i |
            b <- readByte.
            ((b bitAnd: 0b11000000) != (0b10000000)) if: [ ^ 0xfffd asChar ].
            v <- ((v shift: 6) bitOr: (b bitAnd: 0b00111111)).
        ].
      ^ v asChar
    );
    with own parent = #<:std/Object@std/std.eco>;
}
