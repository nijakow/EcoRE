
#=init/block_proxy: {
    value(...) => #'ecosphere.ecore.flow.value'(self, ...).
    repeat     => ( self value. #'ecosphere.ecore.flow.reset'() ).
    while: b   => ( (self value) false: [ ^ #<:std/bool/false> ]. b value. #'ecosphere.ecore.flow.reset'() ).
    until: b   => ( (self value) true:  [ ^ #<:std/bool/true> ]. b value. #'ecosphere.ecore.flow.reset'() ).
    and:   b   => (
        | v <- self value |
        v if: [ ^ b value ] else: [ ^ v ]
    );
    or:    b   => (
        | v <- self value |
        v if: [ ^ v ] else: [ ^ b value ]
    );
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/integer_proxy: {
    + other    => #'ecosphere.ecore.math.add'(self, other);
    - other    => #'ecosphere.ecore.math.sub'(self, other);
    * other    => #'ecosphere.ecore.math.mul'(self, other);
    / other    => #'ecosphere.ecore.math.div'(self, other);
    mod: other => #'ecosphere.ecore.math.mod'(self, other);
    < other    => #'ecosphere.ecore.math.less'(self, other);
    == other   => #'ecosphere.ecore.is'(self, other);
    <= other   => [ self < other ] or: [ self == other ];
    > other    => (self <= other) not;
    >= other   => (self < other) not;
    isZero     => (self == 0);
    isNegative => (self < 0);
    negate     => (0 - self);
    asChar     => #'ecosphere.ecore.int.as_char'(self);
    for: upper do: body => (
        | i <- self |
        [ i < upper ] while: [
            body value(i).
            i <- i + 1.
        ].
    );
    to: upper do: body => for: (upper + 1) do: body;
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/character_proxy: {
    asInt => #'ecosphere.ecore.char.as_int'(self);
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/string_proxy: {
    size => #'ecosphere.ecore.object.string.byte_length'(self);
    at: index => #'ecosphere.ecore.object.string.at_byte'(self, index);
    do: body => (
        | i <- 0. s <- size. |
        [ i < s ] while: [
            body value(#'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    asVector => (
        | v <- #() clone |
        self do: [ :c | v append: c ].
      ^ v
    );
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/vector_proxy: {
    size => #'ecosphere.ecore.object.vector.size'(self);
    isEmpty => size isZero;
    at: index => #'ecosphere.ecore.object.vector.at'(self, _norm(index));
    at: index put: value => #'ecosphere.ecore.object.vector.at_put'(self, _norm(index), value);
    at: index insert: value => #'ecosphere.ecore.object.vector.insert'(self, _nnorm(index), value);
    append: value => at: size insert: value;
    remove: index => #'ecosphere.ecore.object.vector.remove'(self, _norm(index));
    do: body => (
        0 for: size do: [ :i => body value(at: i) ].
      ^ self
    );
    asString => #'ecosphere.ecore.object.vector.to_string'(self);
    _norm(i) => (i isNegative) if: [ size + i ] else: [ i ];
    _nnorm(i) => (i isNegative) if: [ size + i + 1 ] else: [ i ];
    with own parent = #<:std/Object@std/std.eco>;
},

#=init/port_proxy: {
    char<< c => #'ecosphere.ecore.object.port.write_char'(self, c);
    with own parent = #<:std/Object@std/std.eco>;
}
