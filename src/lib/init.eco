
#=init/block_proxy: {
    value(...) => #'ecosphere.ecore.flow.value'(self, ...).
    repeat     => ( self value. #'ecosphere.ecore.flow.reset'() ).
    while: b   => ( (self value) false: [ ^ #<:std/bool/false> ]. b value. #'ecosphere.ecore.flow.reset'() ).
    until: b   => ( (self value) true:  [ ^ #<:std/bool/true> ]. b value. #'ecosphere.ecore.flow.reset'() ).
    and:   b   => (
        | v <- self value |
        v if: [ ^ b value ] else: [ ^ v ]
    );
    or:    b   => (
        | v <- self value |
        v if: [ ^ v ] else: [ ^ b value ]
    );
    with inherited parent = #<:std/Clonable>;
},

#=init/integer_proxy: {
    + other    => #'ecosphere.ecore.math.add'(self, other);
    - other    => #'ecosphere.ecore.math.sub'(self, other);
    * other    => #'ecosphere.ecore.math.mul'(self, other);
    / other    => #'ecosphere.ecore.math.div'(self, other);
    mod: other => #'ecosphere.ecore.math.mod'(self, other);
    bitOr: other => #'ecosphere.ecore.math.bit_or'(self, other);
    bitAnd: other => #'ecosphere.ecore.math.bit_and'(self, other);
    bitXOR: other => #'ecosphere.ecore.math.bit_xor'(self, other);
    lshift: other => #'ecosphere.ecore.math.bitshift_left'(self, other);
    rshift: other => #'ecosphere.ecore.math.bitshift_right'(self, other);
    shift:  other => (other isNegative) if: [ ^ self rshift: (other negate) ] else: [ ^ self lshift: other ];
    < other    => #'ecosphere.ecore.math.less'(self, other);
    == other   => #'ecosphere.ecore.is'(self, other);
    != other   => (self == other) not;
    <= other   => [ self < other ] or: [ self == other ];
    > other    => (self <= other) not;
    >= other   => (self < other) not;
    isZero     => (self == 0);
    isNotZero  => isZero not;
    isNegative => (self < 0);
    isNotNegative => isNegative not;
    inc        => self + 1;
    dec        => self - 1;
    negate     => (0 - self);
    asChar     => #'ecosphere.ecore.int.as_char'(self);
    for: upper do: body => (
        | i <- self |
        [ i < upper ] while: [
            body value(i).
            i <- i + 1.
        ].
    );
    to: upper do: body => for: (upper + 1) do: body;
    do: block => 0 for: self do: block;
    times: block => do: [ :i | block value ];
    writeOn: writer => (
        |
            lib <- {
                Digit(n) => ((#\0 asInt) + n) asChar;
                WriteNumLoop(writer, num, base, digit_func) => (
                    (num isZero) unless: [
                        WriteNumLoop(writer, num / base, base, digit_func).
                        writer << digit_func(num mod: base).
                    ].
                );
                WriteNum(writer, num) => (
                    (num isNegative) if:   [ writer << #\-. num <- num negate ].
                    (num isZero)     if:   [ writer << #\0 ]
                                     else: [ WriteNumLoop(writer, num, 10, [ :i, Digit(i) ]) ]
                );
            }
        |
        lib WriteNum(writer, self);
    );
    with inherited parent = #<:std/Clonable>;
},

#=init/character_proxy: {
    asInt           => #'ecosphere.ecore.char.as_int'(self);
    == other        => #'ecosphere.ecore.is'(self, other);
    != other        => (self == other) not;
    writeOn: writer => (
        | v <- asInt |
        begin
            if: [ v <= 0        ] then: [ writer byte<< 0xef. writer byte<< 0xbf. writer byte<< 0xbd. ] ~
            if: [ v <= 0x7f     ] then: [ writer byte<< v ] ~
            if: [ v <= 0x7ff    ] then: [ writer byte<< (((v rshift: 6) bitAnd: 0x1f) bitOr: 0xc0).
                                          writer byte<< (((v)           bitAnd: 0x3f) bitOr: 0x80). ] ~
            if: [ v <= 0xffff   ] then: [ writer byte<< (((v rshift: 12) bitAnd: 0x0f) bitOr: 0xe0).
                                          writer byte<< (((v rshift:  6) bitAnd: 0x3f) bitOr: 0x80).
                                          writer byte<< (((v)            bitAnd: 0x3f) bitOr: 0x80). ] ~
            if: [ v <= 0x10ffff ] then: [ writer byte<< (((v rshift: 18) bitAnd: 0x07) bitOr: 0xf0).
                                          writer byte<< (((v rshift: 12) bitAnd: 0x3f) bitOr: 0x80).
                                          writer byte<< (((v rshift:  6) bitAnd: 0x3f) bitOr: 0x80).
                                          writer byte<< (((v rshift:  0) bitAnd: 0x3f) bitOr: 0x80). ] ~
            default: [ writer byte<< 0xef. writer byte<< 0xbf. writer byte<< 0xbd. ].
      ^ self
    );
    with inherited parent = #<:std/Clonable>;
},

#=init/key_proxy: {
    asString => #'ecosphere.ecore.object.key.as_string'(self);
    writeOn: writer => (
        writer << #\#.
        writer << #\'.
        writer << asString.
        writer << #\'.
    );
    with inherited parent = #<:std/Clonable>;
},

#=init/string_proxy: {
    size => #'ecosphere.ecore.object.string.byte_length'(self);
    at: index => #'ecosphere.ecore.object.string.at_byte'(self, index);
    do: body => (
        | i <- 0. s <- size. |
        [ i < s ] while: [
            body value(#'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    asVector => (
        | v <- (std util Vector) clone |
        self do: [ :c | v append: c ].
      ^ v
    );
    writeOn: writer => do: [ :c | writer << c ];
    asKey => #'ecosphere.ecore.object.string.as_key'(self);
    + other => (
        | vec <- asVector |
        other do: [ :c | vec append: c ].
      ^ vec asString
    );
    * count => (
        | vec <- (std util Vector) new |
        count times: [
            do: [ :c | vec append: c ]
        ].
      ^ vec asString
    );
    with inherited parent = #<:std/Clonable>;
},

#=init/array_proxy: {
    size => #'ecosphere.ecore.object.array.size'(self);
    isEmpty => size isZero;
    at: index => #'ecosphere.ecore.object.array.at'(self, _norm(index));
    at: index put: value => #'ecosphere.ecore.object.array.at_put'(self, _norm(index), value);
    asString => #'ecosphere.ecore.object.array.to_string'(self);
    _norm(i) => (i isNegative) if: [ size + i ] else: [ i ];
    _nnorm(i) => (i isNegative) if: [ size + i + 1 ] else: [ i ];

    with inherited iterations = #<:std/util/StandardListIterations>;
    with inherited conversions = #<:std/util/StandardListConversions>;
    
    with inherited parent = #<:std/Clonable>;
},

#=init/port_proxy: {
    readByte => (
        | b <- #'ecosphere.ecore.object.port.read_byte'(self) |
        [ b asBool ] until: [
            #'ecosphere.ecore.object.port.notify_me'(self).
            b <- #'ecosphere.ecore.object.port.read_byte'(self)
        ].
      ^ b
    );

    writeByte: b => (#'ecosphere.ecore.object.port.write_byte'(self, b). ^ self);
    byte<< b     => writeByte: b;

    commit => #'ecosphere.ecore.object.port.flush_output'(self);

    with inherited parent = #<:std/Clonable>;
}
