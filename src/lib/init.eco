
#=init/block_proxy: {
    value(...) => #'ecosphere.ecore.flow.value'(self, ...).
    repeat     => ( self value. #'ecosphere.ecore.flow.reset'() ).
    while: b   => ( (self value) false: [ ^ #<:std/bool/false> ]. b value. #'ecosphere.ecore.flow.reset'() ).
    until: b   => ( (self value) true:  [ ^ #<:std/bool/true> ]. b value. #'ecosphere.ecore.flow.reset'() ).
    and:   b   => (
        | v <- self value |
        v if: [ ^ b value ] else: [ ^ v ]
    );
    or:    b   => (
        | v <- self value |
        v if: [ ^ v ] else: [ ^ b value ]
    );
    with inherited own parent = #<:std/Object@std/std.eco>;
},

#=init/integer_proxy: {
    + other    => #'ecosphere.ecore.math.add'(self, other);
    - other    => #'ecosphere.ecore.math.sub'(self, other);
    * other    => #'ecosphere.ecore.math.mul'(self, other);
    / other    => #'ecosphere.ecore.math.div'(self, other);
    mod: other => #'ecosphere.ecore.math.mod'(self, other);
    bitOr: other => #'ecosphere.ecore.math.bit_or'(self, other);
    bitAnd: other => #'ecosphere.ecore.math.bit_and'(self, other);
    bitXOR: other => #'ecosphere.ecore.math.bit_xor'(self, other);
    lshift: other => #'ecosphere.ecore.math.bitshift_left'(self, other);
    rshift: other => #'ecosphere.ecore.math.bitshift_right'(self, other);
    shift:  other => (other isNegative) if: [ ^ self rshift: (other negate) ] else: [ ^ self lshift: other ];
    < other    => #'ecosphere.ecore.math.less'(self, other);
    == other   => #'ecosphere.ecore.is'(self, other);
    != other   => (self == other) not;
    <= other   => [ self < other ] or: [ self == other ];
    > other    => (self <= other) not;
    >= other   => (self < other) not;
    isZero     => (self == 0);
    isNotZero  => isZero not;
    isNegative => (self < 0);
    isNotNegative => isNegative not;
    negate     => (0 - self);
    asChar     => #'ecosphere.ecore.int.as_char'(self);
    for: upper do: body => (
        | i <- self |
        [ i < upper ] while: [
            body value(i).
            i <- i + 1.
        ].
    );
    to: upper do: body => for: (upper + 1) do: body;
    writeOn: writer => (
        |
            lib <- {
                Digit(n) => ((#\0 asInt) + n) asChar;
                WriteNumLoop(writer, num, base, digit_func) => (
                    (num isZero) unless: [
                        WriteNumLoop(writer, num / base, base, digit_func).
                        writer << digit_func(num mod: base).
                    ].
                );
                WriteNum(writer, num) => (
                    (num isNegative) if:   [ writer << #\-. num <- num negate ].
                    (num isZero)     if:   [ writer << #\0 ]
                                     else: [ WriteNumLoop(writer, num, 10, [ :i, Digit(i) ]) ]
                );
            }
        |
        lib WriteNum(writer, self);
    );
    with inherited own parent = #<:std/Object@std/std.eco>;
},

#=init/character_proxy: {
    asInt           => #'ecosphere.ecore.char.as_int'(self);
    writeOn: writer => writer char<< self;
    == other        => #'ecosphere.ecore.is'(self, other);
    != other        => (self == other) not;
    with inherited own parent = #<:std/Object@std/std.eco>;
},

#=init/key_proxy: {
    asString => #'ecosphere.ecore.object.key.as_string'(self);
    writeOn: writer => (
        writer << #\#.
        writer << #\'.
        writer << asString.
        writer << #\'.
    );
    with inherited own parent = #<:std/Object@std/std.eco>;
},

#=init/string_proxy: {
    size => #'ecosphere.ecore.object.string.byte_length'(self);
    at: index => #'ecosphere.ecore.object.string.at_byte'(self, index);
    do: body => (
        | i <- 0. s <- size. |
        [ i < s ] while: [
            body value(#'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    asVector => (
        | v <- #() clone |
        self do: [ :c | v append: c ].
      ^ v
    );
    writeOn: writer => do: [ :c | writer << c ];
    asKey => #'ecosphere.ecore.object.string.as_key'(self);
    with inherited own parent = #<:std/Object@std/std.eco>;
},

#=init/vector_proxy: {
    size => #'ecosphere.ecore.object.vector.size'(self);
    isEmpty => size isZero;
    at: index => #'ecosphere.ecore.object.vector.at'(self, _norm(index));
    at: index put: value => #'ecosphere.ecore.object.vector.at_put'(self, _norm(index), value);
    at: index insert: value => #'ecosphere.ecore.object.vector.insert'(self, _nnorm(index), value);
    append: value => at: size insert: value;
    remove: index => #'ecosphere.ecore.object.vector.remove'(self, _norm(index));
    do: body => (
        0 for: size do: [ :i => body value(at: i) ].
      ^ self
    );
    asString => #'ecosphere.ecore.object.vector.to_string'(self);
    _norm(i) => (i isNegative) if: [ size + i ] else: [ i ];
    _nnorm(i) => (i isNegative) if: [ size + i + 1 ] else: [ i ];
    with inherited own parent = #<:std/Object@std/std.eco>;
},

#=init/port_proxy: {
    readByte  => (
        | b <- #'ecosphere.ecore.object.port.read_byte'(self) |
        [ b asBool ] until: [
            #'ecosphere.ecore.object.port.notify_me'(self).
            b <- #'ecosphere.ecore.object.port.read_byte'(self)
        ].
      ^ b
    );
    writeByte: b  => (#'ecosphere.ecore.object.port.write_byte'(self, b). ^ self);
    flush     => #'ecosphere.ecore.object.port.flush_output'(self);
    readChar => (
        | b <- readByte, bytes, v |
        begin
          if: [ (b bitAnd: 0b10000000) isZero        ] then: [ ^ b asChar                             ] ~
          if: [ (b bitAnd: 0b11100000) == 0b11000000 ] then: [ v <- b bitAnd: 0b00011111. bytes <- 1. ] ~
          if: [ (b bitAnd: 0b11110000) == 0b11100000 ] then: [ v <- b bitAnd: 0b00001111. bytes <- 2. ] ~
          if: [ (b bitAnd: 0b11111000) == 0b11110000 ] then: [ v <- b bitAnd: 0b00000111. bytes <- 3. ] ~
          default: [ ^ 0xfffd asChar ].
        1 to: bytes do: [ :i |
            b <- readByte.
            ((b bitAnd: 0b11000000) != (0b10000000)) if: [ ^ 0xfffd asChar ].
            v <- ((v shift: 6) bitOr: (b bitAnd: 0b00111111)).
        ].
      ^ v asChar
    );
    writeChar: c => (
        | v <- c asInt |
        begin
          if: [ v <= 0        ] then: [ writeByte: 0xef. writeByte: 0xbf. writeByte: 0xbd. ] ~
          if: [ v <= 0x7f     ] then: [ writeByte: v ] ~
          if: [ v <= 0x7ff    ] then: [ writeByte: (((v rshift: 6) bitAnd: 0x1f) bitOr: 0xc0).
                                        writeByte: (((v)           bitAnd: 0x3f) bitOr: 0x80). ] ~
          if: [ v <= 0xffff   ] then: [ writeByte: (((v rshift: 12) bitAnd: 0x0f) bitOr: 0xe0).
                                        writeByte: (((v rshift:  6) bitAnd: 0x3f) bitOr: 0x80).
                                        writeByte: (((v)            bitAnd: 0x3f) bitOr: 0x80). ] ~
          if: [ v <= 0x10ffff ] then: [ writeByte: (((v rshift: 18) bitAnd: 0x07) bitOr: 0xf0).
                                        writeByte: (((v rshift: 12) bitAnd: 0x3f) bitOr: 0x80).
                                        writeByte: (((v rshift:  6) bitAnd: 0x3f) bitOr: 0x80).
                                        writeByte: (((v rshift:  0) bitAnd: 0x3f) bitOr: 0x80). ] ~
          default: [ writeByte: 0xef. writeByte: 0xbf. writeByte: 0xbd. ].
      ^ self
    );
    readLine => (
        | v <- #() clone, c |
        [
            c <- readChar.
            (c == (10 asChar)) if: [ ^ v asString ].
            v append: c.
        ] repeat.
    );
    char<< c  => writeChar: c;
    << object => ( object writeOn: self. ^ self );
    newline   => ( self << (10 asChar).  ^ self );
    with inherited own parent = #<:std/Object@std/std.eco>;
}
