
#=init/block_proxy: {
    isBlock    => true;
    value(...) => #'ecosphere.ecore.flow.value'(self, ...);
    repeat     => ( self value. #'ecosphere.ecore.flow.reset'() );
    while: b   => ( (self value) unless: [ ^ #<:std/bool/false> ]. b value. #'ecosphere.ecore.flow.reset'() );
    until: b   => ( (self value) if: [ ^ #<:std/bool/true> ]. b value. #'ecosphere.ecore.flow.reset'() );
    and:   b   => (
        | v <- self value |
        v if: [ ^ b value ] else: [ ^ v ]
    );
    or:    b   => (
        | v <- self value |
        v if: [ ^ v ] else: [ ^ b value ]
    );
    writeOn: writer => writer << '<block>';
    with inherited parent = #<:std/Clonable>;
},

#=init/code_proxy: {
    execute(...) => #'ecosphere.ecore.object.code.value'(...);
    writeOn: writer => writer << '<code>';
    with inherited parent = #<:std/Clonable>;
},

#=init/integer_proxy: {
    isInt      => true;
    + other    => #'ecosphere.ecore.math.add'(self, other);
    - other    => #'ecosphere.ecore.math.sub'(self, other);
    * other    => #'ecosphere.ecore.math.mul'(self, other);
    / other    => #'ecosphere.ecore.math.div'(self, other);
    mod: other => #'ecosphere.ecore.math.mod'(self, other);
    bitOr: other => #'ecosphere.ecore.math.bit_or'(self, other);
    bitAnd: other => #'ecosphere.ecore.math.bit_and'(self, other);
    bitXOR: other => #'ecosphere.ecore.math.bit_xor'(self, other);
    lshift: other => #'ecosphere.ecore.math.bitshift_left'(self, other);
    rshift: other => #'ecosphere.ecore.math.bitshift_right'(self, other);
    shift:  other => (other isNegative) if: [ ^ self rshift: (other negate) ] else: [ ^ self lshift: other ];
    < other    => #'ecosphere.ecore.math.less'(self, other);
    == other   => #'ecosphere.ecore.is'(self, other);
    != other   => (self == other) not;
    <= other   => [ self < other ] or: [ self == other ];
    > other    => (self <= other) not;
    >= other   => (self < other) not;
    min: other => (self < other) if: [ self  ] else: [ other ];
    max: other => (self < other) if: [ other ] else: [ self  ];
    isZero     => (self == 0);
    isNotZero  => isZero not;
    isNegative => self < 0;
    isNotNegative => isNegative not;
    isPositive => self > 0;
    inc        => self + 1;
    dec        => self - 1;
    negate     => (0 - self);
    asChar     => #'ecosphere.ecore.int.as_char'(self);
    for: upper do: body => (
        | i <- self |
        [ i < upper ] while: [
            body value(i).
            i <- i + 1.
        ]
    );
    to: upper do: body => for: (upper + 1) do: body;
    do: block => 0 for: self do: block;
    times: block => do: [ :i | block value ];
    countUp: block => (
        | i <- self |
        [ block value(i). i <- i + 1 ] repeat
    );
    countDown: block => (
        | i <- self |
        [ i isPositive ] while: [
            block value(i).
            i <- i - 1
        ]
    );
    writeOn: writer => (
        |
            lib <- {
                Digit(n) => ((#\0 asInt) + n) asChar;
                WriteNumLoop(writer, num, base, digit_func) => (
                    (num isZero) unless: [
                        WriteNumLoop(writer, num / base, base, digit_func).
                        writer << digit_func(num mod: base).
                    ].
                );
                WriteNum(writer, num) => (
                    (num isNegative) if:   [ writer << #\-. num <- num negate ].
                    (num isZero)     if:   [ writer << #\0 ]
                                     else: [ WriteNumLoop(writer, num, 10, [ :i, Digit(i) ]) ]
                );
            }
        |
        lib WriteNum(writer, self);
    );
    with inherited parent = #<:std/Clonable>;
},

#=init/character_proxy: {
    isChar          => true;
    asInt           => #'ecosphere.ecore.char.as_int'(self);
    == other        => #'ecosphere.ecore.is'(self, other);
    != other        => (self == other) not;
    < other         => (self asInt) < (other asInt);
    <= other        => (self asInt) <= (other asInt);
    > other         => (self asInt) > (other asInt);
    >= other        => (self asInt) >= (other asInt);
    writeOn: writer => (
        | v <- asInt |
        begin
            if: [ v <= 0        ] then: [ writer byte<< 0xef. writer byte<< 0xbf. writer byte<< 0xbd. ] ~
            if: [ v <= 0x7f     ] then: [ writer byte<< v ] ~
            if: [ v <= 0x7ff    ] then: [ writer byte<< (((v rshift: 6) bitAnd: 0x1f) bitOr: 0xc0).
                                          writer byte<< (((v)           bitAnd: 0x3f) bitOr: 0x80). ] ~
            if: [ v <= 0xffff   ] then: [ writer byte<< (((v rshift: 12) bitAnd: 0x0f) bitOr: 0xe0).
                                          writer byte<< (((v rshift:  6) bitAnd: 0x3f) bitOr: 0x80).
                                          writer byte<< (((v)            bitAnd: 0x3f) bitOr: 0x80). ] ~
            if: [ v <= 0x10ffff ] then: [ writer byte<< (((v rshift: 18) bitAnd: 0x07) bitOr: 0xf0).
                                          writer byte<< (((v rshift: 12) bitAnd: 0x3f) bitOr: 0x80).
                                          writer byte<< (((v rshift:  6) bitAnd: 0x3f) bitOr: 0x80).
                                          writer byte<< (((v rshift:  0) bitAnd: 0x3f) bitOr: 0x80). ] ~
            default: [ writer byte<< 0xef. writer byte<< 0xbf. writer byte<< 0xbd. ].
      ^ self
    );
    with inherited parent = #<:std/Clonable>;
},

#=init/key_proxy: {
    isKey    => true;
    asString => #'ecosphere.ecore.object.key.as_string'(self);
    writeOn: writer => (
        writer << #\#.
        writer << #\'.
        writer << asString.
        writer << #\'.
    );
    with inherited parent = #<:std/Clonable>;
},

#=init/string_proxy: {
    size => #'ecosphere.ecore.object.string.byte_length'(self);
    at: index => #'ecosphere.ecore.object.string.at_byte'(self, index);
    do: body => (
        | i <- 0. s <- size. |
        [ i < s ] while: [
            body value(#'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    forEach: body => (
        | i <- 0. s <- size. |
        [ i < s ] while: [
            body value(i, #'ecosphere.ecore.object.string.at_byte'(self, i)).
            i <- i + (#'ecosphere.ecore.object.string.step_at_byte'(self, i)).
        ].
      ^ self
    );
    equals: other => (
        (other isString)       unless: [ ^ false ].
        (size == (other size)) unless: [ ^ false ].
        forEach: [ :index, :value |
            (value == (other at: index)) unless: [ ^ false ]
        ].
      ^ true
    );
    contains: character => (
        do: [ :c | (c == character) if: [ ^ true ] ].
      ^ false
    );
    isString => true;
    asVector => (
        | v <- std util newVector |
        self do: [ :c | v append: c ].
      ^ v
    );
    parseInt => (
        | v <- 0, sign <- 1 |
        (size isZero) if: [ ^ No ].
        forEach: [ :i, :c |
            (c == #\-) if: [ ( [ i isZero ] and: [ size > 1 ] ) if: [ sign <- -1 ] else: [ ^ No ] ]
                     else: [
                ([ (c asInt) >= (#\0 asInt) ] and: [ (c asInt) <= (#\9 asInt) ]) unless: [ ^ No ].
                v <- (v * 10) + ((c asInt) - (#\0 asInt))
            ]
        ].
        Yes: (v * sign)
    );
    writeOn: writer => do: [ :c | writer << c ];
    asKey => #'ecosphere.ecore.object.string.as_key'(self);
    + other => (
        | vec <- asVector |
        other do: [ :c | vec append: c ].
      ^ vec asString
    );
    * count => (
        | vec <- std util newVector |
        count times: [
            do: [ :c | vec append: c ]
        ].
      ^ vec asString
    );
    with inherited parent = #<:std/Clonable>;
},

#=init/array_proxy: {
    size => #'ecosphere.ecore.object.array.size'(self);
    isEmpty => size isZero;
    at: index => #'ecosphere.ecore.object.array.at'(self, index);
    at: index put: value => #'ecosphere.ecore.object.array.at_put'(self, index, value);
    isArray => true;
    asString => #'ecosphere.ecore.object.array.to_string'(self);

    writeOn: writer => (std util) WriteIterable: self On: writer;

    with inherited iterations = #<:std/util/StandardListIterations>;
    with inherited conversions = #<:std/util/StandardListConversions>;
    with inherited access = #<:std/util/StandardListAccess>;
    
    with inherited parent = #<:std/Clonable>;
},

#=init/blob_proxy: {
    size => #'ecosphere.ecore.object.blob.size'(self);
    isEmpty => size isZero;
    at: index => #'ecosphere.ecore.object.blob.at'(self, index);
    at: index put: value => at: index putInt8: value;
    at: index putInt8: value => #'ecosphere.ecore.object.blob.at_put_int8'(self, index, value);
    at: index putInt16: value => #'ecosphere.ecore.object.blob.at_put_int16'(self, index, value);
    at: index putInt32: value => #'ecosphere.ecore.object.blob.at_put_int32'(self, index, value);

    with inherited iterations = #<:std/util/StandardListIterations>;
    with inherited conversions = #<:std/util/StandardListConversions>;
    with inherited access = #<:std/util/StandardListAccess>;
    
    writeOn: writer => writer << '<blob: ' << size << '>';

    with inherited parent = #<:std/Clonable>;
},

#=init/port_proxy: {
    readByte => (
        | b <- #'ecosphere.ecore.object.port.read_byte'(self) |
        [ b asBool ] until: [
            #'ecosphere.ecore.object.port.notify_me'(self).
            b <- #'ecosphere.ecore.object.port.read_byte'(self)
        ].
      ^ b
    );

    writeByte: b => (#'ecosphere.ecore.object.port.write_byte'(self, b). ^ self);
    byte<< b     => writeByte: b;

    commit => #'ecosphere.ecore.object.port.flush_output'(self);

    with inherited parent = #<:std/Clonable>;
},

#=init/interface_proxy: {
    writeOn: writer => (
        (self is: any) if: [ writer << 'any'. ^ self ].
        writer << '%[ '.
        getEntryNames do: [ :name | writer << name << ', ' ].   "TODO: Also write types"
        writer << ']'
    );
    size => (
        | c <- 0 |
        [
            (#'ecosphere.ecore.object.interface.get_entry_info'(self, c, -1) == self) if: [ ^ c ].
            c <- c + 1
        ] repeat
    );
    getEntryNames => (
        | s <- size. arr <- std util newArray: s |
        0 for: s do: [ :i | arr at: i put: #'ecosphere.ecore.object.interface.get_entry_info'(self, i, -1) ].
      ^ arr
    );
    with inherited parent = #<:std/Clonable>;
}
