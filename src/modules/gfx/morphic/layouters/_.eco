{
    static with inherited _ = std Module;
    protected morphic = $;

    own LayouterTrait = {
        static with inherited _ = std Trait;
        protected module = $;
        protected morphic => module morphic;

        writeOn: w => w << 'a layouter';

        protected CalcFitMorph: morph ToConstraints: constraints Actual: actual Orientation: orientation => (
            morph layoutForOrientation: orientation
              ~ ifShrinkWrap: [           ^ (actual dimensionForOrientation: orientation) min: (constraints dimensionForOrientation: orientation) ]
                ifFlexible:   [           ^ (constraints dimensionForOrientation: orientation)                                                    ]
                ifRigid:      [ :extent | ^ extent                                                                                                ]
        );

        protected FitMorph: morph ToConstraints: constraints Actual: actual => (
            morph resize: (morphic W: (CalcFitMorph: morph ToConstraints: constraints Actual: actual Orientation: (morphic orientation Horizontal))
                                   H: (CalcFitMorph: morph ToConstraints: constraints Actual: actual Orientation: (morphic orientation Vertical))
        );

        calculateMinSizeForMorph: morph Orientation: orientation => (
            morph baseMinSizeForOrientation: orientation
        );

        layoutMorph: morph Constraints: constraints => (
            FitMorph: morph ToConstraints: constraints Actual: (morph minSize)
        );
    };

    own Default = {
        static with inherited _ = std Clonable;
        with inherited LayouterTrait = $ LayouterTrait;

        "No implementation"
    };

    "TODO: Throw this one away"
    own Flex = {
        static with inherited _ = std Clonable;
        with inherited layouterTrait = $ LayouterTrait;

        orientation;

        protected W: w H: h => morphic W: w H: h;
        protected TransformedW: w H: h => (
            orientation ifHorizontal: [ W: w H: h ] ifVertical: [ W: h H: w ]
        );
        protected Transformed: dimensions => (
            TransformedW: (dimensions width) H: (dimensions height)
        );
        protected Layout: morph => morph layoutForOrientation: orientation;
        protected Extent: morph => morph extentForOrientation: orientation;
        protected OppositeLayout: morph => morph layoutForOrientation: (orientation opposite);
        protected PreferredSize: morph => morph preferredSizeForOrientation: orientation;
        protected OppositePreferredSize: morph => morph preferredSizeForOrientation: (orientation opposite);

        protected calculateMinSizeForMorphMainAxis: morph => (
            | minSize <- 0 |
            morph childrenDo: [ :child |
                minSize <- minSize + (child minSizeForOrientation: orientation).
            ].
          ^ minSize
        );

        protected calculateMinSizeForMorphCrossAxis: morph => (
            | minSize <- 0 |
            morph childrenDo: [ :child |
                minSize <- minSize max: (child minSizeForOrientation: (orientation opposite)).
            ].
          ^ minSize
        );

        calculateMinSizeForMorph: morph Orientation: morphOrientation => (
            (morphOrientation == orientation)
              ~ if: [ calculateMinSizeForMorphMainAxis:  morph ]
              else: [ calculateMinSizeForMorphCrossAxis: morph ]
        );

        layoutMorph: morph Constraints: constraints => (
            |
                rigidCount <- 0,
                flexCount  <- 0,
                offset     <- 0,
                cross      <- 0
            |
            morph childrenDo: [ :child |
                (Layout: child) isFlexible
                  ~ if: [ flexCount <- flexCount + 1.
                          cross     <- cross max: (OppositePreferredSize: child) ]
                  else: [ rigidCount <- rigidCount + 1.
                          | childDimensions <- child layoutInplaceIfChanged |
                          offset <- offset + (childDimensions dimensionForOrientation: orientation).
                          cross  <- cross max: (childDimensions dimensionForOrientation: (orientation opposite)).
                        ].
            ].

            |
                remainingSpace <- (constraints dimensionForOrientation: orientation) - offset,
                flexSize       <- (flexCount isZero) if: [ 0 ] else: [ remainingSpace / flexCount ],
                flexDimensions <- (TransformedW: flexSize H: cross)  "We only calculate it once, for efficiency."
                position       <- 0
            |
            morph childrenDo: [ :child |
                "TODO: Set the new bounds of the child."
                child moveTo: (TransformedW: position H: 0).
                (Layout: child) isFlexible
                  ~ if: [ child layoutDimensionsIfNeeded: flexDimensions ].
                position <- position + child extentForOrientation: orientation.
            ].

            FitMorph: morph ToConstraints: constraints Actual: (TransformedW: position H: cross).
        );

        writeOn: w => w << 'a flex layouter';
    };

    own HFlexLayouter = FlexLayouter clone initWithOrientation: (morphic orientation Horizontal);
    own VFlexLayouter = FlexLayouter clone initWithOrientation: (morphic orientation Vertical);
}
