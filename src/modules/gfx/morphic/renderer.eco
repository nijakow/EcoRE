
    {
        static with inherited _ = std Clonable;
        private morphic = $;

        width, height,
        protected offsets,
        protected clips,
        protected eve,
        protected texture;

        with inherited trait = {
            initWithEve: _eve X: _x Y: _y W: _w H: _h => (
                eve         <- _eve.
                width       <- _w.
                height      <- _h.
                offsets     <- std util newStack.
                offsets push: (morphic X: _x Y: _y).
                clips       <- std util newStack.
                clips push: (morphic X: _x Y: _y W: width H: height).

              ^ self
            );

            initWithEve: _eve => initWithEve: _eve X: 0 Y: 0 W: (_eve CurrentWidth) H: (_eve CurrentHeight);

            offset => offsets top;
            pushOffset: point => offsets push: point;
            popOffset => offsets pop;
            withPushedOffset: offset Do: block => (
                pushOffset: offset.
                block value.
                popOffset.
              ^ self
            );

            clip => clips top;
            withClipW: w H: h Do: block => (
                | rect <- morphic X: xOff Y: yOff W: w H: h |
                clips push: rect.
                eve Clip(xOff, yOff, w, h).
                block value.
                clips pop.
                eve Clip(clip x, clip y, clip w, clip h).
              ^ self
            );

            xOff => offset x;
            yOff => offset y;

            clear => eve Clear;
            present => eve Render;

            setR: r G: g B: b => eve SetColorRGB(r, g, b);
            setColor: color => (
                setR: color r
                   G: color g
                   B: color b
            );

            drawPointX: x Y: y => eve DrawPoint(xOff + x, yOff + y);
            drawLineX: x1 Y: y1 X: x2 Y: y2 => eve DrawLine(xOff + x1, yOff + y1, xOff + x2, yOff + y2);
            drawRectX: x Y: y W: w H: h => eve DrawRect(xOff + x, yOff + y, w, h);
            drawRect: rect => drawRectX: rect x Y: rect y W: rect w H: rect h;
            fillRectX: x Y: y W: w H: h => eve FillRect(xOff + x, yOff + y, w, h);
            fillRect: rect => fillRectX: rect x Y: rect y W: rect w H: rect h;
            drawText: text X: x Y: y => eve DrawText(text text, xOff + x, yOff + y);

            accept: morph => morph renderOn: self;

            writeOn: w => w << 'a morphic renderer';
        };
    };
