{
    static with inherited _ = std Module;

    own Renderer = {
        static with inherited _ = std Clonable;
        private module = $;

        protected boundsstack,
        protected sdlRenderer;

        with inherited trait = {
            initWithSDLRenderer: _sdl_renderer X: _x Y: _y W: _w H: _h => (
                sdlRenderer <- _sdl_renderer.
                boundsstack <- std util newStack.
                pushBounds: ((module Rectangle) newX: _x Y: _y W: _w H: _h).
              ^ self
            );

            bounds => boundsstack top;
            pushBounds: b => boundsstack push: b;
            popBounds => boundsstack pop;

            xOff => bounds x;
            yOff => bounds y;

            clear => sdlRenderer clear;
            present => sdlRenderer present;

            setR: r G: g B: b => sdlRenderer setR: r G: g B: b;
            setColor: color => sdlRenderer setColor: color;

            drawPointX: x Y: y => sdlRenderer drawPointX: xOff + x Y: yOff + y;
            drawLineX: x1 Y: y1 X: x2 Y: y2 => sdlRenderer drawLineX: xOff + x1 Y: yOff + y1 X: xOff + x2 Y: yOff + y2;
            drawRectX: x Y: y W: w H: h => sdlRenderer drawRectX: xOff + x Y: yOff + y W: w H: h;
            drawRect: rect => drawRectX: rect x Y: rect y W: rect w H: rect h;
            fillRectX: x Y: y W: w H: h => sdlRenderer fillRectX: xOff + x Y: yOff + y W: w H: h;
            fillRect: rect => fillRectX: rect x Y: rect y W: rect w H: rect h;

            accept: morph => morph renderOn: self;

            writeOn: w => w << 'a morphic renderer';
        };
    };

    own Rectangle = {
        static with inherited _ = std Clonable;

        x, y, w, h;

        with inherited trait = {
            init => (
                x: 0 y: 0 w: 1 h: 1.
              ^ self
            );

            newX: xv Y: yv W: wv H: hv => (
              ^ (self new)
                    x: xv
                    y: yv
                    w: wv
                    h: hv
            );

            offsetToX: x Y: y => newX: x Y: y W: w H: h;
            offsetByX: xoff Y: yoff => newX: x + xoff Y: y + yoff W: w H: h;
            resizeToW: w H: h => newX: x Y: y W: w H: h;

            x: xv => x <- xv;
            y: yv => y <- yv;
            w: wv => w <- wv;
            h: hv => h <- hv;

            x: xv y: yv w: wv h: hv => (
                x: xv.
                y: yv.
                w: wv.
                h: hv.
              ^ self
            );

            containsX: px Y: py => (
                (px < x) -> [ ^ false ].
                (py < y) -> [ ^ false ].
                (px >= (x + w)) -> [ ^ false ].
                (py >= (y + h)) -> [ ^ false ].
              ^ true
            );

            originForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ ^ x ]
                      ifVertical: [ ^ y ]
            );

            dimensionForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ ^ w ]
                      ifVertical: [ ^ h ]
            );

            writeOn: writer => writer << 'a rectangle(' << x << ', ' << y << ', ' << w << ', ' << h << ')';
        };
    };

    own Point2D = {
        static with inherited _ = std Clonable;
        private module = $;

        private x;
        private y;

        with inherited trait = {
            NewX: _x Y: _y => self clone initWithX: _x Y: _y;

            initWithX: _x Y: _y => (
                x <- _x.
                y <- _y.
              ^ self
            );

            x: xv => x <- xv;
            y: yv => y <- yv;

            x: xv y: yv => x: xv ~ y: yv;

            offsetBy: p => module Point2D NewX: (x + p) Y: (y + p);
            offsetBy: p Do: block => block value(offsetBy: p);

            writeOn: w => w << 'a point(' << x << ', ' << y << ')';
        };
    };

    own FlexibleSize = {
        static with inherited _ = std Singleton;

        with inherited trait = {
            isFlexible: flexible isRigid: rigid isShrinkWrap: sw => flexible value;
            isFlexible: flexible isRigid: rigid => flexible value;

            lowerForLower: lower Upper: upper => lower;
            upperForLower: lower Upper: upper => upper;
        };
    };

    own RigidSize = {
        static with inherited _ = std Clonable;

        private lower,
        private upper;

        with inherited trait = {
            initWithLower: _lower Upper: _upper => (
                lower <- _lower.
                upper <- _upper.
              ^ self
            );

            isFlexible: flexible isRigid: rigid isShrinkWrap: sw => rigid value(self);
            isFlexible: flexible isRigid: rigid => rigid value(self);

            lowerForLower: context_low Upper: context_up => context_low + lower;
            upperForLower: context_low Upper: context_up => context_low + upper;
        };
    };

    own RelativeSize = {
        static with inherited _ = std Clonable;

        private lower,
        private upper;

        with inherited trait = {
            initWithLower: _lower Upper: _upper => (
                lower <- _lower.
                upper <- _upper.
              ^ self
            );

            isFlexible: flexible isRigid: rigid isShrinkWrap: sw => rigid value(self);
            isFlexible: flexible isRigid: rigid => rigid value(self);

            lowerForLower: context_low Upper: context_up => (context_low + ((context_up - context_low) * lower)) asInt;
            upperForLower: context_low Upper: context_up => (context_up  - ((context_up - context_low) * upper)) asInt;
        };
    };

    RigidSize: size => RigidSize clone initWithLower: 0 Upper: size;
    RigidSizeWithLower: lower Upper: upper => RigidSize clone initWithLower: lower Upper: upper;

    MarginLeft: lower Right: upper => RelativeSize clone initWithLower: (lower asFloat / 100.0) Upper: (upper asFloat / 100.0);
    Margin: both => MarginLeft: both Right: both;

    own Morph = {
        static with inherited _ = std Clonable;
        private module = $;

        with inherited trait = {
            init => (
              ^ self
            );

            renderOn: renderer => self;

            childrenDo: block => self;
            childrenWithBoundsDo: block ContextBounds: bounds => self;

            xResizeBehavior => module FlexibleSize;
            yResizeBehavior => module FlexibleSize;
            sizePropertiesForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ xResizeBehavior ]
                      ifVertical: [ yResizeBehavior ]
            );

            sizePropertiesForOrientation: orientation Bounds: bounds => (
              ^ sizePropertiesForOrientation: orientation
            );

            processEvent: event AtX: evtX Y: evtY Bounds: bounds => self;

            issueEvent: event AtX: evtX Y: evtY Bounds: cbounds => (
                std io out << 'Received ' << evtX << ' ' << evtY << ' in ' << self ~ newline.
                childrenWithBoundsDo: [ :child, :bounds |
                    bounds containsX: evtX Y: evtY
                      ~ if: [ child issueEvent: event AtX: (evtX - bounds x) Y: (evtY - bounds y) Bounds: (bounds offsetToX: 0 Y: 0) ]
                ] ContextBounds: cbounds.
                processEvent: event AtX: evtX Y: evtY Bounds: cbounds.
            );

            writeOn: w => w << 'a morph';
        };
    };

    own Vertical = {
        static with inherited _ = std Singleton;
        private module = $;

        isHorizontal => false;
        isVertical   => true;

        ifHorizontal: block => self;
        ifVertical:   block => block value;
        ifHorizontal: horiz
          ifVertical: verti => verti value;
        
        opposite => module Horizontal;
    },

    own Horizontal = {
        static with inherited _ = std Singleton;
        private module = $;

        isHorizontal => true;
        isVertical   => false;

        ifHorizontal: block => block value;
        ifVertical:   block => self;
        ifHorizontal: horiz
          ifVertical: verti => horiz value;
        
        opposite => module Vertical;
    },

    own Box = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Morph;
        private module = $;

        protected orientation,
        protected children;

        initWithOrientation: _orientation => (
            my super init.
            orientation <- _orientation.
            children    <- std util newVector.
            ^ self
        );

        childrenDo: block => (
            my super childrenDo: block.
            children do: block.
            ^ self
        );

        with inherited trait = {
            initHorizontal => initWithOrientation: module Horizontal;
            initVertical   => initWithOrientation: module Vertical;

            addChild: child => ( children add: child. ^ self );
            add:      child => addChild: child;

            childrenWithBoundsDo: block ContextBounds: bounds => (
                |
                    lower  <- bounds originForOrientation: orientation,
                    diff   <- bounds dimensionForOrientation: orientation,
                    higher <- lower + diff,
                    
                    fixed     <- 0,
                    flexCount <- 0
                |
                childrenDo: [ :c |
                    c sizePropertiesForOrientation: orientation Bounds: bounds
                      ~ isFlexible: [      flexCount <- flexCount + 1       ]
                           isRigid: [ :s | fixed     <- fixed + (s upperForLower: 0 Upper: (bounds dimensionForOrientation: orientation)) ]
                ].
                |
                    gap  <- (flexCount isZero) if: [ 1 ] else: [ (diff - fixed) / flexCount ],
                    xPos <- 0
                |
                childrenDo: [ :c |
                    | xPosOld <- xPos |
                    c sizePropertiesForOrientation: orientation Bounds: bounds
                      ~ isFlexible: [      xPos <- xPos + gap     ]
                           isRigid: [ :s | xPos <- xPos + (s upperForLower: 0 Upper: (bounds dimensionForOrientation: orientation)) ].
                    | yMax |
                    c sizePropertiesForOrientation: orientation opposite Bounds: bounds
                      ~ isFlexible: [      yMax <- bounds dimensionForOrientation: orientation opposite ]
                           isRigid: [ :s | yMax <- s upperForLower: 0 Upper: (bounds dimensionForOrientation: orientation opposite) ].
                    | r |
                    orientation
                      ~ ifHorizontal: [ r <- module Rectangle newX: lower + xPosOld Y: bounds y W: xPos - xPosOld H: yMax ]
                          ifVertical: [ r <- module Rectangle newX: bounds x Y: lower + xPosOld W: yMax H: xPos - xPosOld ].
                    block value(c, r).
                ].
            );

            renderOn: renderer => (
                childrenWithBoundsDo: [ :c, :b |
                    renderer pushBounds: b.
                    renderer accept: c.
                    renderer popBounds.
                ] ContextBounds: renderer bounds
            );

            writeOn: w => w << 'a box morph';
        };
    };

    own HBox = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Box;
        private module = $;

        with inherited trait = {
            init => initHorizontal;

            writeOn: w => w << 'an hbox morph';
        };
    };

    own VBox = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Box;
        private module = $;

        with inherited trait = {
            init => initVertical;

            writeOn: w => w << 'a vbox morph';
        };
    };

    own Frame = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Morph;
        private module = $;

        xResizeBehavior, yResizeBehavior, child;

        with inherited trait = {
            init => (
                super init.
                xResizeBehavior: module FlexibleSize.
                yResizeBehavior: module FlexibleSize.
                child <- No.
              ^ self
            );

            xResizeBehavior: rb => xResizeBehavior <- rb;
            yResizeBehavior: rb => yResizeBehavior <- rb;

            child: cv => child <- Yes: cv;

            childrenDo: block => (
                super childrenDo: block.
                child yes: [ :c | block value(c) ].
            );

            childrenWithBoundsDo: block ContextBounds: bounds => (
                |
                    newBounds <- module Rectangle newX: (sizePropertiesForOrientation: module Horizontal Bounds: bounds ~ lowerForLower: bounds x Upper: bounds x + bounds w)
                                                     Y: (sizePropertiesForOrientation: module Vertical   Bounds: bounds ~ lowerForLower: bounds y Upper: bounds y + bounds h)
                                                     W: (sizePropertiesForOrientation: module Horizontal Bounds: bounds ~ upperForLower: 0 Upper: bounds w)
                                                     H: (sizePropertiesForOrientation: module Vertical   Bounds: bounds ~ upperForLower: 0 Upper: bounds h)
                |
                super childrenWithBoundsDo: block ContextBounds: newBounds.
                child yes: [ :c | block value(c, newBounds) ].
            );

            renderOn: renderer => (
                childrenWithBoundsDo: [ :c, :b |
                    renderer pushBounds: b.
                    renderer accept: c.
                    renderer popBounds.
                ] ContextBounds: renderer bounds
            );

            writeOn: w => w << 'a frame morph';
        };
    };

    own ColorMorph = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Morph;
        private module = $;

        r, g, b;

        with inherited trait = {
            init => (
                super init.
                r <- 255.
                g <- 255.
                b <- 0.
              ^ self
            );

            r: _r g: _g b: _b => (
                r <- _r.
                g <- _g.
                b <- _b.
              ^ self
            );

            renderOn: renderer => (
                renderer setR: r G: g B: b.
                renderer fillRectX: 0 Y: 0 W: renderer bounds w H: renderer bounds h.
            );

            writeOn: w => w << 'a color morph(' << r << ', ' << g << ', ' << b << ')';
        };
    };
}
