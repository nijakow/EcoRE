{
    static with inherited _ = std Module;

    own Renderer = {
        static with inherited _ = std Clonable;
        private module = $;

        protected boundsstack,
        protected sdlRenderer;

        with inherited trait = {
            initWithSDLRenderer: _sdl_renderer X: _x Y: _y W: _w H: _h => (
                sdlRenderer <- _sdl_renderer.
                boundsstack <- std util newStack.
                boundsstack push: ((module Rectangle) newX: _x Y: _y W: _w H: _h).
              ^ self
            );

            bounds => boundsstack top;
            pushBounds: b => boundsstack push: (b offsetByX: xOff Y: yOff);
            popBounds => boundsstack pop;

            xOff => bounds x;
            yOff => bounds y;

            clear => sdlRenderer clear;
            present => sdlRenderer present;

            setR: r G: g B: b => sdlRenderer setR: r G: g B: b;
            setColor: color => sdlRenderer setColor: color;

            drawPointX: x Y: y => sdlRenderer drawPointX: xOff + x Y: yOff + y;
            drawLineX: x1 Y: y1 X: x2 Y: y2 => sdlRenderer drawLineX: xOff + x1 Y: yOff + y1 X: xOff + x2 Y: yOff + y2;
            drawRectX: x Y: y W: w H: h => sdlRenderer drawRectX: xOff + x Y: yOff + y W: w H: h;
            drawRect: rect => drawRectX: rect x Y: rect y W: rect w H: rect h;
            fillRectX: x Y: y W: w H: h => sdlRenderer fillRectX: xOff + x Y: yOff + y W: w H: h;
            fillRect: rect => fillRectX: rect x Y: rect y W: rect w H: rect h;

            accept: morph => morph renderOn: self;

            writeOn: w => w << 'a morphic renderer';
        };
    };

    own Vertical = {
        static with inherited _ = std Singleton;
        private module = $;

        isHorizontal => false;
        isVertical   => true;

        ifHorizontal: block => self;
        ifVertical:   block => block value;
        ifHorizontal: horiz
          ifVertical: verti => verti value;
        
        opposite => module Horizontal;
    },

    own Horizontal = {
        static with inherited _ = std Singleton;
        private module = $;

        isHorizontal => true;
        isVertical   => false;

        ifHorizontal: block => block value;
        ifVertical:   block => self;
        ifHorizontal: horiz
          ifVertical: verti => horiz value;
        
        opposite => module Vertical;
    },

    own Rectangle = {
        static with inherited _ = std Clonable;

        x, y, w, h;

        with inherited trait = {
            init => (
                x: 0 y: 0 w: 1 h: 1.
              ^ self
            );

            newX: xv Y: yv W: wv H: hv => (
              ^ (self new)
                    x: xv
                    y: yv
                    w: wv
                    h: hv
            );

            offsetToX: x Y: y => newX: x Y: y W: w H: h;
            offsetByX: xoff Y: yoff => newX: x + xoff Y: y + yoff W: w H: h;
            resizeToW: w H: h => newX: x Y: y W: w H: h;

            x: xv => x <- xv;
            y: yv => y <- yv;
            w: wv => w <- wv;
            h: hv => h <- hv;

            x: xv y: yv => x: xv ~ y: yv;

            x: xv y: yv w: wv h: hv => (
                x: xv.
                y: yv.
                w: wv.
                h: hv.
              ^ self
            );

            fromRectangle: rect => (
                x: rect x
                y: rect y
                w: rect w
                h: rect h
            );

            containsX: px Y: py => (
                (px < x) -> [ ^ false ].
                (py < y) -> [ ^ false ].
                (px >= (x + w)) -> [ ^ false ].
                (py >= (y + h)) -> [ ^ false ].
              ^ true
            );

            originForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ ^ x ]
                      ifVertical: [ ^ y ]
            );

            dimensionForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ ^ w ]
                      ifVertical: [ ^ h ]
            );

            writeOn: writer => writer << 'a rectangle(' << x << ', ' << y << ', ' << w << ', ' << h << ')';
        };
    };

    own Point2D = {
        static with inherited _ = std Clonable;
        private module = $;

        private x;
        private y;

        with inherited trait = {
            NewX: _x Y: _y => self clone initWithX: _x Y: _y;

            initWithX: _x Y: _y => (
                x <- _x.
                y <- _y.
            ^ self
            );

            x: xv => x <- xv;
            y: yv => y <- yv;

            x: xv y: yv => x: xv ~ y: yv;

            offsetBy: p => module Point2D NewX: (x + p) Y: (y + p);
            offsetBy: p Do: block => block value(offsetBy: p);

            writeOn: w => w << 'a point(' << x << ', ' << y << ')';
        };
    };

    own layouts = {
        own ShrinkWrap = {
            static with inherited _ = std Singleton;

            with inherited trait = {
                ifShrinkWrap: shrinkwrap ifFlexible: flexible ifRigid: rigid => shrinkwrap value;

                isShrinkWrap => true;
                isFlexible => false;
                isRigid => false;
            };
        };

        own Flexible = {
            static with inherited _ = std Singleton;

            with inherited trait = {
                ifShrinkWrap: shrinkwrap ifFlexible: flexible ifRigid: rigid => flexible value;

                isShrinkWrap => false;
                isFlexible => true;
                isRigid => false;
            };
        };

        own Rigid = {
            static with inherited _ = std Singleton;

            with inherited trait = {
                ifShrinkWrap: shrinkwrap ifFlexible: flexible ifRigid: rigid => rigid value;

                isShrinkWrap => false;
                isFlexible => false;
                isRigid => true;
            };
        };
    };

    own Morph = {
        static with inherited _ = std Clonable;
        private module = $;

        bounds,
        xLayout, yLayout;
        parent, children;

        with inherited trait = {
            init => (
                bounds   <- (module Rectangle) new.
                xLayout  <- module layouts Flexible.
                yLayout  <- module layouts Flexible.
                parent   <- No.
                children <- std util newVector.
              ^ self
            );

            boundsX: x Y: y W: w H: h => (
                bounds x: x y: y w: w h: h.
              ^ self
            );

            moveToX: x Y: y   => boundsX: x Y: y W: bounds w H: bounds h;
            resizeToW: w H: h => boundsX: bounds x Y: bounds y W: w H: h;

            width  => bounds w;
            height => bounds h;

            extentForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ width  ]
                      ifVertical: [ height ]
            );

            minWidth  => width;  "TODO"
            minHeight => height; "TODO"

            minExtentForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ minWidth  ]
                      ifVertical: [ minHeight ]
            );

            xLayout: layout => xLayout <- layout;
            yLayout: layout => yLayout <- layout;

            layoutForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ xLayout ]
                      ifVertical: [ yLayout ]
            );

            root => (
                parent yes: [ :p | p root ]
                        no: [      self   ]
            );

            childrenDo: block => children do: block;
            allChildrenDo: block => childrenDo: [ :c | block value(c). c allChildrenDo: block ];

            unlink => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );

            noParent  => parent <- No.
            parent: p => parent <- Yes: p;

            add: child => (
                child unlink.
                children add: child.
                child parent: self.
              ^ self
            );

            remove: child => (
                children remove: child
                  ~ yes: [ child noParent ].
              ^ self
            );

            writeOn: w => w << 'a morph';
        };
    };

    own BoxMorph = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Morph;
        private module = $;

        protected orientation;

        with inherited trait = {
            initWithOrientation: _orientation => (
                $(super) init.
                orientation <- _orientation.
              ^ self
            );

            initHorizontal => initWithOrientation: module Horizontal;
            initVertical   => initWithOrientation: module Vertical;

            layoutInPlace => (
                |
                    lower  <- 0,
                    higher <- bounds dimensionForOrientation: orientation,
                    diff   <- higher - lower,

                    flexCount <- 0,
                    reservedF <- 0,
                    reservedN <- 0,
                    budget    <- 0
                |

                childrenDo: [ :c |
                    (c layoutForOrientation: orientation) isFlexible
                      ~   if: [ flexCount <- flexCount + 1.
                                reservedF <- reservedF + (c minExtentForOrientation: orientation) ]
                        else: [ reservedN <- reservedN + (c minExtentForOrientation: orientation) ]
                ].

                budget <- (bounds dimensionForOrientation: orientation) max: (reservedF + reservedN).

                |
                    offset <- 0
                |

                childrenDo: [ :c |
                    |
                        minSpace <- c minExtentForOrientation: orientation,
                        spaceForM
                    |
                    (c layoutForOrientation: orientation) isFlexible if: [
                        | available <- budget - reservedN - (reservedF - minSpace) |
                        spaceForM <- (budget - reservedN) / flexCount.
                        (spaceForM > available) -> [ spaceForM <- available ].
                        (spaceForM < minSpace)  -> [ spaceForM <- minSpace  ].
                        flexCount <- flexCount - 1.
                        reservedF <- reservedF - minSpace.
                    ] else: [
                        spaceForM <- minSpace.
                        reservedN <- reservedN - minSpace.
                    ].

                    |
                        heightForM
                    |
                    
                    (c layoutForOrientation: orientation opposite) isFlexible if: [
                        heightForM <- height
                    ] else: [
                        heightForM <- c minHeight
                    ].

                    orientation
                      ~ ifHorizontal: [ c boundsX: offset Y: 0 W: spaceForM H: heightForM ]
                          ifVertical: [ c boundsX: 0 Y: offset W: heightForM H: spaceForM ].
                    
                    offset <- offset + spaceForM.
                ].
            );
        };
    };

    own HBoxMorph = {
        static with inherited _ = std Clonable;
        with inherited own super = $ BoxMorph;
        private module = $;

        with inherited trait = {
            init => (
                $(super) initHorizontal.
              ^ self
            );

            writeOn: w => w << 'an hbox morph';
        };
    };

    own VBoxMorph = {
        static with inherited _ = std Clonable;
        with inherited own super = $ BoxMorph;
        private module = $;

        with inherited trait = {
            init => (
                $(super) initVertical.
              ^ self
            );

            writeOn: w => w << 'a vbox morph';
        };
    };
}
