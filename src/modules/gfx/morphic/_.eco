{
    static with inherited _ = std Module;

    own Renderer = {
        static with inherited _ = std Clonable;
        private module = $;

        protected boundsstack,
        protected sdlRenderer;

        with inherited trait = {
            initWithSDLRenderer: _sdl_renderer X: _x Y: _y W: _w H: _h => (
                sdlRenderer <- _sdl_renderer.
                boundsstack <- std util newStack.
                boundsstack push: ((module Rectangle) newX: _x Y: _y W: _w H: _h).
              ^ self
            );

            bounds => boundsstack top;
            pushBounds: b => boundsstack push: (b offsetByX: xOff Y: yOff);
            popBounds => boundsstack pop;
            withPushedBounds: b Do: block => (
                pushBounds: b.
                block value.
                popBounds.
              ^ self
            );

            xOff => bounds x;
            yOff => bounds y;

            clear => sdlRenderer clear;
            present => sdlRenderer present;

            setR: r G: g B: b => sdlRenderer setR: r G: g B: b;
            setColor: color => sdlRenderer setColor: color;

            drawPointX: x Y: y => sdlRenderer drawPointX: xOff + x Y: yOff + y;
            drawLineX: x1 Y: y1 X: x2 Y: y2 => sdlRenderer drawLineX: xOff + x1 Y: yOff + y1 X: xOff + x2 Y: yOff + y2;
            drawRectX: x Y: y W: w H: h => sdlRenderer drawRectX: xOff + x Y: yOff + y W: w H: h;
            drawRect: rect => drawRectX: rect x Y: rect y W: rect w H: rect h;
            fillRectX: x Y: y W: w H: h => sdlRenderer fillRectX: xOff + x Y: yOff + y W: w H: h;
            fillRect: rect => fillRectX: rect x Y: rect y W: rect w H: rect h;

            accept: morph => morph renderOn: self;

            writeOn: w => w << 'a morphic renderer';
        };
    };

    own Vertical = {
        static with inherited _ = std Singleton;
        private module = $;

        isHorizontal => false;
        isVertical   => true;

        ifHorizontal: block => self;
        ifVertical:   block => block value;
        ifHorizontal: horiz
          ifVertical: verti => verti value;
        
        opposite => module Horizontal;
    },

    own Horizontal = {
        static with inherited _ = std Singleton;
        private module = $;

        isHorizontal => true;
        isVertical   => false;

        ifHorizontal: block => block value;
        ifVertical:   block => self;
        ifHorizontal: horiz
          ifVertical: verti => horiz value;
        
        opposite => module Vertical;
    },

    own Rectangle = {
        static with inherited _ = std Clonable;

        x, y, w, h;

        with inherited trait = {
            init => (
                x: 0 y: 0 w: 1 h: 1.
              ^ self
            );

            newX: xv Y: yv W: wv H: hv => (
              ^ (self new)
                    x: xv
                    y: yv
                    w: wv
                    h: hv
            );

            offsetToX: x Y: y => newX: x Y: y W: w H: h;
            offsetByX: xoff Y: yoff => newX: x + xoff Y: y + yoff W: w H: h;
            resizeToW: w H: h => newX: x Y: y W: w H: h;

            x: xv => x <- xv;
            y: yv => y <- yv;
            w: wv => w <- wv;
            h: hv => h <- hv;

            x: xv y: yv => x: xv ~ y: yv;

            x: xv y: yv w: wv h: hv => (
                x: xv.
                y: yv.
                w: wv.
                h: hv.
              ^ self
            );

            fromRectangle: rect => (
                x: rect x
                y: rect y
                w: rect w
                h: rect h
            );

            containsX: px Y: py => (
                (px < x) -> [ ^ false ].
                (py < y) -> [ ^ false ].
                (px >= (x + w)) -> [ ^ false ].
                (py >= (y + h)) -> [ ^ false ].
              ^ true
            );

            originForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ ^ x ]
                      ifVertical: [ ^ y ]
            );

            dimensionForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ ^ w ]
                      ifVertical: [ ^ h ]
            );

            writeOn: writer => writer << 'a rectangle(' << x << ', ' << y << ', ' << w << ', ' << h << ')';
        };
    };

    own Point2D = {
        static with inherited _ = std Clonable;
        private module = $;

        x, y;

        with inherited trait = {
            NewX: _x Y: _y => self clone initWithX: _x Y: _y;

            initWithX: _x Y: _y => (
                x <- _x.
                y <- _y.
              ^ self
            );

            + p => NewX: x + p x Y: y + p y;
            - p => NewX: x - p x Y: y - p y;

            negate => NewX: x negate Y: y negate;

            offsetBy: p => module Point2D NewX: (x + p) Y: (y + p);
            offsetBy: p Do: block => block value(offsetBy: p);

            writeOn: w => w << 'a point(' << x << ', ' << y << ')';
        };
    };

    own layouts = {
        own ShrinkWrap = {
            static with inherited _ = std Singleton;

            with inherited trait = {
                ifShrinkWrap: shrinkwrap ifFlexible: flexible ifRigid: rigid => shrinkwrap value;

                isShrinkWrap => true;
                isFlexible => false;
                isRigid => false;
            };
        };

        own Flexible = {
            static with inherited _ = std Singleton;

            with inherited trait = {
                ifShrinkWrap: shrinkwrap ifFlexible: flexible ifRigid: rigid => flexible value;

                isShrinkWrap => false;
                isFlexible => true;
                isRigid => false;
            };
        };

        own Rigid = {
            static with inherited _ = std Singleton;

            with inherited trait = {
                ifShrinkWrap: shrinkwrap ifFlexible: flexible ifRigid: rigid => rigid value;

                isShrinkWrap => false;
                isFlexible => false;
                isRigid => true;
            };
        };
    };

    own Morph = {
        static with inherited _ = std Clonable;
        protected morphic = $;

        bounds,
        xLayout, yLayout;
        parent, children;

        protected layoutOkay,
        protected cachedMinWidth,
        protected cachedMinHeight;

        with inherited trait = {
            init => (
                bounds   <- (morphic Rectangle) new.
                xLayout  <- (morphic layouts Flexible).
                yLayout  <- (morphic layouts Flexible).
                parent   <- No.
                children <- std util newVector.
                layoutOkay      <- false.
                cachedMinWidth  <- No.
                cachedMinHeight <- No.
              ^ self
            );

            globalBounds => (
                parent
                  ~ yes: [ :p | | pgb <- p globalBounds | ^ bounds offsetByX: pgb x Y: pgb y ]
                     no: [ ^ bounds                                                          ]
            );

            boundsX: x Y: y W: w H: h => (
                bounds x: x y: y w: w h: h.
              ^ self
            );
            bounds: rect => boundsX: rect x Y: rect y W: rect w H: rect h;

            moveToX: x Y: y   => boundsX: x Y: y W: bounds w H: bounds h;
            resizeToW: w H: h => boundsX: bounds x Y: bounds y W: w H: h;

            offset => (morphic Point2D clone) initWithX: bounds x Y: bounds y;
            globalOffset => (
                | b <- globalBounds |
              ^ (morphic Point2D clone) initWithX: b x Y: b y
            );

            width  => bounds w;
            height => bounds h;

            baseMinWidth  => 0;
            baseMinHeight => 0;

            resizeToW: w => resizeToW: w H: height;
            resizeToH: h => resizeToW: width H: h;

            extentForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ width  ]
                      ifVertical: [ height ]
            );

            layoutOkay: v   => layoutOkay <- v;
            layoutIsNowOkay => layoutOkay: true;

            cachedMinWidth:  v => cachedMinWidth  <- Yes: v;
            cachedMinHeight: v => cachedMinHeight <- Yes: v;
            invalidateMinSizeCaches => (
                cachedMinWidth  <- No.
                cachedMinHeight <- No.
            );
            updateMinSizeCaches => (
                "TODO: Go through all the submorphs"
                cachedMinWidth:  baseMinWidth.
                cachedMinHeight: baseMinHeight.
            );

            minWidth => (
                xLayout isRigid -> [ ^ width ].
                cachedMinWidth no: [ updateMinSizeCaches ].
              ^ cachedMinWidth yes
            );
            minHeight => (
                yLayout isRigid -> [ ^ height ].
                cachedMinHeight no: [ updateMinSizeCaches ].
              ^ cachedMinHeight yes
            );

            minExtentForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ minWidth  ]
                      ifVertical: [ minHeight ]
            );

            invalidateLayoutCaches => (
                layoutOkay: false.
                invalidateMinSizeCaches.
            );

            layoutChanged => (
                invalidateLayoutCaches.
                world yes: [ :w | w dirty ].
            );

            xLayout: layout => xLayout <- layout;
            yLayout: layout => yLayout <- layout;

            rigidWidth:  w => xLayout: morphic layouts Rigid ~ resizeToW: w;
            rigidHeight: h => yLayout: morphic layouts Rigid ~ resizeToH: h;

            layoutForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ xLayout ]
                      ifVertical: [ yLayout ]
            );

            root => (
                parent yes: [ :p | p root ]
                        no: [      self   ]
            );

            world => Yes: root;

            childrenDo: block => children do: block;
            allChildrenDo: block => childrenDo: [ :c | block value(c). c allChildrenDo: block ];
            childrenWithBoundsDo: block => childrenDo: [ :c | block value(c, c bounds) ];

            unlink => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );

            noParent  => parent <- No.
            parent: p => parent <- Yes: p;

            add: child => (
                child unlink.
                children add: child.
                child parent: self.
                child invalidateLayoutCaches.
                layoutChanged.
              ^ self
            );

            remove: child => (
                children remove: child
                  ~ yes: [ child noParent. layoutChanged ].
              ^ self
            );

            remove => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );

            layoutInPlace => childrenDo: [ :c | c layoutInPlace ];
            layoutInPlaceIfNeeded => layoutOkay false: [ layoutInPlace ];
            shrinkToFit => (
                "Only shrink if there is a parent"
                parent yes: [
                    xLayout isShrinkWrap -> [ resizeToW: minWidth  ].
                    yLayout isShrinkWrap -> [ resizeToH: minHeight ].
                ]
            );

            renderChildrenOn: renderer => (
                childrenDo: [ :c |
                    renderer pushBounds: c bounds.
                    renderer accept: c.
                    renderer popBounds.
                ].
            );
            renderOn: renderer => renderChildrenOn: renderer;

            processEvent: event AtX: x Y: y => (
                (std io out << 'Received event in ' << self << '(' << x << ', ' << y << ')') newline commit.
            );

            issueEvent: event AtX: evtX Y: evtY => (
                processEvent: event AtX: evtX Y: evtY.
                childrenWithBoundsDo: [ :c, :b |
                    b containsX: evtX Y: evtY
                      ~ if: [ c issueEvent: event AtX: (evtX - b x) Y: (evtY - b y) ]
                ].
              ^ self
            );

            xRayAtX: x Y: y Do: block => (
                block value(self).
                childrenWithBoundsDo: [ :c, :b |
                    b containsX: x Y: y
                      ~ if: [ c xRayAtX: (x - b x) Y: (y - b y) Do: block ]
                ].
              ^ self
            );

            handleDropMorph: morph AtX: x Y: y => (
              ^ false
            );

            dropMorph: morph AtX: x Y: y => (
                (handleDropMorph: morph AtX: x Y: y) -> [ ^ true ].
                childrenWithBoundsDo: [ :c, :b |
                    b containsX: x Y: y
                      ~ if: [ (c dropMorph: morph AtX: (x - b x) Y: (y - b y)) -> [ ^ true ] ].
                ].
              ^ false
            );

            writeOn: w => w << 'a morph';
        };
    };

    own BoxMorph = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Morph;

        protected orientation;

        with inherited trait = {
            initWithOrientation: _orientation => (
                $(super) init.
                orientation <- _orientation.
              ^ self
            );

            initHorizontal => initWithOrientation: morphic Horizontal;
            initVertical   => initWithOrientation: morphic Vertical;

            updateMinSizeCaches => (
                | w <- 0, h <- (orientation ifHorizontal: [ baseMinWidth ] ifVertical: [ baseMinHeight ]) |
                childrenDo: [ :m |
                    w <- w + (m minExtentForOrientation: orientation).
                    h <- h max: (m minExtentForOrientation: orientation opposite).
                ].
                w <- w max: (orientation ifHorizontal: [ baseMinWidth  ] ifVertical: [ baseMinHeight ]).
                h <- h max: (orientation ifHorizontal: [ baseMinHeight ] ifVertical: [ baseMinWidth  ]).
                orientation
                  ~ ifHorizontal: [ cachedMinWidth: w. cachedMinHeight: h. ]
                      ifVertical: [ cachedMinWidth: h. cachedMinHeight: w. ].
            );

            layoutInPlace => (
                shrinkToFit.

                |
                    lower  <- 0,
                    higher <- bounds dimensionForOrientation: orientation,
                    diff   <- higher - lower,

                    flexCount <- 0,
                    reservedF <- 0,
                    reservedN <- 0,
                    budget    <- 0
                |

                childrenDo: [ :c |
                    (c layoutForOrientation: orientation) isFlexible
                      ~   if: [ flexCount <- flexCount + 1.
                                reservedF <- reservedF + (c minExtentForOrientation: orientation) ]
                        else: [ reservedN <- reservedN + (c minExtentForOrientation: orientation) ].
                ].

                budget <- (bounds dimensionForOrientation: orientation) max: (reservedF + reservedN).

                |
                    offset <- 0
                |

                childrenDo: [ :c |
                    |
                        minSpace <- c minExtentForOrientation: orientation,
                        spaceForM
                    |
                    (c layoutForOrientation: orientation) isFlexible if: [
                        | available <- (budget - reservedN) - (reservedF - minSpace) |
                        spaceForM <- (budget - reservedN) / flexCount.
                        (spaceForM > available) -> [ spaceForM <- available ].
                        (spaceForM < minSpace)  -> [ spaceForM <- minSpace  ].
                        flexCount <- flexCount - 1.
                        reservedF <- reservedF - minSpace.
                    ] else: [
                        spaceForM <- minSpace.
                        reservedN <- reservedN - spaceForM.
                    ].

                    |
                        heightForM
                    |
                    
                    (c layoutForOrientation: orientation opposite) isFlexible if: [
                        heightForM <- extentForOrientation: orientation opposite
                    ] else: [
                        heightForM <- c minHeight
                    ].

                    orientation
                      ~ ifHorizontal: [ c boundsX: offset Y: 0 W: spaceForM H: heightForM ]
                          ifVertical: [ c boundsX: 0 Y: offset W: heightForM H: spaceForM ].
                    
                    offset <- offset + spaceForM.
                    budget <- budget - spaceForM.
                ].

                childrenDo: [ :c | c layoutInPlaceIfNeeded ].
                layoutIsNowOkay.
            );
        };
    };

    own HBoxMorph = {
        static with inherited _ = std Clonable;
        with inherited own super = $ BoxMorph;

        with inherited trait = {
            init => (
                $(super) initHorizontal.
              ^ self
            );

            writeOn: w => w << 'an hbox morph';
        };
    };

    own VBoxMorph = {
        static with inherited _ = std Clonable;
        with inherited own super = $ BoxMorph;

        with inherited trait = {
            init => (
                $(super) initVertical.
              ^ self
            );

            writeOn: w => w << 'a vbox morph';
        };
    };

    own DemoMorph = {
        static with inherited _ = std Clonable;
        with inherited own Morph = $ Morph;

        protected r,
        protected g,
        protected b;

        with inherited trait = {
            init => (
                $(Morph) init.
                r: 0 g: 200 b: 0.
              ^ self
            );

            r: _r g: _g b: _b => (
                r <- _r.
                g <- _g.
                b <- _b.
              ^ self
            );

            renderOn: renderer => (
                renderer setR: r G: g B: b.
                renderer fillRectX: 0 Y: 0 W: bounds w H: bounds h.
                renderChildrenOn: renderer.
            );

            writeOn: w => w << 'a demo morph';
        };
    };

    own HandMorph = {
        static with inherited _ = std Clonable;
        with inherited own Morph = $ Morph;

        protected grabbedMorph;

        with inherited trait = {
            init => (
                $(Morph) init.
                rigidWidth: 1.
                rigidHeight: 1.
                grabbedMorph <- No.
              ^ self
            );

            grab: morph => (
                | p <- morph globalOffset - globalOffset |
                add: morph.
                morph moveToX: p x Y: p y. "TODO: Keep offset"
                grabbedMorph <- Yes: morph.
              ^ self
            );

            grab => (
                world yes: [ :w |
                    | p <- globalOffset, morph <- No |
                    w xRayAtX: p x Y: p y Do: [ :m |
                        (self == m) unless: [
                            morph <- Yes: m
                        ]
                    ].
                    morph
                      ~ yes: [ :m | (m != w) -> [ grab: m ] ]
                ].
            );

            release => (
                grabbedMorph
                  ~ yes: [ :gm |
                        parent yes: [ :p |
                            (p dropMorph: gm AtX: (bounds x + gm bounds x) Y: (bounds y + gm bounds y))
                              ~ if: [ grabbedMorph <- No ]
                        ]
                    ]
            );

            grabOrRelease => (
                grabbedMorph
                  ~ yes: [ release ]
                     no: [ grab    ]
            );

            renderOn: renderer => (
                renderer setR: 200 G: 0 B: 0.
                renderer fillRectX: 0 Y: 0 W: 1 H: 1.
                renderChildrenOn: renderer.
            );

            writeOn: w => w << 'a hand morph';
        };
    };

    own WorldMorph = {
        static with inherited _ = std Clonable;
        with inherited own Morph = $ Morph;
        protected morphic = $;

        protected isDirty,
        handMorph;

        with inherited trait = {
            init => (
                $(Morph) init.
                isDirty   <- true.
                handMorph <- (morphic HandMorph new).
                add: handMorph.
              ^ self
            );

            dirty => isDirty <- true;

            maybeUpdate => (
                isDirty -> [
                    isDirty <- false.
                    allChildrenDo: [ :c | c layoutChanged ].
                    layoutChanged.
                    layoutInPlaceIfNeeded
                ]
            );

            renderOn: renderer => (
                renderer setR: 200 G: 200 B: 200.
                renderer fillRectX: 0 Y: 0 W: bounds w H: bounds h.
                renderChildrenOn: renderer.
            );

            handleDropMorph: morph AtX: x Y: y => (
                add: morph.
                morph moveToX: x Y: y.
              ^ true
            );

            writeOn: w => w << 'a world morph';
        };
    };
}
