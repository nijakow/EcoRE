{
    static with inherited _ = std Module;

    own Renderer = {
        static with inherited _ = std Clonable;
        private module = $;

        protected boundsstack,
        protected sdlRenderer;

        with inherited trait = {
            initWithSDLRenderer: _sdl_renderer X: _x Y: _y W: _w H: _h => (
                sdlRenderer <- _sdl_renderer.
                boundsstack <- std util newStack.
                pushBounds: ((module Rectangle) newX: _x Y: _y W: _w H: _h).
              ^ self
            );

            bounds => boundsstack top;
            pushBounds: b => boundsstack push: b;
            popBounds => boundsstack pop;

            xOff => bounds x;
            yOff => bounds y;

            clear => sdlRenderer clear;
            present => sdlRenderer present;

            setR: r G: g B: b => sdlRenderer setR: r G: g B: b;
            setColor: color => sdlRenderer setColor: color;

            drawPointX: x Y: y => sdlRenderer drawPointX: xOff + x Y: yOff + y;
            drawLineX: x1 Y: y1 X: x2 Y: y2 => sdlRenderer drawLineX: xOff + x1 Y: yOff + y1 X: xOff + x2 Y: yOff + y2;
            drawRectX: x Y: y W: w H: h => sdlRenderer drawRectX: xOff + x Y: yOff + y W: w H: h;
            drawRect: rect => drawRectX: rect x Y: rect y W: rect w H: rect h;
            fillRectX: x Y: y W: w H: h => sdlRenderer fillRectX: xOff + x Y: yOff + y W: w H: h;
            fillRect: rect => fillRectX: rect x Y: rect y W: rect w H: rect h;

            accept: morph => morph renderOn: self;

            writeOn: w => w << 'a morphic renderer';
        };
    };

    own Rectangle = {
        static with inherited _ = std Clonable;

        x, y, w, h;

        with inherited trait = {
            init => (
                x: 0 y: 0 w: 1 h: 1.
              ^ self
            );

            newX: xv Y: yv W: wv H: hv => (
              ^ (self new)
                    x: xv
                    y: yv
                    w: wv
                    h: hv
            );

            offsetToX: x Y: y => newX: x Y: y W: w H: h;
            offsetByX: xoff Y: yoff => newX: x + xoff Y: y + yoff W: w H: h;
            resizeToW: w H: h => newX: x Y: y W: w H: h;

            x: xv => x <- xv;
            y: yv => y <- yv;
            w: wv => w <- wv;
            h: hv => h <- hv;

            x: xv y: yv w: wv h: hv => (
                x: xv.
                y: yv.
                w: wv.
                h: hv.
              ^ self
            );

            containsX: px Y: py => (
                (px < x) -> [ ^ false ].
                (py < y) -> [ ^ false ].
                (px >= (x + w)) -> [ ^ false ].
                (py >= (y + h)) -> [ ^ false ].
              ^ true
            );

            dimensionForOrientation: orientation => (
                orientation
                  ~ isHorizontal: [ ^ w ]
                      isVertical: [ ^ h ]
            );

            writeOn: writer => writer << 'a rectangle(' << x << ', ' << y << ', ' << w << ', ' << h << ')';
        };
    };

    own Point2D = {
        static with inherited _ = std Clonable;
        private module = $;

        private x;
        private y;

        with inherited trait = {
            NewX: _x Y: _y => self clone initWithX: _x Y: _y;

            initWithX: _x Y: _y => (
                x <- _x.
                y <- _y.
              ^ self
            );

            x: xv => x <- xv;
            y: yv => y <- yv;

            x: xv y: yv => x: xv ~ y: yv;

            offsetBy: p => module Point2D NewX: (x + p) Y: (y + p);
            offsetBy: p Do: block => block value(offsetBy: p);

            writeOn: w => w << 'a point(' << x << ', ' << y << ')';
        };
    };

    own FlexibleSize = {
        static with inherited _ = std Singleton;

        with inherited trait = {
            isFlexible: flexible isRigid: rigid isShrinkWrap: sw => flexible value;
            isFlexible: flexible isRigid: rigid => flexible value;

            cut: dimension => dimension;
        };
    };

    own RigidSize50 = {
        static with inherited _ = std Singleton;

        with inherited trait = {
            isFlexible: flexible isRigid: rigid isShrinkWrap: sw => rigid value(50);
            isFlexible: flexible isRigid: rigid => rigid value(50);

            cut: dimension => dimension min: 50;
        };
    };

    own Morph = {
        static with inherited _ = std Clonable;
        private module = $;

        with inherited trait = {
            init => (
              ^ self
            );

            renderOn: renderer => (
                renderer setR: 0 G: 255 B: 0.
                renderer fillRectX: 0 Y: 0 W: renderer bounds w H: renderer bounds h.
            );

            childrenDo: block => self;
            childrenWithBoundsDo: block ContextBounds: bounds => self;

            xResizeBehavior => module FlexibleSize;
            yResizeBehavior => module FlexibleSize;
            sizePropertiesForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ xResizeBehavior ]
                      ifVertical: [ yResizeBehavior ]
            );

            sizePropertiesForOrientation: orientation Bounds: bounds => (
              ^ sizePropertiesForOrientation: orientation
            );

            processEvent: event AtX: evtX Y: evtY Bounds: bounds => self;

            issueEvent: event AtX: evtX Y: evtY Bounds: cbounds => (
                std io out << 'Received ' << evtX << ' ' << evtY << ' in ' << self ~ newline.
                childrenWithBoundsDo: [ :child, :bounds |
                    bounds containsX: evtX Y: evtY
                      ~ if: [ child issueEvent: event AtX: (evtX - bounds x) Y: (evtY - bounds y) Bounds: (bounds offsetToX: 0 Y: 0) ]
                ] ContextBounds: cbounds.
                processEvent: event AtX: evtX Y: evtY Bounds: cbounds.
            );

            writeOn: w => w << 'a morph';
        };
    };

    own Vertical = {
        static with inherited _ = std Singleton;
        private module = $;

        isHorizontal => false;
        isVertical   => true;

        ifHorizontal: block => self;
        ifVertical:   block => block value;
        ifHorizontal: horiz
          ifVertical: verti => verti value;
        
        opposite => module Horizontal;
    },

    own Horizontal = {
        static with inherited _ = std Singleton;
        private module = $;

        isHorizontal => true;
        isVertical   => false;

        ifHorizontal: block => block value;
        ifVertical:   block => self;
        ifHorizontal: horiz
          ifVertical: verti => horiz value;
        
        opposite => module Vertical;
    },

    own Box = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Morph;
        private module = $;

        protected orientation,
        protected children;

        initWithOrientation: _orientation => (
            my super init.
            orientation <- _orientation.
            children    <- std util newVector.
            ^ self
        );

        childrenDo: block => (
            my super childrenDo: block.
            children do: block.
            ^ self
        );

        with inherited trait = {
            initHorizontal => initWithOrientation: module Horizontal;
            initVertical   => initWithOrientation: module Vertical;

            addChild: child => children add: child;

            childrenWithBoundsDo: block ContextBounds: bounds => (
                | lower, higher, diff |
                orientation
                  ~ ifHorizontal: [ lower <- bounds x. diff <- bounds w ]
                      ifVertical: [ lower <- bounds y. diff <- bounds h ].
                higher <- lower + diff.
                | fixed <- 0, flexCount <- 0 |
                childrenDo: [ :c |
                    c sizePropertiesForOrientation: orientation Bounds: bounds
                      ~ isFlexible: [      flexCount <- flexCount + 1 ]
                           isRigid: [ :s | fixed     <- fixed     + s ]
                ].
                |
                    gap  <- (flexCount isZero) if: [ 1 ] else: [ (diff - fixed) / flexCount ],
                    xPos <- 0
                |
                childrenDo: [ :c |
                    | xPosOld <- xPos |
                    c sizePropertiesForOrientation: orientation Bounds: bounds
                      ~ isFlexible: [      xPos <- xPos + gap ]
                           isRigid: [ :s | xPos <- xPos + s   ].
                    | yMax |
                    c sizePropertiesForOrientation: orientation opposite Bounds: bounds
                      ~ isFlexible: [      yMax <- orientation ifHorizontal: [ bounds h ] ifVertical: [ bounds w ] ]
                           isRigid: [ :s | yMax <- s        ].
                    | r |
                    orientation
                      ~ ifHorizontal: [ r <- module Rectangle newX: lower + xPosOld Y: bounds y W: xPos - xPosOld H: yMax ]
                          ifVertical: [ r <- module Rectangle newX: bounds x Y: lower + xPosOld W: yMax H: xPos - xPosOld ].
                    block value(c, r).
                ].
            );

            renderOn: renderer => (
                childrenWithBoundsDo: [ :c, :b |
                    renderer pushBounds: b.
                    renderer accept: c.
                    renderer popBounds.
                ] ContextBounds: renderer bounds
            );

            writeOn: w => w << 'a box morph';
        };
    };

    own HBox = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Box;
        private module = $;

        with inherited trait = {
            init => initHorizontal;

            writeOn: w => w << 'an hbox morph';
        };
    };

    own VBox = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Box;
        private module = $;

        with inherited trait = {
            init => initVertical;

            writeOn: w => w << 'a vbox morph';
        };
    };

    own Frame = {
        static with inherited _ = std Clonable;
        with inherited own super = $ Morph;
        private module = $;

        xResizeBehavior, yResizeBehavior, child;

        with inherited trait = {
            init => (
                super init.
                xResizeBehavior: module RigidSize50.
                yResizeBehavior: module RigidSize50.
                child <- No.
              ^ self
            );

            xResizeBehavior: rb => xResizeBehavior <- rb;
            yResizeBehavior: rb => yResizeBehavior <- rb;

            child: cv => child <- Yes: cv;

            childrenDo: block => (
                super childrenDo: block.
                child yes: [ :c | block value(c) ].
            );

            childrenWithBoundsDo: block ContextBounds: bounds => (
                |
                    newBounds <- bounds resizeToW: (sizePropertiesForOrientation: module Horizontal Bounds: bounds ~ cut: bounds w)
                                                H: (sizePropertiesForOrientation: module Vertical   Bounds: bounds ~ cut: bounds h)
                |
                super childrenWithBoundsDo: block ContextBounds: newBounds.
                child yes: [ :c | block value(c, newBounds) ].
            );

            renderOn: renderer => (
                childrenWithBoundsDo: [ :c, :b |
                    renderer pushBounds: b.
                    renderer accept: c.
                    renderer popBounds.
                ] ContextBounds: renderer bounds
            );

            writeOn: w => w << 'a frame morph';
        };
    };
}
