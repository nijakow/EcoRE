{
    static with inherited _ = std Module;

    own Renderer = {
        static with inherited _ = std Clonable;
        private module = $;

        protected boundsstack,
        protected sdlRenderer;

        with inherited trait = {
            initWithSDLRenderer: _sdl_renderer X: _x Y: _y W: _w H: _h => (
                sdlRenderer <- _sdl_renderer.
                boundsstack <- std util newStack.
                pushBounds: ((module Rectangle) newX: _x Y: _y W: _w H: _h).
              ^ self
            );

            bounds => boundsstack top;
            pushBounds: b => boundsstack push: b;
            popBounds => boundsstack pop;

            xOff => bounds x;
            yOff => bounds y;

            clear => sdlRenderer clear;
            present => sdlRenderer present;

            setR: r G: g B: b => sdlRenderer setR: r G: g B: b;
            setColor: color => sdlRenderer setColor: color;

            drawPointX: x Y: y => sdlRenderer drawPointX: xOff + x Y: yOff + y;
            drawLineX: x1 Y: y1 X: x2 Y: y2 => sdlRenderer drawLineX: xOff + x1 Y: yOff + y1 X: xOff + x2 Y: yOff + y2;
            drawRectX: x Y: y W: w H: h => sdlRenderer drawRectX: xOff + x Y: yOff + y W: w H: h;
            drawRect: rect => drawRectX: rect x Y: rect y W: rect w H: rect h;
            fillRectX: x Y: y W: w H: h => sdlRenderer fillRectX: xOff + x Y: yOff + y W: w H: h;
            fillRect: rect => fillRectX: rect x Y: rect y W: rect w H: rect h;

            accept: morph => morph renderOn: self;

            writeOn: w => w << 'a morphic renderer';
        };
    };

    own Rectangle = {
        static with inherited _ = std Clonable;

        x, y, w, h;

        with inherited trait = {
            init => (
                x: 0 y: 0 w: 1 h: 1.
              ^ self
            );

            newX: xv Y: yv W: wv H: hv => (
              ^ (self new)
                    x: xv
                    y: yv
                    w: wv
                    h: hv
            );

            offsetByX: xoff Y: yoff => newX: x + xoff Y: y + yoff W: w H: h;

            x: xv => x <- xv;
            y: yv => y <- yv;
            w: wv => w <- wv;
            h: hv => h <- hv;

            x: xv y: yv w: wv h: hv => (
                x: xv.
                y: yv.
                w: wv.
                h: hv.
              ^ self
            );

            writeOn: writer => writer << 'a rectangle(' << x << ', ' << y << ', ' << w << ', ' << h << ')';
        };
    };

    own Point2D = {
        static with inherited _ = std Clonable;
        private module = $;

        private x;
        private y;

        with inherited trait = {
            NewX: _x Y: _y => self clone initWithX: _x Y: _y;

            initWithX: _x Y: _y => (
                x <- _x.
                y <- _y.
              ^ self
            );

            x: xv => x <- xv;
            y: yv => y <- yv;

            x: xv y: yv => x: xv ~ y: yv;

            offsetBy: p => module Point2D NewX: (x + p) Y: (y + p);
            offsetBy: p Do: block => block value(offsetBy: p);

            writeOn: w => w << 'a point(' << x << ', ' << y << ')';
        };
    };

    own FlexibleSize = {
        static with inherited _ = std Singleton;

        with inherited trait = {
            isFlexible: flexible isRigid: rigid => flexible value;
        };
    };

    own Morph = {
        static with inherited _ = std Clonable;
        private module = $;

        with inherited trait = {
            init => (
              ^ self
            );

            renderOn: renderer => (
                renderer setR: 0 G: 255 B: 0.
                renderer fillRectX: 0 Y: 0 W: renderer bounds w H: renderer bounds h.
            );

            childrenDo: block => self;

            xResizeBehavior => module FlexibleSize;
            yResizeBehavior => module FlexibleSize;

            writeOn: w => w << 'a morph';
        };
    };

    own Constraints = {

    };

    own NoConstraints = {
        static with inherited _ = std Singleton;
    };

    own ConstraintsMorph = {
        static with inherited _ = std Clonable;
        with own super = $ Morph;
        private module = $;

        constraints;

        private child;

        with inherited trait = {
            init => (
                super init.
                "TODO: Come up with constraints"
                constraints <- module NoConstraints;
                child <- No.
              ^ self
            );

            child: v => child <- Yes: v; "TODO: This should be `own`, but `own`ing No clones a singleton!"

            childrenDo: block => (
                super childrenDo: block.
                child yes: [ :c | block value(c) ].
              ^ self
            );

            renderOn: renderer => (
                renderer pushConstraints: constraints.
                childrenDo: [ :c | renderer accept: c ].
                renderer popConstraints.
            );

            writeOn: w => w << 'a constraints morph';
        };
    };

    own HBox = {
        static with inherited _ = std Clonable;
        with own super = $ Morph;
        private module = $;

        private children;

        with inherited trait = {
            init => (
                super init.
                children <- std util newVector.
              ^ self
            );

            childrenDo: block => (
                super childrenDo: block.
                children do: block.
              ^ self
            );

            addChild: child => children add: child;

            childrenWithBoundsDo: block ContextBounds: bounds => (
                | fixed <- 0, flexCount <- 0 |
                childrenDo: [ :c |
                    c xResizeBehavior
                      ~ isFlexible: [      flexCount <- flexCount + 1 ]
                           isRigid: [ :s | fixed     <- fixed     + s ]
                ].
                |
                    gap  <- (bounds w - fixed) / flexCount,
                    xPos <- 0
                |
                childrenDo: [ :c |
                    | xPosOld <- xPos |
                    c xResizeBehavior
                      ~ isFlexible: [      xPos <- xPos + gap ]
                           isRigid: [ :s | xPos <- xPos + s   ].
                    block value(c, module Rectangle newX: bounds x + xPosOld Y: bounds y W: xPos - xPosOld H: bounds h).
                ].
            );

            renderOn: renderer => (
                childrenWithBoundsDo: [ :c, :b |
                    (std io out << b) newline.
                    renderer pushBounds: b.
                    renderer accept: c.
                    renderer popBounds.
                ] ContextBounds: renderer bounds
            );

            writeOn: w => w << 'an hbox morph';
        };
    };
}
