{
    static with inherited _ = std Module;

    own Renderer = {
        static with inherited _ = std Clonable;
        private module = $;

        bounds,
        protected sdlRenderer;

        with inherited trait = {
            initWithSDLRenderer: _sdl_renderer X: _x Y: _y W: _w H: _h => (
                sdlRenderer <- _sdl_renderer.
                bounds <- (module Rectangle) newX: _x Y: _y W: _w H: _h.
              ^ self
            );

            xOff => bounds x;
            yOff => bounds y;

            clear => sdlRenderer clear;
            present => sdlRenderer present;

            setR: r G: g B: b => sdlRenderer setR: r G: g B: b;
            setColor: color => sdlRenderer setColor: color;

            drawPointX: x Y: y => sdlRenderer drawPointX: xOff + x Y: yOff + y;
            drawLineX: x1 Y: y1 X: x2 Y: y2 => sdlRenderer drawLineX: xOff + x1 Y: yOff + y1 X: xOff + x2 Y: yOff + y2;
            drawRectX: x Y: y W: w H: h => sdlRenderer drawRectX: xOff + x Y: yOff + y W: w H: h;
            fillRectX: x Y: y W: w H: h => sdlRenderer fillRectX: xOff + x Y: yOff + y W: w H: h;

            writeOn: w => w << 'a morphic renderer';
        };
    };

    own Rectangle = {
        static with inherited _ = std Clonable;

        x, y, w, h;

        with inherited trait = {
            init => (
                x: 0 y: 0 w: 1 h: 1.
              ^ self
            );

            newX: xv Y: yv W: wv H: hv => (
              ^ (self new)
                    x: xv
                    y: yv
                    w: wv
                    h: hv
            );

            x: xv => x <- xv;
            y: yv => y <- yv;
            w: wv => w <- wv;
            h: hv => h <- hv;

            x: xv y: yv w: wv h: hv => (
                x: xv.
                y: yv.
                w: wv.
                h: hv.
              ^ self
            );

            writeOn: w => w << 'a rectangle';
        };
    };

    own Point2D = {
        static with inherited _ = std Clonable;
        private module = $;

        private x;
        private y;

        with inherited trait = {
            NewX: _x Y: _y => self clone initWithX: _x Y: _y;

            initWithX: _x Y: _y => (
                x <- _x.
                y <- _y.
              ^ self
            );

            x: xv => x <- xv;
            y: yv => y <- yv;

            x: xv y: yv => x: xv ~ y: yv;

            offsetBy: p => module Point2D NewX: (x + p) Y: (y + p);
            offsetBy: p Do: block => block value(offsetBy: p);

            writeOn: w => w << 'a point(' << x << ', ' << y << ')';
        };
    };

    own Morph = {
        static with inherited _ = std Clonable;
        private module = $;

        bounds;

        with inherited trait = {
            init => (
                bounds <- (module Rectangle) clone x: 0 y: 0 w: 50 h: 50.
              ^ self
            );

            renderOn: renderer => (
                renderer setR: 0 G: 255 B: 0.
                renderer fillRectX: bounds x Y: bounds y W: bounds w H: bounds h.
            );

            beforeRendering: renderer => self;
            afterRendering: renderer => self;

            childrenDo: block => self;

            writeOn: w => w << 'a morph';
        };
    };

    own Constraints = {

    };

    own NoConstraints = {
        static with inherited _ = std Singleton;
    };

    own ConstraintsMorph = {
        static with inherited _ = std Clonable;
        with own super = $ Morph;
        private module = $;

        constraints;

        private child;

        with inherited trait = {
            init => (
                super init.
                "TODO: Come up with constraints"
                constraints = module NoConstraints;
                child <- No.
              ^ self
            );

            child: v => child <- Yes: v; "TODO: This should be `own`, but `own`ing No clones a singleton!"

            childrenDo: block => (
                super childrenDo: block.
                child yes: [ :c | block value(c) ].
              ^ self
            );

            renderOn: renderer => self;

            beforeRendering: renderer => renderer pushConstraints: constraints;
            afterRendering: renderer => renderer popConstraints;

            writeOn: w => w << 'a constraints morph';
        };

    };
}
