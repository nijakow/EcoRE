
    {
        static with inherited _ = std Clonable;
        protected morphic = $ morphic;

        bounds,
        xLayout, yLayout;
        parent, children;

        protected layoutOkay,
        protected cachedMinWidth,
        protected cachedMinHeight;

        with inherited trait = {
            init => (
                bounds   <- (morphic Rectangle) new.
                xLayout  <- (morphic layouts Flexible).
                yLayout  <- (morphic layouts Flexible).
                parent   <- No.
                children <- std util newVector.
                layoutOkay      <- false.
                cachedMinWidth  <- No.
                cachedMinHeight <- No.
              ^ self
            );

            globalBounds => (
                parent
                  ~ yes: [ :p | | pgb <- p globalBounds | ^ bounds offsetByX: pgb x Y: pgb y ]
                     no: [ ^ bounds                                                          ]
            );

            boundsX: x Y: y W: w H: h => (
                bounds x: x y: y w: w h: h.
              ^ self
            );
            bounds: rect => boundsX: rect x Y: rect y W: rect w H: rect h;

            moveToX: x Y: y   => boundsX: x Y: y W: bounds w H: bounds h;
            resizeToW: w H: h => boundsX: bounds x Y: bounds y W: w H: h;

            offset => (morphic Point2D clone) initWithX: bounds x Y: bounds y;
            globalOffset => (
                | b <- globalBounds |
              ^ (morphic Point2D clone) initWithX: b x Y: b y
            );

            width  => bounds w;
            height => bounds h;

            baseMinWidth  => 0;
            baseMinHeight => 0;

            resizeToW: w => resizeToW: w H: height;
            resizeToH: h => resizeToW: width H: h;

            extentForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ width  ]
                      ifVertical: [ height ]
            );

            layoutOkay: v   => layoutOkay <- v;
            layoutIsNowOkay => layoutOkay: true;

            cachedMinWidth:  v => cachedMinWidth  <- Yes: v;
            cachedMinHeight: v => cachedMinHeight <- Yes: v;
            invalidateMinSizeCaches => (
                cachedMinWidth  <- No.
                cachedMinHeight <- No.
            );
            updateMinSizeCaches => (
                "TODO: Go through all the submorphs"
                cachedMinWidth:  baseMinWidth.
                cachedMinHeight: baseMinHeight.
            );

            minWidth => (
                xLayout isRigid -> [ ^ width ].
                cachedMinWidth no: [ updateMinSizeCaches ].
              ^ cachedMinWidth yes
            );
            minHeight => (
                yLayout isRigid -> [ ^ height ].
                cachedMinHeight no: [ updateMinSizeCaches ].
              ^ cachedMinHeight yes
            );

            minExtentForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ minWidth  ]
                      ifVertical: [ minHeight ]
            );

            invalidateLayoutCaches => (
                layoutOkay: false.
                invalidateMinSizeCaches.
              ^ self
            );

            layoutChanged => (
                invalidateLayoutCaches.
                world yes: [ :w | w dirty ].
              ^ self
            );

            xLayout: layout => xLayout <- layout;
            yLayout: layout => yLayout <- layout;

            rigidWidth:  w => xLayout: morphic layouts Rigid ~ resizeToW: w;
            rigidHeight: h => yLayout: morphic layouts Rigid ~ resizeToH: h;

            flexibleWidth  => xLayout: morphic layouts Flexible;
            flexibleHeight => yLayout: morphic layouts Flexible;
            flexibleSize   => ( flexibleWidth. flexibleHeight. );

            shrinkWrapWidth  => xLayout: morphic layouts ShrinkWrap;
            shrinkWrapHeight => yLayout: morphic layouts ShrinkWrap;
            shrinkWrapSize   => ( shrinkWrapWidth. shrinkWrapHeight. );

            layoutForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ xLayout ]
                      ifVertical: [ yLayout ]
            );

            root => (
                parent yes: [ :p | p root ]
                        no: [      self   ]
            );

            world => (
                parent yes: [ :p | p world ]
                        no: [      No      ]
            );

            childrenDo: block => children do: block;
            childrenReverseDo: block => 0 for: children size do: [ :i | block value(children at: (children size - i - 1)) ];
            allChildrenDo: block => childrenDo: [ :c | block value(c). c allChildrenDo: block ];
            childrenWithBoundsDo: block => childrenDo: [ :c | block value(c, c bounds) ];

            unlink => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );

            noParent  => parent <- No.
            parent: p => parent <- Yes: p;

            isIn: morph => (
                (self == morph) -> [ ^ true ].
                parent yes: [ :p | ^ p isIn: morph ]
                        no: [      ^ false         ]
            );

            tryAdd: child => (
                ((self isIn: child) not) -> [
                    child unlink.
                    children add: child.
                    child parent: self.
                    child invalidateLayoutCaches.
                    layoutChanged.
                  ^ true
                ].
              ^ false
            );

            add: child => ( tryAdd: child. ^ self );

            remove: child => (
                children remove: child
                  ~ yes: [ child noParent. layoutChanged ].
              ^ self
            );

            remove => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );

            layoutInPlace => childrenDo: [ :c | c layoutInPlace ];
            layoutInPlaceIfNeeded => layoutOkay false: [ layoutInPlace ];
            shrinkToFit => (
                "Only shrink if there is a parent"
                parent yes: [
                    xLayout isShrinkWrap -> [ resizeToW: minWidth  ].
                    yLayout isShrinkWrap -> [ resizeToH: minHeight ].
                ]
            );

            renderChildrenOn: renderer => (
                childrenDo: [ :c |
                    renderer pushBounds: c bounds.
                    renderer accept: c.
                    renderer popBounds.
                ].
            );
            renderOn: renderer => renderChildrenOn: renderer;

            dispatchEvent: block AtX: evtX Y: evtY => (
                childrenReverseDo: [ :c |
                    | b <- c bounds |
                    b containsX: evtX Y: evtY
                      ~ if: [ (c dispatchEvent: block AtX: (evtX - b x) Y: (evtY - b y)) -> [ ^ true ] ]
                ].
                block value(self, evtX, evtY) -> [ ^ true ].
              ^ false
            );

            xRayAtX: x Y: y Do: block => (
                block value(self).
                childrenWithBoundsDo: [ :c, :b |
                    b containsX: x Y: y
                      ~ if: [ c xRayAtX: (x - b x) Y: (y - b y) Do: block ]
                ].
              ^ self
            );

            handleDropMorph: morph AtX: x Y: y => false;
            handleClickAtX: x Y: y HandMorph: hand => false;

            dropMorph: morph AtX: x Y: y => dispatchEvent: [ :e, :ex, :ey | e handleDropMorph: morph AtX: ex Y: ey ] AtX: x Y: y;
            clickAtX: x Y: y HandMorph: hand => dispatchEvent: [ :e, :ex, :ey | e handleClickAtX: ex Y: ey HandMorph: hand ] AtX: x Y: y;

            writeOn: w => w << 'a morph';
        };
    }
