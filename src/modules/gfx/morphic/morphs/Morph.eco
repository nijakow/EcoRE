
    {
        static with inherited _ = std Clonable;
        protected morphic = $ morphic;

        offset, dimensions,
        xLayout, yLayout, layouter,
        parent, children;

        with inherited trait = {
            static with inherited _ = std Trait;

            initWithChildConfig: config => (
                offset          <- (morphic X: 0 Y: 0).
                dimensions      <- (morphic W: 0 H: 0).
                xLayout         <- (morphic layouts Flexible).
                yLayout         <- (morphic layouts Flexible).
                layouter        <- (morphic layouters Default).
                parent          <- No.
                children        <- config new.
              ^ self
            );

            initWithNoChildren   => initWithChildConfig: (morphic children None);
            initWithOneChild     => initWithChildConfig: (morphic children One);
            initWithManyChildren => initWithChildConfig: (morphic children Many);

            init => initWithNoChildren;

            "
                Children
            "
            childrenDo: block => children childrenDo: block;
            childrenReverseDo: block => children childrenReverseDo: block;
            allChildrenDo: block => childrenDo: [ :c | block value(c). c allChildrenDo: block ];
            childrenWithBoundsDo: block => childrenDo: [ :c | block value(c, c bounds) ];

            allParentsDo: block => (
                parent yes: [ :p | block value(p). p allParentsDo: block ]
                        no: [      ^ self                                ]
            );

            root => (
                parent yes: [ :p | p root ]
                        no: [      self   ]
            );

            world => (
                parent yes: [ :p | p world ]
                        no: [      No      ]
            );

            unlink => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );

            noParent  => parent <- No.
            parent: p => parent <- Yes: p;

            isIn: morph => (
                (self == morph) -> [ ^ true ].
                parent yes: [ :p | ^ p isIn: morph ]
                        no: [      ^ false         ]
            );

            tryAdd: child => (
                ((self isIn: child) not) -> [
                    (children add: child) unless: [ ^ false ].
                    child unlink.
                    child parent: self.
                  ^ true
                ].
              ^ false
            );

            add: child => (
                (tryAdd: child)
                    unless: [ 'Morph can not be added!' throw ].
              ^ self
            );

            remove: child => (
                (children remove: child)
                  ~ if: [ child noParent. ].
              ^ self
            );

            remove => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );


            "
                Position and Size
            "
            offsetForOrientation: orientation => (
                offset dimensionForOrientation: orientation
            );

            width  => dimensions x;
            height => dimensions y;

            extentForOrientation: orientation => (
                dimensions dimensionForOrientation: orientation
            );

            move: point => (
                offset <- point.
              ^ self
            );

            resize: point => (
                dimensions <- point.
              ^ self
            );

            move: _offset resize: _dimensions => move: _offset ~ resize: _dimensions;


            "
                Layouts
            "
            xLayout: layout => xLayout <- layout;
            yLayout: layout => yLayout <- layout;

            rigidWidth:  w => xLayout: morphic layouts Rigid ~ resizeToW: w;
            rigidHeight: h => yLayout: morphic layouts Rigid ~ resizeToH: h;

            flexibleWidth  => xLayout: morphic layouts Flexible;
            flexibleHeight => yLayout: morphic layouts Flexible;
            flexibleSize   => ( flexibleWidth. flexibleHeight. );

            shrinkWrapWidth  => xLayout: morphic layouts ShrinkWrap;
            shrinkWrapHeight => yLayout: morphic layouts ShrinkWrap;
            shrinkWrapSize   => ( shrinkWrapWidth. shrinkWrapHeight. );

            layoutForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ xLayout ]
                      ifVertical: [ yLayout ]
            );


            "
                Layouting
            "
            baseMinSizeForOrientation: orientation => (
              layoutForOrientation: orientation
                  ~ ifShrinkWrap: [           ^ 0 "Take children into account?" ]
                    ifFlexible:   [           ^ 0                               ]
                    ifRigid:      [ :extent | ^ extent                          ]
            );

            minSizeForOrientation: orientation => (
                layouter calculateMinSizeForMorph: self Orientation: orientation
            );

            minSize => morphic X: (minSizeForOrientation: morphic orientations Horizontal)
                               Y: (minSizeForOrientation: morphic orientations Vertical);

            basePreferredSizeForOrientation: orientation => (
                layoutForOrientation: orientation
                  ~ ifShrinkWrap: [           ^ minSizeForOrientation: orientation                         ]
                    ifFlexible:   [           ^ 'Tried to access preferred size of flexible layout!' throw ]
                    ifRigid:      [ :extent | ^ extent                                                     ]
            );

            preferredSizeForOrientation: orientation => (
                layouter calculatePreferredSizeForMorph: self Orientation: orientation
            );

            preferredSize => morphic X: (preferredSizeForOrientation: morphic orientations Horizontal)
                                     Y: (preferredSizeForOrientation: morphic orientations Vertical);

            layoutChildrenWithConstraints: constraints => (
                childrenWithBoundsDo: [ :c :b |
                    c layoutWithConstraintsIfChanged: constraints.
                ].
            );
            layoutWithConstraints: constraints => layouter layoutMorph: self Constraints: constraints;
            layoutWithConstraintsIfChanged: constraints => layoutWithConstraints: constraints;
            layoutInplaceIfChanged => layoutWithConstraintsIfChanged: dimensions;

            "
                Rendering
            "
            renderChildrenOn: renderer => (
                childrenDo: [ :c |
                    renderer pushBounds: c bounds.
                    renderer accept: c.
                    renderer popBounds.
                ].
            );
            renderOn: renderer => (
              isRenderDirty <- false.
              isChildRenderDirty <- false.
              renderChildrenOn: renderer;
            );

            writeOn: w => w << 'a morph';
        };
    }
