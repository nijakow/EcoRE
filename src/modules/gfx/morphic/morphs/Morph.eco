
    {
        static with inherited _ = std Clonable;
        protected morphic = $ morphic;

        bounds,
        xLayout, yLayout;
        parent, children;

        protected layoutOkay,
        protected cachedMinWidth,
        protected cachedMinHeight,
        protected isDirty,
        protected isRenderDirty,
        protected isChildRenderDirty;

        with inherited trait = {
            initWithChildConfig: config => (
                bounds          <- (morphic Rectangle) new.
                xLayout         <- (morphic layouts Flexible).
                yLayout         <- (morphic layouts Flexible).
                parent          <- No.
                children        <- config new.
                layoutOkay      <- false.
                cachedMinWidth  <- No.
                cachedMinHeight <- No.
                isDirty         <- true.
                isRenderDirty   <- true.
                isChildRenderDirty <- true.
              ^ self
            );

            initWithNoChildren   => initWithChildConfig: (morphic children None);
            initWithOneChild     => initWithChildConfig: (morphic children One);
            initWithManyChildren => initWithChildConfig: (morphic children Many);

            init => initWithNoChildren;

            globalBounds => (
                parent
                  ~ yes: [ :p | | pgb <- p globalBounds | ^ bounds offsetByX: pgb x Y: pgb y ]
                     no: [ ^ bounds                                                          ]
            );

            boundsX: x Y: y W: w H: h => (
                bounds x: x y: y w: w h: h.
                renderDirty.
              ^ self
            );
            bounds: rect => boundsX: rect x Y: rect y W: rect w H: rect h;

            moveToX: x Y: y   => boundsX: x Y: y W: bounds w H: bounds h;
            resizeToW: w H: h => boundsX: bounds x Y: bounds y W: w H: h;

            offset => (morphic Point2D clone) initWithX: bounds x Y: bounds y;
            globalOffset => (
                | b <- globalBounds |
              ^ (morphic Point2D clone) initWithX: b x Y: b y
            );

            width  => bounds w;
            height => bounds h;

            baseMinWidth  => 0;
            baseMinHeight => 0;

            resizeToW: w => resizeToW: w H: height;
            resizeToH: h => resizeToW: width H: h;

            extentForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ width  ]
                      ifVertical: [ height ]
            );

            layoutOkay: v   => layoutOkay <- v;
            layoutIsNowOkay => layoutOkay: true;

            cachedMinWidth:  v => cachedMinWidth  <- Yes: v;
            cachedMinHeight: v => cachedMinHeight <- Yes: v;
            invalidateMinSizeCaches => (
                cachedMinWidth  <- No.
                cachedMinHeight <- No.
            );
            updateMinSizeCaches => (
                "TODO: Go through all the submorphs"
                cachedMinWidth:  baseMinWidth.
                cachedMinHeight: baseMinHeight.
            );

            minWidth => (
                xLayout isRigid -> [ ^ width ].
                cachedMinWidth no: [ updateMinSizeCaches ].
              ^ cachedMinWidth yes
            );
            minHeight => (
                yLayout isRigid -> [ ^ height ].
                cachedMinHeight no: [ updateMinSizeCaches ].
              ^ cachedMinHeight yes
            );

            minExtentForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ minWidth  ]
                      ifVertical: [ minHeight ]
            );

            invalidateLayoutCaches => (
                layoutOkay: false.
                invalidateMinSizeCaches.
                dirty.
              ^ self
            );

            layoutChanged => (
                invalidateLayoutCaches.
              ^ self
            );

            xLayout: layout => xLayout <- layout;
            yLayout: layout => yLayout <- layout;

            rigidWidth:  w => xLayout: morphic layouts Rigid ~ resizeToW: w;
            rigidHeight: h => yLayout: morphic layouts Rigid ~ resizeToH: h;

            flexibleWidth  => xLayout: morphic layouts Flexible;
            flexibleHeight => yLayout: morphic layouts Flexible;
            flexibleSize   => ( flexibleWidth. flexibleHeight. );

            shrinkWrapWidth  => xLayout: morphic layouts ShrinkWrap;
            shrinkWrapHeight => yLayout: morphic layouts ShrinkWrap;
            shrinkWrapSize   => ( shrinkWrapWidth. shrinkWrapHeight. );

            layoutForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ xLayout ]
                      ifVertical: [ yLayout ]
            );

            root => (
                parent yes: [ :p | p root ]
                        no: [      self   ]
            );

            world => (
                parent yes: [ :p | p world ]
                        no: [      No      ]
            );

            childrenDo: block => children childrenDo: block;
            childrenReverseDo: block => children childrenReverseDo: block;
            allChildrenDo: block => childrenDo: [ :c | block value(c). c allChildrenDo: block ];
            childrenWithBoundsDo: block => childrenDo: [ :c | block value(c, c bounds) ];

            unlink => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );

            noParent  => parent <- No.
            parent: p => parent <- Yes: p;

            isIn: morph => (
                (self == morph) -> [ ^ true ].
                parent yes: [ :p | ^ p isIn: morph ]
                        no: [      ^ false         ]
            );

            tryAdd: child => (
                ((self isIn: child) not) -> [
                    (children add: child) unless: [ ^ false ].
                    child unlink.
                    child parent: self.
                    child invalidateLayoutCaches.
                    layoutChanged.
                  ^ true
                ].
              ^ false
            );

            add: child => (
                (tryAdd: child)
                    unless: [ 'Morph can not be added!' throw ].
              ^ self
            );

            remove: child => (
                (children remove: child)
                  ~ if: [ child noParent. layoutChanged ].
              ^ self
            );

            remove => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );

            layoutInPlace => ( childrenDo: [ :c | c layoutInPlace ]. layoutIsNowOkay. );
            layoutInPlaceIfNeeded => layoutOkay false: [ layoutInPlace ];
            shrinkToFit => (
                "Only shrink if there is a parent"
                parent yes: [
                    xLayout isShrinkWrap -> [ resizeToW: minWidth  ].
                    yLayout isShrinkWrap -> [ resizeToH: minHeight ].
                ]
            );

            dirty => (
                isDirty not -> [
                    (std io out << 'Dirty: ' << self) newline commit.
                    isDirty <- true.
                    parent yes: [ :p | p dirty ].
                ].
                "renderDirty."
              ^ self
            );

            undirty => (
                isDirty -> [
                    layoutChanged.
                    childrenDo: [ :c | c undirty ].
                    isDirty <- false.
                ].
              ^ self
            );

            renderDirty => (
                isRenderDirty <- true.
                childRenderDirty.
              ^ self
            );

            childRenderDirty => (
                isChildRenderDirty not -> [
                    isChildRenderDirty <- true.
                    parent yes: [ :p | p childRenderDirty ].
                ]
            );

            renderChildrenOn: renderer => (
                childrenDo: [ :c |
                    renderer pushBounds: c bounds.
                    renderer accept: c.
                    renderer popBounds.
                ].
            );
            renderOn: renderer => renderChildrenOn: renderer;

            maybeRenderChildrenOn: renderer => (
                childrenDo: [ :c |
                    renderer pushBounds: c bounds.
                    c maybeRenderOn: renderer.
                    renderer popBounds.
                ].
            );
            maybeRenderOn: renderer => (
              isChildRenderDirty -> [
                isChildRenderDirty <- false.
                isRenderDirty if: [ isRenderDirty <- false. renderOn: renderer ]
                            else: [ maybeRenderChildrenOn: renderer ]
              ]
            );

            dispatchEvent: block AtX: evtX Y: evtY => (
                childrenReverseDo: [ :c |
                    | b <- c bounds |
                    b containsX: evtX Y: evtY
                      ~ if: [ (c dispatchEvent: block AtX: (evtX - b x) Y: (evtY - b y)) -> [ ^ true ] ]
                ].
                block value(self, evtX, evtY) -> [ ^ true ].
              ^ false
            );

            xRayAtX: x Y: y Do: block => (
                block value(self).
                childrenWithBoundsDo: [ :c, :b |
                    b containsX: x Y: y
                      ~ if: [ c xRayAtX: (x - b x) Y: (y - b y) Do: block ]
                ].
              ^ self
            );

            handleDropMorph: morph AtX: x Y: y => false;
            handleClickAtX: x Y: y HandMorph: hand => false;

            dropMorph: morph AtX: x Y: y => dispatchEvent: [ :e, :ex, :ey | e handleDropMorph: morph AtX: ex Y: ey ] AtX: x Y: y;
            clickAtX: x Y: y HandMorph: hand => dispatchEvent: [ :e, :ex, :ey | e handleClickAtX: ex Y: ey HandMorph: hand ] AtX: x Y: y;

            writeOn: w => w << 'a morph';

            dumpOn: w Indentation: i => (
                0 to: i do: [ :j | w << '  ' ].
                (w << self << ' ' << bounds << ' layoutOK: ' << layoutOkay << ', dirty: ' << isDirty << ', renderDirty: ' << isRenderDirty << ', childRenderDirty: ' << isChildRenderDirty) newline commit.
                childrenDo: [ :c | c dumpOn: w Indentation: (i + 1) ].
            );
            dumpOn: w => dumpOn: w Indentation: 0;
        };
    }
