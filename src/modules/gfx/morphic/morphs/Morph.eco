
    {
        static with inherited _ = std Clonable;
        protected morphic = $ morphic;

        offset, dimensions,
        protected cachedGlobalOffset,
        protected cachedLayoutingConstraints,
        xLayout, yLayout, layouter,
        parent, children;

        with inherited trait = {
            static with inherited _ = std Trait;

            initWithChildConfig: config => (
                offset             <- (morphic X: 0 Y: 0).
                dimensions         <- (morphic W: 0 H: 0).
                cachedGlobalOffset <- No.
                cachedLayoutingConstraints <- No.
                xLayout            <- (morphic layouts Flexible).
                yLayout            <- (morphic layouts Flexible).
                layouter           <- (morphic layouters Default).
                parent             <- No.
                children           <- config new.
              ^ self
            );

            initWithNoChildren   => initWithChildConfig: (morphic children None);
            initWithOneChild     => initWithChildConfig: (morphic children One);
            initWithManyChildren => initWithChildConfig: (morphic children Many);

            init => initWithNoChildren;

            "
                Children
            "
            childrenDo: block => children childrenDo: block;
            childrenReverseDo: block => children childrenReverseDo: block;
            allChildrenDo: block => childrenDo: [ :c | block value(c). c allChildrenDo: block ];
            childrenWithBoundsDo: block => childrenDo: [ :c | block value(c, c bounds) ];

            allParentsDo: block => (
                parent yes: [ :p | block value(p). p allParentsDo: block ]
                        no: [      ^ self                                ]
            );

            root => (
                parent yes: [ :p | p root ]
                        no: [      self   ]
            );

            world => (
                parent yes: [ :p | p world ]
                        no: [      No      ]
            );

            unlink => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );

            noParent  => (
                parent       <- No.
                invalidateGlobalOffsetCache.
              ^ self
            );
            parent: p => (
                parent       <- Yes: p;
                invalidateGlobalOffsetCache.
              ^ self
            );

            isIn: morph => (
                (self == morph) -> [ ^ true ].
                parent yes: [ :p | ^ p isIn: morph ]
                        no: [      ^ false         ]
            );

            tryAdd: child => (
                ((self isIn: child) not) -> [
                    (children add: child) unless: [ ^ false ].
                    child unlink.
                    child parent: self.
                    layoutChanged.
                    child invalidateGlobalOffsetCache.
                  ^ true
                ].
              ^ false
            );

            add: child => (
                (tryAdd: child)
                    unless: [ 'Morph can not be added!' throw ].
              ^ self
            );

            remove: child => (
                (children remove: child)
                  ~ if: [ child noParent. layoutChanged. ].
              ^ self
            );

            remove => (
                parent yes: [ :p | p remove: self ].
              ^ self
            );


            "
                Position and Size
            "
            offsetForOrientation: orientation => (
                offset dimensionForOrientation: orientation
            );

            width  => dimensions x;
            height => dimensions y;

            extentForOrientation: orientation => (
                dimensions dimensionForOrientation: orientation
            );

            globalOffset => (
                cachedGlobalOffset
                  ~ yes: [ :v | ^ v ]
                     no: [  |
                                goffset <- parent yes: [ :p | (p globalOffset + offset) ]
                                                   no: [      offset                    ]
                            |
                            cachedGlobalOffset <- Yes: goffset.
                          ^ goffset
                     ].
            );
            invalidateGlobalOffsetCache => (
                cachedGlobalOffset <- No.
                childrenDo: [ :c | c invalidateGlobalOffsetCache ].
              ^ self
            );

            moveTo: point => (
                offset <- point.
                invalidateGlobalOffsetCache.
              ^ self
            );

            moveToX: x Y: y => moveTo: (morphic X: x Y: y);

            resizeTo: point => (
                dimensions <- point.
                layoutChanged.
              ^ self
            );

            reshapeX: x Y: y W: w H: h => moveTo: (morphic X: x Y: y) ~ resizeTo: (morphic W: w H: h);
            bounds: rect => reshapeX: (rect x) Y: (rect y) W: (rect w) H: (rect h);


            "
                Layouts
            "
            layouter: l => layouter <- l;
            
            xLayout: layout => xLayout <- layout;
            yLayout: layout => yLayout <- layout;

            rigidWidth:  w => xLayout: (morphic layouts Rigid: w);
            rigidHeight: h => yLayout: (morphic layouts Rigid: h);

            flexibleWidth  => xLayout: morphic layouts Flexible;
            flexibleHeight => yLayout: morphic layouts Flexible;
            flexibleSize   => ( flexibleWidth. flexibleHeight. );

            shrinkWrapWidth  => xLayout: morphic layouts ShrinkWrap;
            shrinkWrapHeight => yLayout: morphic layouts ShrinkWrap;
            shrinkWrapSize   => ( shrinkWrapWidth. shrinkWrapHeight. );

            layoutForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ xLayout ]
                      ifVertical: [ yLayout ]
            );


            "
                Layouting
            "
            baseMinWidth => 0;
            baseMinHeight => 0;

            baseMinSizeForOrientation: orientation => (
                orientation
                  ~ ifHorizontal: [ baseMinWidth  ]
                      ifVertical: [ baseMinHeight ]
            );

            minSizeForOrientation: orientation => (
                layouter calculateMinSizeForMorph: self Orientation: orientation
            );

            minWidth => minSizeForOrientation: (morphic orientation Horizontal);
            minHeight => minSizeForOrientation: (morphic orientation Vertical);

            minSize => morphic X: minWidth Y: minHeight;

            preferredSizeForOrientation: orientation Constraint: constraint => (
                layouter calculatePreferredSizeForMorph: self Orientation: orientation Constraint: constraint
            );

            preferredSizeWithConstraints: constraints => (
                morphic X: (preferredSizeForOrientation: (morphic orientation Horizontal) Constraint: (constraints x))
                        Y: (preferredSizeForOrientation: (morphic orientation Vertical)   Constraint: (constraints y))
            );

            layoutChanged => (
                cachedLayoutingConstraints <- No.
                parent yes: [ :p | p layoutChanged ].
            );

            protected layoutDirtyForConstraints: constraints => (
                cachedLayoutingConstraints
                  ~ yes: [ :c | (c equalsPoint: constraints) if: [ ^ false ] ].
              ^ true
            );

            forceLayoutWithConstraints: constraints => (
                layouter layoutMorph: self Constraints: constraints.
                cachedLayoutingConstraints <- Yes: constraints.
            );
            forceLayoutInPlace => forceLayoutWithConstraints: dimensions;

            layoutWithConstraints: constraints => (
                layoutDirtyForConstraints: constraints
                  ~ if: [ forceLayoutWithConstraints: constraints ]
            );
            layoutInPlace => layoutWithConstraints: dimensions;

            "
                Rendering
            "
            renderChildrenOn: renderer => (
                childrenDo: [ :c |
                    renderer pushOffset: c globalOffset.
                    renderer accept: c.
                    renderer popOffset.
                ].
            );
            renderOn: renderer => (
                renderChildrenOn: renderer;
            );

            dumpOn: w Indentation: i => (
                0 to: i do: [ :j | w << '  ' ].
                (w << self << ' ' << offset << ' ' << globalOffset << ', dimensions ' << dimensions << ' -- ' << xLayout << ' | ' << yLayout) newline commit.
                childrenDo: [ :c | c dumpOn: w Indentation: (i + 1) ].
            );
            dumpOn: w => dumpOn: w Indentation: 0;

            writeOn: w => w << 'a morph';
        };
    }
