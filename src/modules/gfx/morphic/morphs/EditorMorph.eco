
{
    static with inherited _ = std Clonable;
    with inherited own Morph = $ Morph;

    protected caret,
    protected lines;

    with inherited trait = {
        static with inherited _ = std Trait;

        protected own Line = {
            static with inherited _ = std Clonable;

            textobj, texture;

            static with inherited trait = {
                static with inherited _ = std Trait;

                initWithTextObj: _textobj => (
                    textobj <- _textobj.
                    texture <- No.
                  ^ self
                );

                width  => textobj width;
                height => textobj height;

                caretX: x      => textobj pointAtCharacterIndex: x;
                charAtPoint: x => textobj characterIndexAtX: x;

                protected getOrMakeTexture: renderer => (
                    texture no: [
                        texture <- Yes: (renderer makeTextTexture: textobj text).
                    ].
                  ^ texture
                );

                renderOn: renderer X: x Y: y => (
                    (getOrMakeTexture: renderer) yes: [ :t | renderer drawTexture: t X: x Y: y W: width H: height ].
                );

                writeOn: w => w << 'a text editor line';
            };
        };

        init => (
            $(Morph) init.
            caret <- morphic X: 0 Y: 0.
            lines <- std util newVector.
          ^ self
        );

        baseMinWidth => (
            | w <- 0 |
            lines do: [ :l | w <- w max: l width ].
          ^ w
        );

        baseMinHeight => (
            | h <- 0 |
            lines do: [ :l | h <- h + l height ].
          ^ h
        );

        protected reshapeToFit => (
            rigidWidth: baseMinWidth.
            rigidHeight: baseMinHeight.
          ^ self
        );

        append: text => (
            lines add: (Line clone initWithTextObj: (morphic Text: text)).
            reshapeToFit.
            layoutChanged.
          ^ self
        );

        protected caretToPixel(caret) => (
            |
                caretX <- (lines at: (caret y)) caretX: (caret x),
                caretY <- 0,
                y      <- 0
            |
            lines do: [ :l |
                (y < caret y) if: [ caretY <- caretY + l height ].
                y <- y + 1.
            ].
          ^ morphic X: caretX Y: caretY
        );

        protected pixelToCaret(pixel) => (
            |
                x  <- 0,
                y  <- 0,
                dy <- 0,
                dc <- 0
            |
            lines do: [ :l |
                (dy < pixel y) if: [ y <- dc ].
                dy <- dy + l height.
                dc <- dc + 1
            ].

            x <- (lines at: y) charAtPoint: pixel x.
          ^ morphic X: x Y: y
        );

        renderImplOn: renderer => (
            | y <- 0 |
            lines do: [ :l |
                l renderOn: renderer X: 0 Y: y.
                y <- y + l height.
            ].

            | pixelCaret <- caretToPixel(caret) |
            
            renderer setR: 255 G: 0 B: 0.
            renderer drawLineX: (pixelCaret x) Y: (pixelCaret y) X: (pixelCaret x) Y: (pixelCaret y) + (lines at: (caret y)) height.

            $(Morph) renderImplOn: renderer.
        );

        handleGrabAt: point HandMorph: hand => ( hand grab: self. true );
        handleClickAt: point HandMorph: hand => (
            caret <- pixelToCaret(point).
            renderDirty.
          ^ true
        );

        writeOn: w => w << 'a text editor';
    };
}
