
{
    static with inherited _ = std Module;

    sdl = (here / 'sdl.eco') import;

    Init => (
        sdl Init.
      ^ self
    );

    NewWindowWithTitle: title X: x Y: y W: w H: h => (Window clone) initWithHandle: (sdl CreateWindow(title, x, y, w, h, 0)) Width: w Height: h;
    NewEvent => (Event clone) init: sdl SDL_Event alloc;

    own Window = {
        static with inherited _ = std Clonable;

        protected wrapper = $,
        protected winptr,
        width, height,
        renderer;

        with inherited trait = {
            protected sdl => wrapper sdl;

            initWithHandle: _winptr Width: _width Height: _height => (
                winptr   <- _winptr.
                width    <- _width.
                height   <- _height.
                renderer <- (wrapper Renderer clone) init: (sdl CreateRenderer(_winptr, -1, 0));
              ^ self
            );

            destroy => sdl DestroyWindow(winptr);

            show => sdl ShowWindow(winptr);
            hide => sdl HideWindow(winptr);

            writeOn: w => w << 'an sdl window';
        };
    };

    own Renderer = {
        static with inherited _ = std Clonable;

        protected     wrapper = $,
        protected     renptr,
        protected own rectangle;

        with inherited trait = {
            protected sdl => wrapper sdl;

            init: _renptr => (
                renptr    <- _renptr.
                rectangle <- sdl SDL_Rect alloc.
              ^ self
            );

            destroy => sdl DestroyRenderer(renptr);

            flush => sdl RenderFlush(renptr);
            present => sdl RenderPresent(renptr);

            setR: r G: g B: b A: a => sdl SetRenderDrawColor(renptr, r, g, b, a);
            setR: r G: g B: b => setR: r G: g B: b A: 255;
            setColor: color => setR: color r G: g B: b;

            clear => sdl RenderClear(renptr);
            drawPointX: x Y: y => sdl RenderDrawPoint(renptr, x, y);
            drawLineX: x1 Y: y1 X: x2 Y: y2 => sdl RenderDrawLine(renptr, x1, y1, x2, y2);
            drawRectX: x Y: y W: w H: h => (
                drawLineX: x Y: y X: (x + w) Y: y.
                drawLineX: x Y: y X: x Y: (y + h).
                drawLineX: x Y: (y + h) X: (x + w) Y: (y + h).
                drawLineX: (x + w) Y: y X: (x + w) Y: (y + h).
            );
            fillRectX: x Y: y W: w H: h => (
                (rectangle access: 0) store: x.
                (rectangle access: 1) store: y.
                (rectangle access: 2) store: w.
                (rectangle access: 3) store: h.
                sdl RenderFillRect(renptr, rectangle address).
            );

            writeOn: w => w << 'an sdl renderer';
        };
    };

    own EventVisitor = {
        static with inherited _ = std Clonable;

        visitUnknown: event => event;

        visitMouseMotionEvent: event => visitUnknown: event;

        visitMouseButtonEvent: event => visitUnknown: event;

        visitKeyEvent: event => visitUnknown: event;

        writeOn: w => w << 'an sdl event visitor';
    };

    own Event = {
        static with inherited _ = std Clonable;

        protected wrapper = $;
        protected event;

        with inherited trait = {
            protected sdl => wrapper sdl;

            init: _event => (
                event <- _event.
              ^ self
            );

            poll => sdl PollEvent(event address);
            type => (event access: 0) fetch;

            isMouseMotionEvent => (type == sdl SDL_EventTypes MOUSEMOTION);
            mouseMotionX => (((event access: 2) fetch) access: 5) fetch;
            mouseMotionY => (((event access: 2) fetch) access: 6) fetch;

            isMouseButtonDown => (type == sdl SDL_EventTypes MOUSEBUTTONDOWN);
            isMouseButtonUp => (type == sdl SDL_EventTypes MOUSEBUTTONUP);

            isKeyDown => (type == sdl SDL_EventTypes KEYDOWN);
            isKeyUp => (type == sdl SDL_EventTypes KEYUP);

            acceptEventVisitor: visitor => (
                begin
                    if: [ isMouseMotionEvent ] then: [ visitor visitMouseMotionEvent: self ] ~
                    if: [ isMouseButtonUp    ] then: [ visitor visitMouseButtonEvent: self ] ~
                    if: [ isMouseButtonDown  ] then: [ visitor visitMouseButtonEvent: self ] ~
                    if: [ isKeyUp            ] then: [ visitor visitKeyEvent: self         ] ~
                    if: [ isKeyDown          ] then: [ visitor visitKeyEvent: self         ] ~
                default: [ visitor visitUnknown: self ].
            );

            writeOn: w => w << 'an sdl event';
        };
    };

    own Program = {
        static with inherited _ = std Clonable;

        window,
        protected handler,
        private running;

        with inherited trait = {
            initWithWindow: _window Handler: _handler => (
                window  <- _window.
                handler <- _handler.
                running <- true.
              ^ self
            );

            run => (
                | event <- sdl NewEvent |
                running <- true.
                [
                    (running not) -> [ ^ self ].
                    handler tick: self.
                    (event poll != 0) -> [
                        handler handleEvent: event.
                    ].
                    "TODO: Sleep for a while to avoid eating up CPU resources"
                ] repeat.
            );

            stop => running <- false;

            writeOn: w => w << 'an sdl program';
        };
    };

    own Color = {
        static with inherited _ = std Clonable;

        r, g, b;

        with inherited trait = {
            initWithR: _r G: _g B: _b => (
                r <- _r.
                g <- _g.
                b <- _b.
              ^ self
            );

            writeOn: w => w << 'a color';
        };
    };
}
