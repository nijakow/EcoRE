{
    static with inherited _ = std Clonable;

    with gfx = $package;

    MirrorBuilder = {
        static with inherited _ = std Module;
        $battery = $;

        document <- $ document;
        builder <- $ ui builder.
        optimizer <- $package ecosphere optimizer;

        SlotOutliner: slotMirror Rebuilder: rebuilder => (
            builder HBox(
                builder Framed(
                    builder Margin(3,
                        builder HBox(
                            builder Label: (slotMirror isProtected if: 'p' else: ' '),
                            builder Label: (slotMirror isStatic if: 's' else: ' '),
                            builder Label: (slotMirror isFinal if: 'f' else: ' '),
                            builder Label: (slotMirror isWith if: 'w' else: ' '),
                            builder Label: (slotMirror isInherited if: 'i' else: ' '),
                        ) ~ xLayout: builder layouts ShrinkWrap,
                    ) ~ xLayout: builder layouts ShrinkWrap,
                ) ~ xLayout: builder layouts ShrinkWrap,
                builder Button(builder Margin(3, builder Label: (slotMirror name asString)),
                                $[ :(builder, mirror) :sender |
                                    (sender world yes) open: (builder WindowFor: (mirror slotValue))
                                ] bind(self, slotMirror)
                ) ~ xLayout: builder layouts Flexible,
                builder Button(builder Margin(3, builder Label: 'Ã¸'),
                                $[ :(mirror, rebuilder) :sender |
                                    mirror delete.
                                    rebuilder value.
                                ] bind(slotMirror, rebuilder)
                )
            ) ~ xLayout: builder layouts Flexible
              ~ yLayout: builder layouts ShrinkWrap
        );

        OutlinerPaneForMirror: mirror => (
            |
                slots     <- builder make VBoxMorph,
                rebuilder <- $[ :(builder, mirror, slots) | slots replaceWith: (builder OutlinerPaneForMirror: mirror) ] bind(self, mirror, slots)
            |

            mirror slotNames do: [ :slotName |
                slots add: (SlotOutliner: (mirror slot: slotName) Rebuilder: rebuilder)
            ].

          ^ slots
        );

        OutlinerPaneForObject: object => OutlinerPaneForMirror: (std reflect Mirror: object);

        LoadToolFromPath: path => (
            [
                | morph <- (path importIn: $battery) build |
              ^ Yes: morph
            ] catch: [ :e |
                | sw <- (std io StringWriter) new |
                (sw << 'Error while loading tool!') newline newline.
                sw << e.
                ErrorWindow: (sw build).
              ^ No
            ]
        );

        PathOutlinerRow: childpath Name: name Parent: parent => (
            builder ShrinkWrap(
                builder HBox(
                    builder Button(builder Margin(3, builder Label: (name)),
                                   $[ :(builder, parent, path) :sender |
                                        begin
                                          ~ if: [ (path extension) equals: 'eco' ] then: [ (sender world yes) open: (builder OutlinerWindowForPath: path) ]
                                          ~ if: [ (path extension) equals: 'ego' ] then: [ (builder LoadToolFromPath: path) yes: [ :obj | (sender world yes) open: obj ] ]
                                          ~ default: [ parent replaceWith: (builder OutlinerPaneForPath: path) ]
                                   ] bind(self, parent, childpath)
                    )
                ) ~ xLayout: builder layouts Flexible
            )
        );
        PathOutlinerRow: childpath Parent: parent => PathOutlinerRow: childpath Name: (childpath name) Parent: parent;
        OutlinerPaneForPath: path => (
            | slots <- builder make VBoxMorph |
            slots add: (PathOutlinerRow: (path / '..') Name: '..' Parent: slots).
            path children do: [ :subpath |
                slots add: (PathOutlinerRow: subpath Parent: slots)
            ].
          ^ slots
        );
        OutlinerWindowForPath: path => (
            ((path extension) equals: 'eco') if: [
                ^ [ WindowFor: (path import) ] catch: [ :e |
                    | sw <- (std io StringWriter) new |
                    (sw << 'Syntax error while parsing expression:') newline newline.
                    sw << e.
                    ErrorWindow: (sw build)
                ]
            ] else: [
                ^ builder Window(400, 400, builder Scrollable(OutlinerPaneForPath: path))
            ]
        );

        MoleculePaneFor: object => (
            builder WithRebuilderDo: $[ :(us, builder, object) :rebuilder |
                builder Stacked(
                    builder VBox(
                        builder Spacer,
                        builder HBox(
                            builder Spacer,
                            builder Button(builder Margin(5, builder Label: 'C'),
                                            $[ :(object) :sender |
                                                sender world yes: [ :world |
                                                    (world handMorph) copyToClipboard: object
                                                ]
                                            ] bind(object)
                            ),
                            builder Button(builder Margin(5, builder Label: '+'),
                                            $[ :(object, rebuilder) :sender |
                                                #'ecosphere.ecore.reflect.add_value_slot'(object, -1, 1, any, #'newSlot', 42).
                                                rebuilder value.
                                            ] bind(object, rebuilder)
                            ),
                            builder SpacerW: 10 H: 1
                        ) ~ yLayout: builder layouts ShrinkWrap,
                    ),
                    builder Scrollable(builder Margin(10, us OutlinerPaneForObject: object)),
                ),
            ] bind(self, builder, object)
        );

        InterfacePaneFor: object => (
            builder Scrollable(
                builder Margin(10,
                    builder Label: 'Interface!'
                )
            )
        );

        CodePaneFor: object => (
            |
                writer       <- (std io StringWriter) new,
                disassembled <- optimizer Disassemble: object,
                ast          <- optimizer BuildAST: disassembled,
                rewritten    <- optimizer RewriteAST: ast
            |

            ((optimizer ast Printer) clone initWithWriter: writer) print: rewritten ast.

            builder Scrollable(
                builder TextField: (writer build)
            )
        );

        PresentationPaneFor: object => (
            | writer <- (std io StringWriter) new |
            
            writer << object.

            builder Scrollable(
                builder TextField: (writer build)
            )
        );

        PaneFor: object => (
            begin
              ~ if: [ std reflect primitives IsMolecule:  object ] then: [ ^ MoleculePaneFor:  object ]
              ~ if: [ std reflect primitives IsInterface: object ] then: [ ^ InterfacePaneFor: object ]
              ~ if: [ std reflect primitives IsCode:      object ] then: [ ^ CodePaneFor:      object ]
            ~ default: [ ^ PresentationPaneFor: object ]
        );

        WindowFor: object => (
            builder Window(400, 400,
                builder VBox(
                    PaneFor: object,
                    ObjectShellFor: object ~ rigidHeight: 100
                )
            )
        );

        ErrorWindow: error => (
            builder Window(360, 200,
                builder TextField: error
            )
        );

        RunStringAndShowResult: source World: world Environment: environment => (
            [
                |
                    parser <- (lang eco controller) CreateParserForString: source
                |
                parser exprDo: [ :expr |
                    [
                        | result <- expr basicEvaluateInEnv: environment |
                        world open: (WindowFor: result)
                    ] catch: [ :e |
                        | sw <- (std io StringWriter) new |
                        (sw << 'Error while evaluating expression!') newline newline.
                        sw << e.
                        world open: (ErrorWindow: (sw build))
                    ]
                ]
            ] catch: [ :e |
                | sw <- (std io StringWriter) new |
                (sw << 'Syntax error while parsing expression:') newline newline.
                sw << e.
                world open: (ErrorWindow: (sw build))
            ]
        );
        RunStringAndShowResult: source World: world => RunStringAndShowResult: source World: world Environment: lobby;

        RunDocumentAndShowResult: source World: world Environment: environment => (
            [
                |
                    parser <- (lang eco controller) CreateParserForSourceStream: (source documentStream)
                |

                parser exprDo: [ :expr |
                    [
                        | result <- expr basicEvaluateInEnv: environment |
                        world open: (WindowFor: result)
                    ] catch: [ :e |
                        | sw <- (std io StringWriter) new |
                        (sw << 'Error while evaluating expression!') newline newline.
                        sw << e.
                        world open: (ErrorWindow: (sw build)).
                      ^ self
                    ]
                ]
            ] catch: [ :e |
                | sw <- (std io StringWriter) new |
                (sw << 'Syntax error while parsing expression:') newline newline.
                sw << e.
                world open: (ErrorWindow: (sw build)).
              ^ self
            ]
        );
        RunDocumentAndShowResult: source World: world => RunDocumentAndShowResult: source World: world Environment: lobby;

        ShellWindow => (
            builder Window(500, 350,
                builder DocumentEditor: (document FromString: '"\n    A module.\n"\n\n{\n    static with inherited _ = std Module;\n\n    \n}\n')
                    OnAccept: $[ :(us) :editor | us RunDocumentAndShowResult: (editor document) World: (editor world yes) ] bind(self)
                    OnCancel: $[ :editor | editor clear ]
            )
        );

        ObjectShellFor: object => (
            builder DocumentEditor: (document FromString: '"Enter your instructions here"\n\n')
                OnAccept: $[ :(us, object) :editor | us RunDocumentAndShowResult: (editor document) World: (editor world yes) Environment: object ] bind(self, object)
                OnCancel: $[ :editor | editor clear ]
        );
    };

    openInWorld: world => world open: build;

    reset => (
      ^ self
    );

    build => (
        | ui <- self ui builder |

        ui Window(280, 275,
            ui VBox(
                ui Center(ui TextField: 'Look at me as I can fly!\n    - Chrom, "Regret & Testify"'),
                ui VBox(
                    ui Button(ui Center(ui Label: 'Outliner'),
                            $[ :(MirrorBuilder) :sender | (sender world yes) open: (MirrorBuilder WindowFor: lobby) ]
                                    bind(MirrorBuilder))
                        ~ xLayout: ui layouts Flexible
                        ~ yLayout: ui layouts Flexible,
                    ui Button(ui Center(ui Label: 'Files'),
                            $[ :(MirrorBuilder) :sender | (sender world yes) open: (MirrorBuilder OutlinerWindowForPath: (std os files here / '..' / '..' / '..')) ]
                                    bind(MirrorBuilder))
                        ~ xLayout: ui layouts Flexible
                        ~ yLayout: ui layouts Flexible,
                    ui Button(ui Center(ui Label: 'Shell'),
                            $[ :(MirrorBuilder) :sender | (sender world yes) open: (MirrorBuilder ShellWindow) ]
                                    bind(MirrorBuilder))
                        ~ xLayout: ui layouts Flexible
                        ~ yLayout: ui layouts Flexible
                )
            )
        )
    );

    Main => (
        morphic RunWithWidth: 1400 Height: 800 App: self;
    );
}
