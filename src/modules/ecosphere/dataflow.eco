{
    static with inherited _ = std Module;

    own Register = {
        static with inherited _ = std Clonable;

        index, depth;

        with inherited trait = {
            initWithIndex: _index Depth: _depth => (
                index <- _index.
                depth <- _depth.
              ^ self
            );

            writeOn: w => w << 'a register';
        };
    };

    own RegisterTable = {
        static with inherited _ = std Clonable;
        protected wrapper = $;

        entries;

        with inherited trait = {
            protected Register => wrapper Register;

            init => (
                entries <- std util newVector.
              ^ self
            );

            register: index depth: depth => (
                entries do: [ :e |
                    ([e index == index] and: [e depth == depth])
                      ~ if: [ ^ e ]
                ].
                | r <- (Register new) initWithIndex: index Depth: depth |
                entries add: r.
              ^ r
            );
        };
    };

    own types = {
        static with inherited _ = std Module;

        own Any = {
            static with inherited _ = std Singleton;

            writeOn: w => w << 'any value';
        };

        own ConstantValue = {
            static with inherited _ = std Clonable;

            constantValue;

            with inherited trait = {
                init: _cv => (
                    constantValue <- _cv.
                  ^ self
                );

                writeOn: w => w << 'a constant value';
            };
        };

        Constant: val => (ConstantValue new) init: val;
        Either: a Or: b => Any; "TODO: Combination type"
    };

    own nodes = {
        static with inherited _ = std Module;

        own Node = {

        };
    };
   
}
