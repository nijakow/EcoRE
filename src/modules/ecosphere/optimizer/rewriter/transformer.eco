{
    static with inherited _ = std Clonable;

    context;

    Answer: ast In: context => "TODO: Return a pair of AST and Context";
    Answer: ast => Answer: ast In: context;

    In: context => "TODO: Create a new transformer";

    "
        Sometimes we don't want to have all those ASTScope's flying
        around. This function neatly unwraps them for us.
    "
    Unscope: ast => (
        | c <- context |
        [ ast type == astTypes Scope ] while: [
            ast <- ast body.
            c <- ast context.
        ].
      ^ Answer: ast In: c
    );

    transformMultiple: exprs => (
        exprs map: [ :expr | transform: expr ]
    );

    transformRegister: ast => (
        | constraints  <- context
                            ~ lexical: (ast depth)
                            ~ register: (ast index)
                            ~ constraints
        |
        
        c ifConstant: [
            ^ Answer: (c constant) In: (c context)
        ] else: [
            ^ Answer: ast
        ]
    );

    with inherited _builtin = {
        static with inherited _ = std Trait;

        InlineValueBuiltin: ast Args: args => (
            "The 'InlineFunction:' function will take 'Answer's as parameters"
            ^ (InlineFunction: ((Unscope: args first) ast) Args: args Varargs: (ast varargs) Context: ((Unscope: args first) context))
        );

        RewriteBuiltin: ast Args: args => (
            ^ (builder Builtin: (ast message) Args: (args) Varargs: (ast varargs))
        );

        transformBuiltin: ast => (
            | args <- transformMultiple: (ast args) |

            "TODO: Call 'Unscope:' on 'args first'"

                 [ ast message == #'ecosphere.ecore.flow.value' ]
            and: [ args first ast type == astTypes Code         ] 
               ~ if: [ ^ Answer: (InlineValueBuiltin: args Args: args) ]
               else: [ ^ Answer: (RewriteBuiltin: ast Args: args)      ].
        );
    };

    transformSend: ast => (
        |
            args   <- transformMultiple: (ast args),
            ast2   <- builder Send: (ast message) Args: (ast args map: [ :arg | (Rewrite: arg Context: context) first ]) Varargs: (ast varargs),
            method <- LookupMethod: (ast2 message) InAST: (ast2 receiver)
        |
        method yes: [ :m | ^ InlineAST: m Args: ast2 args Varargs: ast2 varargs Context: context ]
                no: [      ^ ast2 & context                                                      ]
    );

    transform: ast => (
        Switch: (ast type)
          ~ case: astTypes Register do: [ ^ transformRegister: ast ]
          ~ case: astTypes Builtin  do: [ ^ transformBuiltin:  ast ]
          ~ case: astTypes Send     do: [ ^ transformSend:     ast ]
        ~ default: [ ^ Answer: ast In: context ]
    );
}
