{
    static with inherited _ = std Module;
    module = $;

    optimizer => module optimizer;

    with own switch = self module switch;

    protected astTypes => module ast types;
    protected constraints => module constraints;
    protected calc => module calc;
    protected builder => module builder;

    InlineMethod: m Args: args Varargs: varargs Context: context => (
        "TODO"
        (io out << 'Inlining method ' << m) newline commit.
      ^ 42
    );

    LookupCodeMethod: name => (
        (name == #'value') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'value' In: (std reflect proxies Block))) ].
        (name == #'repeat') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'repeat' In: (std reflect proxies Block))) ].
      ^ No
    );

    LookupMethod: name InAST: ast => (
        ((ast type) == (astTypes Code))
              if: [ ^ LookupCodeMethod: name ]
            else: [ ^ No                     ]
    );

    Rewrite: ast Context: context => (
        (Switch: ast type)
          ~ case: astTypes Builtin do: [
              ^ ast
            ]
          ~ case: astTypes Send do: [
                |
                    method <- LookupMethod: (ast message) InAST: (ast receiver)
                |
                method yes: [ :m | ^ InlineMethod: m Args: ast args Varargs: ast varargs Context: context ]
                        no: [      ^ ast                                                                  ]
            ]
          ~ case: astTypes Return do: [
              ^ builder Return: (Rewrite: ast returnValue Context: context) Depth: (ast depth)
            ]
          ~ default: [ ^ ast ]
    );
}
