{
    static with inherited _ = std Module;
    module = $;

    optimizer => module optimizer;

    with own switch = self module switch;

    protected astTypes => module ast types;
    protected constraints => module constraints;
    protected calc => module calc;
    protected builder => module builder;

    InlineMethod: m Args: args Varargs: varargs Context: context => (
        "TODO"
        (io out << 'Inlining method ' << m) newline commit.
        | newContext <- context wrap |
        args forEach: [ :i, :arg |
            (newContext register: i) constraints: (calc ConstraintsFor: arg Context: context).
            (std io out << i << ' ' << (calc ConstraintsFor: arg Context: context)) newline commit.
        ].
        "TODO: Stop condition for rewriting and inlining (maybe based on context depth?)"
      ^ Rewrite: m Context: newContext
    );

    LookupCodeMethod: name => (
        (name == #'value') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'value' In: (std reflect proxies Block))) ].
        (name == #'repeat') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'repeat' In: (std reflect proxies Block))) ].
      ^ No
    );

    LookupMethod: name InAST: ast => (
        ((ast type) == (astTypes Code))
              if: [ ^ LookupCodeMethod: name ]
            else: [ ^ No                     ]
    );

    Rewrite: ast Context: context => (
        (Switch: ast type)
          ~ case: astTypes Register do: [
                | c <- context
                           ~ depth: (ast depth)
                           ~ register: (ast index)
                           ~ constraints
                |
                c ifConstant: [ ^ c constant ] else: [ ^ ast ]
            ]
          ~ case: astTypes Builtin do: [
                (ast message == #'ecosphere.ecore.flow.value') -> [ ^ InlineMethod: (ast args at: 0) Args: (ast args map: [ :arg | Rewrite: arg Context: context ]) Varargs: (ast varargs) Context: context ].
              ^ builder Builtin: (ast message) Args: (ast args map: [ :arg | Rewrite: arg Context: context ]) Varargs: (ast varargs)
            ]
          ~ case: astTypes Send do: [
                |
                    ast2   <- builder Send: (ast message) Args: (ast args map: [ :arg | Rewrite: arg Context: context ]) Varargs: (ast varargs),
                    method <- LookupMethod: (ast2 message) InAST: (ast2 receiver)
                |
                method yes: [ :m | ^ InlineMethod: m Args: ast2 args Varargs: ast2 varargs Context: context ]
                        no: [      ^ ast2                                                                   ]
            ]
          ~ case: astTypes Return do: [
              ^ builder Return: (Rewrite: ast returnValue Context: context) Depth: (ast depth)
            ]
          ~ case: astTypes Compound do: [
              ^ builder Compound: (ast instructions map: [ :arg | Rewrite: arg Context: context ])
            ]
          ~ default: [ ^ ast ]
    );
}
