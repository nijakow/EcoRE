{
    static with inherited _ = std Module;
    module = $;

    optimizer => module optimizer;

    with own switch = self module switch;

    protected astTypes => module ast types;
    protected constraints => module constraints;
    protected calc => module calc;
    protected builder => module builder;

    InlineAST: m Args: args Varargs: varargs Context: context NewContext: newContext => (
        args forEach: [ :i, :arg |
            (newContext register: i) constraints: (calc ConstraintsFor: arg Context: context).
        ].
        "TODO: Stop condition for rewriting and inlining (maybe based on context depth?)"
      ^ Rewrite: (builder Scope: m Context: newContext) Context: newContext
    );
    InlineAST: m Args: args Varargs: varargs Context: context => InlineAST: m Args: args Varargs: varargs Context: context NewContext: context wrap;

    InlineFunction: m Args: args Varargs: varargs Context: context NewContext: newContext => InlineAST: m code Args: args Varargs: varargs Context: context NewContext: newContext;
    InlineFunction: m Args: args Varargs: varargs Context: context => InlineAST: m code Args: args Varargs: varargs Context: context NewContext: (context wrapLexical: context);

    LookupCodeMethod: name => (
        (name == #'std') -> [ ^ Yes: (builder Constant: std) ].
        (name == #'value') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'value' In: (std reflect proxies Block))) ].
        (name == #'repeat') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'repeat' In: (std reflect proxies Block))) ].
      ^ No
    );

    LookupMethod: name InAST: ast => (
        ((ast type) == (astTypes Code))
              if: [ ^ LookupCodeMethod: name ]
            else: [ ^ No                     ]
    );

    Rewrite: ast Context: context => (
        (Switch: ast type)
          ~ case: astTypes Register do: [
                | c <- context
                           ~ lexical: (ast depth)
                           ~ register: (ast index)
                           ~ constraints
                |
              ^ c ifConstant: [ c constant ] else: [ ast ]
            ]
          ~ case: astTypes Builtin do: [
                | args2 <- ast args map: [ :arg | Rewrite: arg Context: context ] |
                ( [ast message == #'ecosphere.ecore.flow.value'] and: [(args2 at: 0) type == astTypes Code]) -> [
                  ^ InlineFunction: (args2 at: 0) Args: args2 Varargs: (ast varargs) Context: context
                ].
              ^ builder Builtin: (ast message) Args: (args2) Varargs: (ast varargs)
            ]
          ~ case: astTypes Send do: [
                |
                    ast2   <- builder Send: (ast message) Args: (ast args map: [ :arg | Rewrite: arg Context: context ]) Varargs: (ast varargs),
                    method <- LookupMethod: (ast2 message) InAST: (ast2 receiver)
                |
                method yes: [ :m | ^ InlineAST: m Args: ast2 args Varargs: ast2 varargs Context: context ]
                        no: [      ^ ast2                                                                ]
            ]
          ~ case: astTypes Return do: [
              ^ builder Return: (Rewrite: ast returnValue Context: context) Depth: (ast depth)
            ]
          ~ case: astTypes Compound do: [
              ^ builder Compound: (ast instructions map: [ :arg | Rewrite: arg Context: context ])
            ]
          ~ case: astTypes Scope do: [
              ^ builder Scope: (Rewrite: (ast body) Context: (ast context)) Context: (ast context)
            ]
          ~ default: [ ^ ast ]
    );
}
