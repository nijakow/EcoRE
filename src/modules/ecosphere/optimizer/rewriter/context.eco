
{
    static with inherited _ = std Module;
    protected module = $;

    constraints => module constraints;

    own RegisterInfo = {
        static with inherited _ = std Clonable;
        protected context = $;

        constraints;

        with inherited trait = {
            init => (
                constraints <- context constraints Anything.
              ^ self
            );

            constraints: c => constraints <- c;

            writeOn: w => w << 'some register info';
        };
    };

    own Context = {
        static with inherited _ = std Clonable;
        protected context = $;

        surroundingContext,
        lexicalContext,
        registers;

        with inherited trait = {
            initWithSurroundingContext: context LexicalContext: lexical => (
                surroundingContext <- Yes: context.
                lexicalContext     <- Yes: lexical.
                registers          <- std util newMap.
              ^ self
            );

            initWithSurroundingContext: context => (
                surroundingContext <- Yes: context.
                lexicalContext     <- No.
                registers          <- std util newMap.
              ^ self
            );

            initWithLexicalContext: context => (
                surroundingContext <- No.
                lexicalContext     <- Yes: context.
                registers          <- std util newMap.
              ^ self
            );

            init => (
                surroundingContext <- No.
                lexicalContext     <- No.
                registers          <- std util newMap.
              ^ self
            );

            depth: d => (
                (d isZero)
                  ~   if: [ ^ self                                  ]
                    else: [ ^ surroundingContext yes depth: (d - 1) ]
            );

            lexical: d => (
                (d isZero)
                  ~   if: [ ^ self                                ]
                    else: [ ^ lexicalContext yes lexical: (d - 1) ]
            );

            depth => (
                surroundingContext yes: [ :lc | lc depth + 1 ]
                                    no: [       0            ]
            );

            lexicalDepth => (
                lexicalContext yes: [ :lc | lc lexicalDepth + 1 ]
                                no: [       0                   ]
            );

            register: index => (
                (registers at: index)
                  ~ yes: [ :r | ^ r ]
                     no: [
                          | ri <- (context RegisterInfo) new |
                          registers at: index put: ri.
                        ^ ri
                     ]
            );

            wrap => context WrapContext: self;
            wrapLexical: other => context WrapContext: self Lexical: other;

            writeOn: w => w << 'a context (' << depth << ', ' << lexicalDepth << ')';
        };
    };

    WrapContext: context => (Context clone) initWithSurroundingContext: context;
    WrapContext: context Lexical: lexical => (Context clone) initWithSurroundingContext: context LexicalContext: lexical;
    NewContext => (Context clone) init;
}
