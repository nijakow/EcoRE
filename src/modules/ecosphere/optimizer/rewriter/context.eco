
{
    static with inherited _ = std Module;
    protected module = $;

    constraints => module constraints;

    own RegisterInfo = {
        static with inherited _ = std Clonable;
        protected context = $;

                  constraints,
        protected translation;

        with inherited trait = {
            init => (
                constraints <- context constraints Anything.
                translation <- No.
              ^ self
            );

            constraints: c => constraints <- c;

            translationUsingAllocator: alloc => (
                translation yes: [ :t | ^ t                                              ]
                             no: [ translation <- Yes: alloc allocate. ^ translation yes ]
            );

            writeOn: w => w << 'some register info';
        };
    };

    own RegisterAllocator = {
        static with inherited _ = std Clonable;

        protected counter,
        protected freed;
        
        with inherited trait = {
            init => (
                counter <- 128.
                freed   <- std util newStack.
              ^ self
            );

            protected allocateNew => (
                | reg <- counter |
                counter <- counter + 1.
              ^ reg
            );

            protected allocateFreed => (
              ^ freed pop
            );

            allocate => (
                (freed isEmpty)
                  ~ if: [ ^ allocateNew   ]
                  else: [ ^ allocateFreed ]
            );

            free: n => freed push: n;

            withRegister: block => (
                | r <- allocate |
                        [ block value(r) ]
                ensure: [ free: r        ].
            );

            writeOn: w => w << 'a register allocator';
        };
    };

    own ContextCore = {
        static with inherited _ = std Clonable;
        protected context = $;

        registerAllocator;

        with inherited trait = {
            init => (
                registerAllocator <- (context RegisterAllocator) new.
              ^ self
            );

            writeOn: w => w << 'a context core';
        };
    };

    own Context = {
        static with inherited _ = std Clonable;
        protected context = $;

        core,
        surroundingContext,
        lexicalContext,
        protected registers,
        protected registerTranslations;

        with inherited trait = {

            _initWithSurroundingContext: surr Lexical: lex => (
                (surr or: lex) yes: [ :con | core <- con core                ]
                                no: [        core <- context ContextCore new ].
                surroundingContext <- surr.
                lexicalContext     <- lex.
                registers          <- std util newMap.
              ^ self
            );

            initWithSurroundingContext: context LexicalContext: lexical => (
              ^ _initWithSurroundingContext: (Yes: context) Lexical: (Yes: lexical)
            );

            initWithSurroundingContext: context => (
              ^ _initWithSurroundingContext: (Yes: context) Lexical: No
            );

            initWithLexicalContext: context => (
              ^ _initWithSurroundingContext: No Lexical: (Yes: lexical)
            );

            init => (
              ^ _initWithSurroundingContext: No Lexical: No
            );

            depth: d => (
                (d isZero)
                  ~   if: [ ^ self                                  ]
                    else: [ ^ surroundingContext yes depth: (d - 1) ]
            );

            lexical: d => (
                (d isZero)
                  ~   if: [ ^ self                                ]
                    else: [ ^ lexicalContext yes lexical: (d - 1) ]
            );

            depth => (
                surroundingContext yes: [ :lc | lc depth + 1 ]
                                    no: [       0            ]
            );

            lexicalDepth => (
                lexicalContext yes: [ :lc | lc lexicalDepth + 1 ]
                                no: [       0                   ]
            );

            register: index => (
                (registers at: index)
                  ~ yes: [ :r | ^ r ]
                     no: [
                          | ri <- (context RegisterInfo) new |
                          registers at: index put: ri.
                        ^ ri
                     ]
            );

            wrap => context WrapContext: self;
            wrapLexical: other => context WrapContext: self Lexical: other;

            translateRegister: n Depth: d => lexical: d ~ translateRegister: n;
            translateRegister: n => (
                (n < 128) if: [ ^ No ].
              ^ Yes: ((register: n) translationUsingAllocator: core registerAllocator)
            );

            writeOn: w => w << 'a context (' << depth << ', ' << lexicalDepth << ')';
        };
    };

    WrapContext: context => (Context clone) initWithSurroundingContext: context;
    WrapContext: context Lexical: lexical => (Context clone) initWithSurroundingContext: context LexicalContext: lexical;
    NewContext => (Context clone) init;
}
