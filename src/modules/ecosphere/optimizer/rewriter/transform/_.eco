{
    static with inherited _ = std Module;
    module = $;

    optimizer => module optimizer;

    with own switch = self module switch;

    protected astTypes => module ast types;
    protected constraints => module constraints;
    protected calc => module calc;
    protected builder => module builder;

    with own Answer = (here / 'Answer.eco') importIn: self;
    with own Transformer = (here / 'Transformer.eco') importIn: self;

    InlineAST: m Args: args Varargs: varargs Context: context NewContext: newContext => (
        args forEach: [ :i, :arg |
            "OOF! BUG FOUND! The [...] will be interpreted as coming from the surrounding context, even though it is from a deeper one! 'ConstraintsFor: arg Context: context' will not return the correct context, since the AST doesn't even store it!"
            (newContext register: i) constraints: (calc ConstraintsFor: arg Context: context).
        ].
        "TODO: Stop condition for rewriting and inlining (maybe based on context depth?)"
      ^ Rewrite: (builder Scope: m Context: newContext) Context: newContext
    );
    InlineAST: m Args: args Varargs: varargs Context: context => InlineAST: m Args: args Varargs: varargs Context: context NewContext: context wrap;

    InlineFunction: m Args: args Varargs: varargs Context: context NewContext: newContext => InlineAST: m code Args: args Varargs: varargs Context: context NewContext: newContext;
    InlineFunction: m Args: args Varargs: varargs Context: context => InlineAST: m code Args: args Varargs: varargs Context: context NewContext: (context wrapLexical: context);

    LookupCodeMethod: name => (
        (name == #'value') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'value' In: (std reflect proxies Block))) ].
        (name == #'repeat') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'repeat' In: (std reflect proxies Block))) ].
      ^ No
    );

    LookupMethod: name InAST: ast => (
        ((ast type) == (astTypes Code))
              if: [ ^ LookupCodeMethod: name ]
            else: [ ^ No                     ]
    );

    ImplForRewrite: ast Context: context => (
        (Switch: ast type)
          ~ case: astTypes Register do: [
                | c <- context
                           ~ lexical: (ast depth)
                           ~ register: (ast index)
                           ~ constraints
                |
              ^ c ifConstant: [ (c constant) & (c context) ] else: [ ast & context ]
            ]
          ~ case: astTypes Builtin do: [
                | args2 <- ast args map: [ :arg | Rewrite: arg Context: context ] |
                ( [ast message == #'ecosphere.ecore.flow.value'] and: [(args2 at: 0) first type == astTypes Code]) -> [
                  ^ (InlineFunction: (args2 at: 0) first Args: (args2 map: [ :e | e first ]) Varargs: (ast varargs) Context: (args2 at: 0) second) & context
                ].
              ^ (builder Builtin: (ast message) Args: (args2) Varargs: (ast varargs)) & context
            ]
          ~ case: astTypes Send do: [
                |
                    ast2   <- builder Send: (ast message) Args: (ast args map: [ :arg | (Rewrite: arg Context: context) first ]) Varargs: (ast varargs),
                    method <- LookupMethod: (ast2 message) InAST: (ast2 receiver)
                |
                method yes: [ :m | ^ InlineAST: m Args: ast2 args Varargs: ast2 varargs Context: context ]
                        no: [      ^ ast2 & context                                                      ]
            ]
          ~ case: astTypes Return do: [
              ^ (builder Return: (Rewrite: ast returnValue Context: context) first Depth: (ast depth)) & context
            ]
          ~ case: astTypes Compound do: [
              ^ (builder Compound: (ast instructions map: [ :arg | (Rewrite: arg Context: context) first ])) & context
            ]
          ~ case: astTypes Scope do: [
              ^ (builder Scope: (Rewrite: (ast body) Context: (ast context)) first Context: (ast context)) & (ast context)
            ]
          ~ default: [ ^ ast & context ]
    );

    Rewrite: ast Context: context => (
        | v <- ImplForRewrite: ast Context: context |
        (std io out << '<<< Rewriting ' << ast << ' in ' << context << ' => ' << v) newline commit.
      ^ v
    );
}
