{
    static with inherited _ = std Clonable;

    protected transform = $;
    protected module => transform module;
    protected optimizer => module optimizer;

    with own switch = $ module switch;

    protected astTypes => module ast types;
    protected constraints => module constraints;
    protected calc => module calc;
    protected builder => module builder;

    context;

    Answer: ast In: context => (transform Answer) clone initWithAST: ast Context: context;
    Answer: ast => Answer: ast In: context;

    In: context => (transform Transformer) clone init: context;

    "
        Sometimes we don't want to have all those ASTScope's flying
        around. This function neatly unwraps them for us.
    "
    Unscope: ast => (
        | c <- context |
        [ ast type == astTypes Scope ] while: [
            ast <- ast body.
            c <- ast context.
        ].
      ^ Answer: ast In: c
    );

    with inherited _inlining = {
        static with inherited _ = std Trait;

        InlineAST: ast Args: args Varargs: varargs NewContext: newContext => (
            "TODO: To make inlining easier, let the program store all arguments in variables and
                   make the local variables point to them."
            args forEach: [ :i, :arg |
                (newContext register: i) constraints: (calc ConstraintsFor: arg)
            ].
            "TODO: Stop condition for rewriting and inlining (maybe based on context depth?)"
          ^ ((In: newContext) transform: ast) wrap
        );
        InlineAST: ast Args: args Varargs: varargs =>
            InlineAST: ast Args: args Varargs: varargs NewContext: context wrap;

        InlineLambda: lambda Args: args Varargs: varargs => (
            | ast <- lambda ast, newContext <- lambda context |
            "TODO: Maybe do argument checking?"
          ^ (InlineAST: ast code Args: args Varargs: varargs NewContext: (newContext wrapLexical))
        );

        InlineMethod: method Args: args Varargs: varargs => (
          ^ (InlineAST: method Args: args Varargs: varargs)
        );
    };

    with inherited _lookup = {
        static with inherited _ = std Trait;

        LookupBlockMethod: name => (
            (name == #'value') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'value' In: (std reflect proxies Block))) ].
            (name == #'repeat') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'repeat' In: (std reflect proxies Block))) ].
            (name == #'while:') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'while:' In: (std reflect proxies Block))) ].
          ^ No
        );

        LookupMethod: name InAST: ast => (
            ((ast type) == (astTypes Block))
                  if: [ ^ LookupBlockMethod: name ]
                else: [ ^ No                      ]
        );
    };

    with inherited _register = {
        static with inherited _ = std Trait;

        TranslateRegister: r => (
            (context translateRegister: r index Depth: r depth)
              ~ yes: [ :id | ^ (builder Register: id Depth: 0) ]
                 no: [       ^ r "TODO: Still translate inlined register depth" ]
        );

        transformRegister: ast => (
            | constraints  <- context
                                ~ lexical: (ast depth)
                                ~ register: (ast index)
                                ~ constraints
            |
            
            constraints ifConstant: [
                ^ Answer: (constraints constant) In: (constraints context)
            ] else: [
                "This is an early test for register rewriting."
                "TODO: If the translation was successful, the answer *MUST* be in 'root context'!!!"
                ^ Answer: (TranslateRegister: ast)
            ]
        );
    };

    with inherited _valueref = {
        static with inherited _ = std Trait;

        transformValueRef: ast => (
            | constraints <- calc ConstraintsFor: ast |

            constraints ifConstant: [
                ^ Answer: (constraints constant) In: (constraints context)
            ] else: [
                ^ Answer: ast
            ].
            ^ Answer: ast
        );
    };

    with inherited _builtin = {
        static with inherited _ = std Trait;

        InlineValueBuiltin: args Varargs: varargs => (
            | lambda <- args first |
          ^ (InlineLambda: (lambda) Args: (args) Varargs: (varargs))
        );

        RewriteBuiltin: ast Args: args => (
          ^ (builder Builtin: (ast message) Args: (args) Varargs: (ast varargs))
        );

        transformBuiltin: ast => (
            | args <- transformMultiple: (ast args) |

            "TODO: Call 'Unscope:' on 'args first'"

                 [ ast message == #'ecosphere.ecore.flow.value' ]
            and: [ args first ast type == astTypes Block        ]
               ~ if: [ ^ Answer: (InlineValueBuiltin: args Varargs: ast varargs) ]
               else: [ ^ Answer: (RewriteBuiltin: ast Args: args)      ].
        );
    };

    with inherited _send = {
        static with inherited _ = std Trait;

        RewriteSend: ast Args: args => (
            ^ (builder Send: (ast message) Args: (args map: [ :arg | arg wrapIn: context ]) Varargs: (ast varargs))
        );

        transformSend: ast => (
            |
                args   <- transformMultiple: (ast args),
                method <- LookupMethod: (ast message) InAST: ((args at: 0) ast)
            |
            method yes: [ :m | ^ Answer: (InlineMethod: m Args: args Varargs: ast varargs) ]
                    no: [      ^ Answer: (RewriteSend: ast Args: args)                      ]
        );
    };

    with inherited _return = {
        static with inherited _ = std Trait;

        transformReturn: ast => (
            ^ Answer: (builder Return: ((transform: ast returnValue) wrapIn: context) Depth: (ast depth))
        );
    };

    with inherited _compound = {
        static with inherited _ = std Trait;

        transformCompound: ast => (
            ^ Answer: (builder Compound: (ast instructions map: [ :arg | (transform: arg) wrapIn: context ]))
        );
    };

    with inherited _assignment = {
        static with inherited _ = std Trait;

        transformAssignment: ast => (
          ^ Answer: (builder Assign: ((transform: ast rhs) wrapIn: context) To: ((transform: ast lhs) wrapIn: context))
        );
    };

    with inherited _code = {
        static with inherited _ = std Trait;

        transformBlock: ast => (
          ^ Answer: (builder Block: (((In: context wrapLexical) transform: ast code) wrapIn: context))
        );
    };

    with inherited _scope = {
        static with inherited _ = std Trait;

        transformScope: ast => (
          ^ (In: ast context) transform: (ast body)
        );
    };

    transform: ast => (
        Switch: (ast type)
          ~ case: astTypes Register   do: [ ^ transformRegister:   ast ]
          ~ case: astTypes ValueRef   do: [ ^ transformValueRef:   ast ]
          ~ case: astTypes Builtin    do: [ ^ transformBuiltin:    ast ]
          ~ case: astTypes Send       do: [ ^ transformSend:       ast ]
          ~ case: astTypes Return     do: [ ^ transformReturn:     ast ]
          ~ case: astTypes Compound   do: [ ^ transformCompound:   ast ]
          ~ case: astTypes Assignment do: [ ^ transformAssignment: ast ]
          ~ case: astTypes Block      do: [ ^ transformBlock:      ast ]
          ~ case: astTypes Scope      do: [ ^ transformScope:      ast ]
          "TODO: Slot Assignments, ..."
        ~ default: [ ^ Answer: ast ]
    );

    transformMultiple: exprs =>
        exprs map: [ :expr | transform: expr ];
    

    init: _context => (
        context <- _context.
      ^ self
    );

    writeOn: w => w << 'a transformer';
}
