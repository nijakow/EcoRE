{
    static with inherited _ = std Clonable;

    protected transform = $;

    context;

    Answer: ast In: context => "TODO: Return a pair of AST and Context";
    Answer: ast => Answer: ast In: context;

    In: context => (transform Transformer) clone init: context;

    "
        Sometimes we don't want to have all those ASTScope's flying
        around. This function neatly unwraps them for us.
    "
    Unscope: ast => (
        | c <- context |
        [ ast type == astTypes Scope ] while: [
            ast <- ast body.
            c <- ast context.
        ].
      ^ Answer: ast In: c
    );

    with inherited _inlining = {
        static with inherited _ = std Trait;

        InlineAST: ast Args: args Varargs: varargs NewContext: newContext => (
            args forEach: [ :i, :arg |
                (newContext register: i) constraints: (calc ConstraintsFor: arg)
            ].
            "TODO: Stop condition for rewriting and inlining (maybe based on context depth?)"
          ^ (In: newContext) transform: ast
        );

        InlineLambda: lambda Args: args Varargs: varargs => (
            | ast <- lambda ast, newContext <- lambda context |
          ^ (InlineAST: ast Args: args Varargs: varargs NewContext: newContext)
        );

        InlineMethod: method Args: args Varargs: varargs => (
          ^ (InlineAST: method Args: args Varargs: varargs)
        );
    };

    with inherited _register = {
        static with inherited _ = std Trait;

        transformRegister: ast => (
            | constraints  <- context
                                ~ lexical: (ast depth)
                                ~ register: (ast index)
                                ~ constraints
            |
            
            c ifConstant: [
                ^ Answer: (c constant) In: (c context)
            ] else: [
                ^ Answer: ast
            ]
        );
    };

    with inherited _builtin = {
        static with inherited _ = std Trait;

        InlineValueBuiltin: ast Args: args => (
            | lambda <- (Unscope: args first) |
          ^ (InlineLambda: (lambda) Args: (args) Varargs: (ast varargs))
        );

        RewriteBuiltin: ast Args: args => (
            ^ (builder Builtin: (ast message) Args: (args) Varargs: (ast varargs))
        );

        transformBuiltin: ast => (
            | args <- transformMultiple: (ast args) |

            "TODO: Call 'Unscope:' on 'args first'"

                 [ ast message == #'ecosphere.ecore.flow.value' ]
            and: [ args first ast type == astTypes Code         ] 
               ~ if: [ ^ Answer: (InlineValueBuiltin: args Args: args) ]
               else: [ ^ Answer: (RewriteBuiltin: ast Args: args)      ].
        );
    };

    with inherited _send = {
        static with inherited _ = std Trait;

        RewriteSend: ast Args: args => (
            ^ (builder Send: (ast message) Args: (args) Varargs: (ast varargs))
        );

        transformSend: ast => (
            |
                args   <- transformMultiple: (ast args),
                method <- LookupMethod: (ast2 message) InAST: (ast2 receiver)
            |
            method yes: [ :m | ^ Answer: (InlineMethod: m Args: args Varargs: ast2 varargs) ]
                    no: [      ^ Answer: (RewriteSend: ast Args: args)                      ]
        );
    };

    with inherited _return = {
        static with inherited _ = std Trait;

        transformReturn: ast => (
            ^ Answer: (builder Return: (transform: ast returnValue) wrap Depth: (ast depth))
        );
    };

    with inherited _compound = {
        static with inherited _ = std Trait;

        transformCompound: ast => (
            ^ Answer: (builder Compound: (ast instructions map: [ :arg | (transform: arg) wrap ]))
        );
    };

    with inherited _scope = {
        static with inherited _ = std Trait;

        transformScope: ast => (
            ^ ((In: ast context) transform: (ast body) ~ wrap)
        );
    };

    transform: ast => (
        Switch: (ast type)
          ~ case: astTypes Register do: [ ^ transformRegister: ast ]
          ~ case: astTypes Builtin  do: [ ^ transformBuiltin:  ast ]
          ~ case: astTypes Send     do: [ ^ transformSend:     ast ]
          ~ case: astTypes Return   do: [ ^ transformReturn:   ast ]
          ~ case: astTypes Compound do: [ ^ transformCompound: ast ]
          ~ case: astTypes Scope    do: [ ^ transformScope:    ast ]
        ~ default: [ ^ Answer: ast ]
    );

    transformMultiple: exprs =>
        exprs map: [ :expr | transform: expr ];
    

    init: _context => (
        context <- _context.
      ^ self
    );

    writeOn: w => w << 'a transformer';
}
