{
    static with inherited _ = std Clonable;

    protected transform = $;
    protected module => transform module;
    protected optimizer => module optimizer;

    with own switch = $ module switch;

    protected astTypes => module ast types;
    protected constraints => module constraints;
    protected calc => module calc;
    protected builder => module builder;

    context;

    Answer: ast In: context => (transform Answer) clone initWithAST: ast Context: context;
    Answer: ast => Answer: ast In: context;

    In: context => (transform Transformer) clone init: context;

    "
        Sometimes we don't want to have all those ASTScope's flying
        around. This function neatly unwraps them for us.
    "
    Unscope: ast => (
        | c <- context |
        [ ast type == astTypes Scope ] while: [
            ast <- ast body.
            c <- ast context.
        ].
      ^ Answer: ast In: c
    );

    ExtendVarargs: args => (
        | v <- std util newVector |
        args into: v.
        (std io out << context lexicalVarargs) newline commit.
        context lexicalVarargs yes: [ :varargs | varargs do: [ :vararg | v add: vararg ] ].
        (std io out << 'arg: ' << v) newline commit.
      ^ v asArray
    );

    ExtendVarargs: args If: bool => (
        bool   if: [ ^ ExtendVarargs: args ]
             else: [ ^ args                ]
    );

    with inherited _inlining = {
        static with inherited _ = std Trait;

        allocValueRef => context core valueRefAllocator allocate;
        freeValueRef: ref => self; "Not doing anything (yet?)"

        InlineAST: ast ArgDefs: argdefs Args: args Varargs: varargs NewContext: newContext => (
            (args size > argdefs size) if: [ (std io out << 'Note: Possible argument error while inlining!') newline commit ].
            (args size < argdefs size) if: [
                'Argument error when inlining!' throw
            ].

            (args) do: [ :arg | (std io out << 'Argument: ' << arg) newline commit ].

            |
                refs    <- std util newVector,
                mapping <- std util newMap,
                cb      <- std util newVector
            |

            argdefs forEach: [ :i :arg |
                "TODO: If the corresponding argument is a constant (e.g. a block),
                       then don't generate a ValueRef, but replace the argument directly
                       by the literal.
                       This only works if there are no assignments to the variable."
                | param <- ((args at: i) ast) |
                (module IsConstant: param) if: [
                    mapping at: arg put: param
                ] else: [
                    |
                        v <- allocValueRef,
                        bv <- builder ValueRef: v
                    |
                    refs add: v.
                    mapping at: arg put: bv.
                    cb add: (builder Assign: ((args at: i) ast) To: bv)
                ]
            ].

            "TODO: Make a list of all varargs and add them to the context"

            |
                varargCount <- args size - argdefs size,
                varargList  <- std util newVector
            |
            0 to: (varargCount - 1) do: [ :i |
                | param <- (args at: varargCount + i) |
                (module IsConstant: param ast) if: [
                    varargList add: param
                ] else: [
                    |
                        v <- allocValueRef,
                        bv <- builder ValueRef: v
                    |
                    refs add: v.
                    varargList add: (Answer: bv).
                    cb add: (builder Assign: ((args at: i) ast) To: bv)
                ]
            ].

            (std io out << 'varargs:') newline commit.
            varargList do: [ :e |
                (std io out << '   ' << e) newline commit
            ].

            newContext varargs: (varargList asArray).

            cb add: (transform ReplaceAll: mapping In: ast).

            refs do: [ :ref | freeValueRef: ref ].

          ^ ((In: newContext) transform: (builder Compound: cb asArray)) wrap
        );
        InlineAST: ast ArgDefs: argdefs Args: args Varargs: varargs =>
            InlineAST: ast ArgDefs: argdefs Args: args Varargs: varargs NewContext: context wrap;

        InlineLambda: lambda Args: args Varargs: varargs => (
            | ast <- lambda ast, newContext <- lambda context |
            "TODO: Maybe do argument checking?"
          ^ (InlineAST: ast code ArgDefs: ast args Args: args Varargs: varargs NewContext: (newContext wrapLexical))
        );

        InlineMethod: method Args: args Varargs: varargs => (
          "^ (InlineAST: method ArgDefs: ... Args: args Varargs: varargs)"
          ^ (InlineAST: method code ArgDefs: method args Args: args Varargs: varargs)
        );
    };

    with inherited _lookup = {
        static with inherited _ = std Trait;

        LookupBlockMethod: name => (
            (name == #'value') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'value' In: (std reflect proxies Block))) ].
            (name == #'repeat') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'repeat' In: (std reflect proxies Block))) ].
            (name == #'while:') -> [ ^ Yes: (optimizer BuildAST: (optimizer Disassemble: #'while:' In: (std reflect proxies Block))) ].
          ^ No
        );

        LookupMethod: name InAST: ast => (
            ((ast type) == (astTypes Block))
                  if: [ ^ LookupBlockMethod: name ]
                else: [ ^ No                      ]
        );
    };

    with inherited _valueref = {
        static with inherited _ = std Trait;

        transformValueRef: ast => (
            |
                constraints <- calc ConstraintsFor: ast Context: context
            |

            constraints ifConstant: [
                ^ Answer: (constraints constant) In: (constraints context)
            ] else: [
                ^ Answer: ast
            ]
        );
    };

    with inherited _builtin = {
        static with inherited _ = std Trait;

        InlineValueBuiltin: args Varargs: varargs => (
            | lambda <- args first |
          ^ (InlineLambda: (lambda) Args: (args) Varargs: (varargs))
        );

        RewriteBuiltin: ast Args: args => (
          ^ (builder Builtin: (ast message) Args: (args map: [ :e | e wrapIn: context ]) Varargs: (ast varargs))
        );

        transformBuiltin: ast => (
            | args <- transformMultiple: (ast args) |

            "TODO: Call 'Unscope:' on 'args first'"

                 [ ast message == #'ecosphere.ecore.flow.value' ]
            and: [ args first ast type == astTypes Block        ]
               ~ if: [ ^ Answer: (InlineValueBuiltin: (ExtendVarargs: args If: ast varargs) Varargs: ast varargs) ]
               else: [ ^ Answer: (RewriteBuiltin: ast Args: args)                                                 ]
        );
    };

    with inherited _send = {
        static with inherited _ = std Trait;

        RewriteSend: ast Args: args => (
            ^ (builder Send: (ast message) Args: (args map: [ :arg | arg wrapIn: context ]) Varargs: (ast varargs))
        );

        transformSend: ast => (
            |
                args   <- transformMultiple: (ast args),
                method <- LookupMethod: (ast message) InAST: ((args at: 0) ast)
            |
            method yes: [ :m | ^ Answer: (InlineMethod: m Args: (ExtendVarargs: args If: ast varargs) Varargs: ast varargs) ]
                    no: [      ^ Answer: (RewriteSend: ast Args: args)                                                      ]
        );
    };

    with inherited _return = {
        static with inherited _ = std Trait;

        transformReturn: ast => (
            ^ Answer: (builder Return: ((transform: ast returnValue) wrapIn: context) Depth: (ast depth))
        );
    };

    with inherited _compound = {
        static with inherited _ = std Trait;

        transformCompound: ast => (
            ^ Answer: (builder Compound: (ast instructions map: [ :arg | (transform: arg) wrapIn: context ]))
        );
    };

    with inherited _assignment = {
        static with inherited _ = std Trait;

        transformAssignment: ast => (
          ^ Answer: (builder Assign: ((transform: ast rhs) wrapIn: context) To: ((transform: ast lhs) wrapIn: context))
        );
    };

    with inherited _code = {
        static with inherited _ = std Trait;

        transformBlock: ast => (
          ^ Answer: (builder Block: (((In: context wrapLexical) transform: ast code) wrapIn: context) Args: (ast args))
        );
    };

    with inherited _scope = {
        static with inherited _ = std Trait;

        transformScope: ast => (
          ^ (In: ast context) transform: (ast body)
        );
    };

    transform: ast => (
        Switch: (ast type)
          ~ case: astTypes ValueRef   do: [ ^ transformValueRef:   ast ]
          ~ case: astTypes Builtin    do: [ ^ transformBuiltin:    ast ]
          ~ case: astTypes Send       do: [ ^ transformSend:       ast ]
          ~ case: astTypes Return     do: [ ^ transformReturn:     ast ]
          ~ case: astTypes Compound   do: [ ^ transformCompound:   ast ]
          ~ case: astTypes Assignment do: [ ^ transformAssignment: ast ]
          ~ case: astTypes Block      do: [ ^ transformBlock:      ast ]
          ~ case: astTypes Scope      do: [ ^ transformScope:      ast ]
          "TODO: Slot Assignments, ..."
        ~ default: [ ^ Answer: ast ]
    );

    transformMultiple: exprs =>
        exprs map: [ :expr | transform: expr ];
    

    init: _context => (
        context <- _context.
      ^ self
    );

    writeOn: w => w << 'a transformer';
}
