{
    static with inherited _ = std Clonable;
    protected optimizer = $;
    with inherited visitor = $ InstructionVisitor;

    protected function;
    protected stack;
    protected bindings;
    protected compound;

    visitInstruction: instr => (std io out << 'Visiting ' << instr) newline;

    with inherited trait = {
        protected RegisterComparator = {
            static with inherited _ = std Singleton;

            value(a, b) => a equalsRegister: b;
        };

        initWithFunction: _function => (
            function <- _function.
            stack    <- std util newStack.
            bindings <- std util newAlistWithComparator: RegisterComparator;
            compound <- std util newVector.
          ^ self
        );

        builder => self;
        asts => optimizer ast;

        protected UnknownInstruction => 42;

        protected GetRegister: i => GetRegister: i Depth: 0;
        protected GetRegister: i Depth: d => (
            | r <- (Register: i Depth: d) |
            bindings at: r
              ~ yes: [ :v | ^ v ]
                 no: [      ^ r ]
        );

        protected Register: i => Register: i Depth: 0;
        protected Register: i Depth: d => (asts ASTRegister clone) initWithDepth: d Index: i;
        protected Constant: c => (asts ASTConstant clone) initWithConstant: c;
        protected Code: code => (asts ASTCode clone) initWithCode: code;

        protected Move: from To: to => (
            bindings at: to put: from.
            (asts ASTAssignment clone) initWithLHS: to RHS: from.
        );

        protected Builtin: key Args: args Varargs: varargs => UnknownInstruction;
        protected Send: key Args: args Varargs: varargs => (asts ASTSend clone) initWithMessage: key Args: args Varargs: varargs;
        protected Assign: key To: arg Key: key => UnknownInstruction;

        protected Return: v Depth: d => (asts ASTReturn clone) initWithValue: v Depth: d;
        protected JumpBack => (asts ASTJumpBack clone) init;

        protected Compound: elements => (asts ASTCompound clone) initWithInstructions: elements;

        protected popN: amount => (
            "
                This is a very ugly implementation,
                which will (hopefully!) change in the future.
            "

            |
                s <- std util newStack,
                v <- std util newVector
            |
            1 to: amount do: [ s push: (stack pop) ].
            1 to: amount do: [ v add: (s pop) ].
          ^ v asArray
        );

        protected OnStack: expr => stack push: expr;
        protected OnAST: expr => compound add: expr;

        visitNoop: instr => UnknownInstruction;
        visitLoadConstant: instr => OnAST: (builder Move: (builder Constant: instr constant) To: (builder Register: instr register));
        visitPushConstant: instr => OnStack: (builder Constant: instr constant);
        visitPush: instr => OnStack: (GetRegister: instr register);
        visitPop: instr => (builder Move: stack pop To: (builder Register: instr register));
        visitDrop: instr => OnAST: (stack pop);
        visitDup: instr => ( | v <- stack pop | stack push: v. stack push: v. );
        visitR2R: instr => (builder Move: (builder GetRegister: instr from) To: (builder Register: instr to));
        visitR2L: instr => (builder Move: (builder GetRegister: instr from) To: (builder Register: instr to Depth: instr depth));
        visitL2R: instr => (builder Move: (builder GetRegister: instr from Depth: instr depth) To: (builder Register: instr to));
        visitBuiltin: instr => OnStack: (builder Builtin: instr key Args: (popN: (instr args)) Varargs: instr varargs);
        visitSend: instr => OnStack: (builder Send: instr key Args: (popN: (instr args)) Varargs: instr varargs);
        visitAssign: instr => ( | v <- stack pop | OnStack: (builder Assign: v To: stack pop Key: instr key));
        visitReturn: instr => OnAST: (builder Return: stack pop Depth: instr depth);
        visitClosure: instr => (builder Move: (builder Code: instr code) To: (builder Register: instr register));
        visitJump: instr => OnAST: (builder JumpBack);

        buildAST => (
            |
                expr  <- function instructions,
            |
            
            [ :break |
                expr accept: self;
                expr next yes: [ :v | expr <- v ] no: [ break value ].
            ] repeatWithBreak.
          ^ builder Compound: compound
        );
    };
}
