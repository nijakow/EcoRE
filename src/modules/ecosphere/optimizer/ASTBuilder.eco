{
    static with inherited _ = std Clonable;
    protected optimizer = $;
    with inherited visitor = $ InstructionVisitor;

    protected function;
    protected stack;
    protected bindings;
    protected accu;
    protected cleared;
    protected compound;

    visitInstruction: instr => (std io out << 'Visiting ' << instr) newline;

    with inherited trait = {
        protected RegisterComparator = {
            static with inherited _ = std Singleton;

            value(a, b) => a equalsRegister: b;
        };

        initWithFunction: _function => (
            function <- _function.
            stack    <- std util newStack.
            bindings <- std util newAlistWithComparator: RegisterComparator;
            accu     <- builder Register: 0.
            cleared  <- false.
            compound <- std util newVector.
          ^ self
        );

        builder => self;
        asts => optimizer ast;

        protected UnknownInstruction => 42;

        protected GetRegister: i => GetRegister: i Depth: 0;
        protected GetRegister: i Depth: d => (
            | r <- (Register: i Depth: d) |
            bindings at: r
              ~ yes: [ :v | ^ v ]
                 no: [      ^ r ]
        );

        protected GetAccu => accu;

        protected Register: i => Register: i Depth: 0;
        protected Register: i Depth: d => (asts ASTRegister clone) initWithDepth: d Index: i;
        protected Constant: c => (asts ASTConstant clone) initWithConstant: c;
        protected Code: code => (asts ASTCode clone) initWithCode: code;

        protected Move: from To: to => (
            | v <- (asts ASTAssignment clone) initWithLHS: to RHS: from |
            (to depth != 0) -> [ ^ v ].
            bindings at: to put: v.
          ^ v
        );

        protected Builtin: key Args: args Varargs: varargs => (asts ASTBuiltin clone) initWithMessage: key Args: args Varargs: varargs;
        protected Send: key Args: args Varargs: varargs => (asts ASTSend clone) initWithMessage: key Args: args Varargs: varargs;
        protected Resend: key Args: args Varargs: varargs => (asts ASTResend clone) initWithMessage: key Args: args Varargs: varargs;
        protected Assign: v To: arg Slot: key => (asts ASTSlotAssignment clone) initWithLHS: arg RHS: v Slot: key;

        protected Return: v Depth: d => (asts ASTReturn clone) initWithValue: v Depth: d;
        protected JumpBack => (asts ASTJumpBack clone) init;

        protected Compound: elements => (asts ASTCompound clone) initWithInstructions: elements;

        protected popN: amount => (
            "
                This is a very ugly implementation,
                which will (hopefully!) change in the future.
            "

            |
                s <- std util newStack,
                v <- std util newVector
            |
            1 to: amount do: [ s push: (stack pop) ].
            1 to: amount do: [ v add: (s pop) ].
          ^ v asArray
        );

        protected OnStack: expr => stack push: expr;
        protected OnAST: expr => (expr isAtomic not) if: [ compound add: expr ];
        protected Accu: expr => (
            cleared not -> [ OnAST: accu ].
            accu <- expr.
            cleared <- false.
        );

        visitNoop: instr => UnknownInstruction;
        visitConst: instr => Accu: (builder Constant: instr constant);
        visitPush: instr => ( OnStack: GetAccu. cleared <- true );
        visitPop: instr => Accu: stack pop;
        visitLoadLocal: instr => Accu: (builder Register: instr register);
        visitStoreLocal: instr => (
            OnAST: (builder Move: GetAccu To: (builder Register: instr register)).
            cleared <- true.
        );
        visitLoadLexical: instr => Accu: (builder Register: instr register Depth: instr depth);
        visitStoreLexical: instr => (
            OnAST: (builder Move: GetAccu To: (builder Register: instr register Depth: instr depth)).
            cleared <- true.
        );
        visitBuiltin: instr => OnStack: (builder Builtin: instr key Args: (popN: (instr args)) Varargs: instr varargs);
        visitSend: instr => OnStack: (builder Send: instr key Args: (popN: (instr args)) Varargs: instr varargs);
        visitResend: instr => OnStack: (builder Resend: instr key Args: (popN: (instr args)) Varargs: instr varargs);
        visitAssign: instr => ( | v <- stack pop | OnStack: (builder Assign: v To: stack pop Slot: instr key));
        visitReturn: instr => OnAST: (builder Return: stack pop Depth: instr depth);
        visitClosure: instr => Accu: (builder Code: instr code);
        visitJump: instr => OnAST: (builder JumpBack);

        buildAST => (
            |
                expr  <- function instructions,
            |
            
            [ :break |
                expr accept: self;
                expr next yes: [ :v | expr <- v ] no: [ break value ].
            ] repeatWithBreak.
          ^ builder Compound: compound
        );
    };
}
