
{
    static with inherited _ = std Module;

    own ast = (here / 'ast' / 'nodes.eco') importIn: self;
    own instructions = (here / 'instructions' / '_.eco') importIn: self;

    own InstructionGraphBuilder = (here / 'InstructionGraphBuilder.eco') importIn: self;
    own InstructionVisitor = (here / 'InstructionVisitor.eco') importIn: self;

    own ASTBuilder = (here / 'ASTBuilder.eco') importIn: self;

    own Disassembler = (here / 'Disassembler.eco') importIn: self;

    own DisassembledFunction = {
        static with inherited _ = std Clonable;
        protected optimizer = $;

        instructions;

        with inherited trait = {
            initWithInstructions: _instructions => (
                instructions <- _instructions.
              ^ self
            );

            ast => ((optimizer ASTBuilder clone) initWithFunction: self) buildAST;

            writeOn: w => w << 'a disassembled function';
        };
    };
    

    Print(f, indent) => (
        | expr <- f instructions |
        [ :break |
            1 to: indent do: [ std io out << '    ' ].
            (std io out << expr) newline commit.
            expr withSubCode: [ :c | Print(c, indent + 1) ].
            expr next yes: [ :v | expr <- v ] no: [ break value ].
        ] repeatWithBreak.
      ^ f
    );

    DisassembleCodeObject: code => (Disassembler clone initWithCode: code) disassemble;

    Disassemble: code => DisassembleCodeObject: code;

    Disassemble: name In: object => (
        Disassemble: ((std reflect Mirror: object)
                        ~ slot: name
                        ~ slotValue).
    );

    Print: name In: object => Print(Disassemble: name In: object, 0);
}
