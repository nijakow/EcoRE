
{
    static with inherited _ = std Module;

    own instructions = {
        static with inherited _ = std Module;

        own StopInstruction = {
            static with inherited _ = std Singleton;

            next => self;

            writeOn: w => w << 'a stop bytecode pseudo-instruction';
        },

        own ByteCodeInstruction = {
            static with inherited _ = std Clonable;
            private instructions = $;

            next;

            with inherited trait = {
                init => next: (instructions StopInstruction new);

                next: v => next <- v;

                writeOn: w => w << 'a bytecode instruction';
            };
        },

        own NoopInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            with inherited trait = {
                init => (
                    super init.
                  ^ self
                );

                writeOn: w => w << 'a noop bytecode instruction';
            };
        },

        own LoadConstantInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            register, constant;

            with inherited trait = {
                initWithRegister: _register Constant: _constant => (
                    super init.
                    register <- _register.
                    constant <- _constant.
                  ^ self
                );

                writeOn: w => w << 'a load constant bytecode instruction';
            };
        },

        own PushConstantInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            constant;

            with inherited trait = {
                initWithConstant: _constant => (
                    super init.
                    constant <- _constant.
                  ^ self
                );

                writeOn: w => w << 'a push constant bytecode instruction';
            };
        },

        own PushInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            register;

            with inherited trait = {
                initWithRegister: _register => (
                    super init.
                    register <- _register.
                  ^ self
                );

                writeOn: w => w << 'a push bytecode instruction';
            };
        },

        own PopInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            register;

            with inherited trait = {
                initWithRegister: _register => (
                    super init.
                    register <- _register.
                  ^ self
                );

                writeOn: w => w << 'a pop bytecode instruction';
            };
        },

        own DropInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            with inherited trait = {
                init => (
                    super init.
                  ^ self
                );

                writeOn: w => w << 'a drop bytecode instruction';
            };
        },

        own DupInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            with inherited trait = {
                init => (
                    super init.
                  ^ self
                );

                writeOn: w => w << 'a dup bytecode instruction';
            };
        },

        own R2RInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            from, to;

            with inherited trait = {
                initWithFrom: _from To: _to => (
                    super init.
                    from <- _from.
                    to   <- _to.
                  ^ self
                );

                writeOn: w => w << 'a register-to-register bytecode instruction';
            };
        },

        own R2LInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            from, to, depth;

            with inherited trait = {
                initWithFrom: _from To: _to Depth: _depth => (
                    super init.
                    from  <- _from.
                    to    <- _to.
                    depth <- _depth.
                  ^ self
                );

                writeOn: w => w << 'a register-to-lexical bytecode instruction';
            };
        },

        own L2RInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            from, depth, to;

            with inherited trait = {
                initWithFrom: _from Depth: _depth To: _to => (
                    super init.
                    from  <- _from.
                    depth <- _depth.
                    to    <- _to.
                  ^ self
                );

                writeOn: w => w << 'a lexical-to-register bytecode instruction';
            };
        },

        own BuiltinInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            key, args, varargs;

            with inherited trait = {
                initWithKey: _key Args: _args Varargs: _varargs => (
                    super init.
                    key     <- _key.
                    args    <- _args.
                    varargs <- _varargs.
                  ^ self
                );
                initWithKey: key Args: args => initWithKey: key Args: args Varargs: false;
                initWithArgs: args Key: key => initWithKey: key Args: args;
                initWithArgs: args Key: key Varargs: varargs => initWithKey: key Args: args Varargs: varargs;

                writeOn: w => w << 'a call-builtin bytecode instruction';
            };
        },

        own SendInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            key, args, varargs;

            with inherited trait = {
                initWithKey: _key Args: _args Varargs: _varargs => (
                    super init.
                    key     <- _key.
                    args    <- _args.
                    varargs <- _varargs.
                  ^ self
                );
                initWithKey: key Args: args => initWithKey: key Args: args Varargs: false;
                initWithArgs: args Key: key => initWithKey: key Args: args;
                initWithArgs: args Key: key Varargs: varargs => initWithKey: key Args: args Varargs: varargs;

                writeOn: w => w << 'a send bytecode instruction';
            };
        },

        own AssignInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            key;

            with inherited trait = {
                initWithKey: _key => (
                    super init.
                    key <- _key.
                  ^ self
                );

                writeOn: w => w << 'an assign bytecode instruction';
            };
        },

        own ReturnInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            depth;

            with inherited trait = {
                initWithDepth: _depth => (
                    super init.
                    depth <- _depth.
                  ^ self
                );
                init => initWithDepth: 0;

                writeOn: w => w << 'a return bytecode instruction';
            };
        },

        own ClosureInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            register, code;

            with inherited trait = {
                initWithRegister: _register Code: _code => (
                    super init.
                    register <- _register.
                    code     <- _code.
                  ^ self
                );

                writeOn: w => w << 'a closure bytecode instruction';
            };
        },

        own JumpInstruction = {
            static with inherited _ = std Clonable;
            with inherited own super = $ ByteCodeInstruction;

            target;

            with inherited trait = {
                initWithTarget: _target => (
                    super init.
                    target <- _target.
                  ^ self
                );

                writeOn: w => w << 'a jump bytecode instruction';
            };
        },
    },

    own InstructionGraphBuilder = {
        static with inherited _ = std Clonable;
        private optimizer = $;

        private first,
        private last;

        with inherited trait = {
            init => (
                | node <- optimizer instructions NoopInstruction |
                first <- node.
                last  <- node.
              ^ self
            );
        };

        add: instruction => (
            last next: instruction.
            last <- instruction.
          ^ self
        );

        commit => first;

        writeOn: w => w << 'an instruction graph builder';
    },

    own Disassembler = {
        static with inherited parent = std Clonable;
        private optimizer = $;
        private instructions = $ instructions;

        private bytecodes,
        private it,
        private constants,
        private closures;

        with inherited trait = {
            initWithBytecodes: _bytecodes Constants: _constants Closures: _closures => (
                bytecodes <- _bytecodes.
                constants <- _constants.
                closures  <- _closures.
                it        <- _bytecodes iterator.
              ^ self
            );
            initWithCode: _code => initWithBytecodes: (_code bytecodes) Constants: (_code constants) Closures: (_code closures);

            protected nextU8 => (it next) bitAnd: 255;
            protected nextU16 => (
                | v <- nextU8 |
                v <- v bitOr: (nextU8 rshift: 8).
              ^ v
            );

            protected nextConstant => constants at: nextU16;
            protected nextCode => closures at: nextU16;

            disassemble => (
                | builder <- (optimizer InstructionGraphBuilder) new |
                [ it hasNext ] while: [
                    | opcode <- nextU8 |
                    (opcode == lang eco bytecodes NOOP)  -> [ builder add: ((instructions NoopInstruction) clone init) ].
                    (opcode == lang eco bytecodes CONST) -> [ builder add: ((instructions LoadConstantInstruction) clone initWithRegister: nextU8 Constant: nextConstant) ].
                    (opcode == lang eco bytecodes PUSHC) -> [ builder add: ((instructions PushConstantInstruction) clone initWithConstant: nextConstant) ].
                    (opcode == lang eco bytecodes PUSH)  -> [ builder add: ((instructions PushInstruction) clone initWithRegister: nextU8) ].
                    (opcode == lang eco bytecodes POP)   -> [ builder add: ((instructions PopInstruction) clone initWithRegister: nextU8) ].
                    (opcode == lang eco bytecodes DROP)  -> [ builder add: ((instructions DropInstruction) clone init) ].
                    (opcode == lang eco bytecodes DUP)   -> [ builder add: ((instructions DupInstruction) clone init) ].
                    (opcode == lang eco bytecodes R2R)   -> [ builder add: ((instructions R2RInstruction) clone initWithTo: nextU8 From: nextU8) ].
                    (opcode == lang eco bytecodes R2L)   -> [ builder add: ((instructions R2LInstruction) clone initWithTo: nextU8 Depth: nextU8 From: nextU8) ].
                    (opcode == lang eco bytecodes L2R)   -> [ builder add: ((instructions L2RInstruction) clone initWithTo: nextU8 From: nextU8 Depth: nextU8) ].
                    (opcode == lang eco bytecodes BUILTIN) -> [
                        | args <- nextU8, key <- nextConstant |
                        (#'ecosphere.ecore.flow.reset' == key)
                              if: [ builder add: ((instructions JumpInstruction) clone initWithTarget: builder commit) ]
                            else: [ builder add: ((instructions BuiltinInstruction) clone initWithArgs: args Key: key) ]
                    ].
                    (opcode == lang eco bytecodes BUILTINV) -> [ builder add: ((instructions BuiltinInstruction) clone initWithArgs: nextU8 Key: nextConstant Varargs: true) ].
                    (opcode == lang eco bytecodes SEND) -> [ builder add: ((instructions SendInstruction) clone initWithArgs: nextU8 Key: nextConstant) ].
                    (opcode == lang eco bytecodes SENDV) -> [ builder add: ((instructions SendInstruction) clone initWithArgs: nextU8 Key: nextConstant Varargs: true) ].
                    (opcode == lang eco bytecodes ASSIGN) -> [ builder add: ((instructions AssignInstruction) clone initWithKey: nextConstant) ].
                    (opcode == lang eco bytecodes RETURN) -> [ builder add: ((instructions ReturnInstruction) clone initWithDepth: nextU8) ].
                    (opcode == lang eco bytecodes CLOSURE) -> [ builder add: ((instructions ClosureInstruction) clone initWithRegister: nextU8 Code: nextCode) ].
                ].
              ^ builder commit
            );

            writeOn: w => w << 'a disassembler';
        };
    },

    Disassemble: code => (Disassembler clone initWithCode: code) disassemble;
}
