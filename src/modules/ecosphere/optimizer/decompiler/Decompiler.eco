{
    static with inherited _ = std Clonable;
    protected decompiler = $;
    with inherited visitor = $ optimizer asm InstructionVisitor;

    protected function,
    protected stack,
    protected bindings,
    protected accu,
    protected cleared,
    protected compound;

    visitInstruction: instr => (std io out << 'Visiting ' << instr) newline;

    with inherited trait = {
        protected RegisterComparator = {
            static with inherited _ = std Singleton;

            value(a, b) => a equalsRegister: b;
        };

        initWithFunction: _function => (
            function <- _function.
            stack    <- std util newStack.
            bindings <- std util newAlistWithComparator: RegisterComparator;
            accu     <- builder Register: 0.
            cleared  <- false.
            compound <- std util newVector.
          ^ self
        );

        protected optimizer => decompiler optimizer;
        protected ast => optimizer ast;
        protected builder => optimizer ast builder;

        protected UnknownInstruction => 42;

        protected GetRegister: i => GetRegister: i Depth: 0;
        protected GetRegister: i Depth: d => (
            | r <- (Register: i Depth: d) |
            bindings at: r
              ~ yes: [ :v | ^ v ]
                 no: [      ^ r ]
        );

        protected GetAccu => accu;

        protected Move: from To: to => (
            | v <- builder Assign: from To: to |
            (to depth != 0) -> [ ^ v ].
            bindings at: to put: v.
          ^ v
        );

        protected popN: amount => (
            "
                This is a very ugly implementation,
                which will (hopefully!) change in the future.
            "

            |
                s <- std util newStack,
                v <- std util newVector
            |
            1 to: amount do: [ s push: (stack pop) ].
            1 to: amount do: [ v add: (s pop) ].
          ^ v asArray
        );

        protected OnStack: expr => stack push: expr;
        protected OnAST: expr => (expr isAtomic not) if: [ compound add: expr ];
        protected Accu: expr => (
            cleared not -> [ OnAST: accu ].
            accu <- expr.
            cleared <- false.
        );

        visitNoop: instr => UnknownInstruction;
        visitConst: instr => Accu: (builder Constant: instr constant);
        visitPush: instr => ( OnStack: GetAccu. cleared <- true );
        visitPop: instr => Accu: stack pop;
        visitLoadLocal: instr => Accu: (builder Register: instr register);
        visitStoreLocal: instr => (
            OnAST: (Move: GetAccu To: (builder Register: instr register)).
            cleared <- true.
        );
        visitLoadLexical: instr => Accu: (builder Register: instr register Depth: instr depth);
        visitStoreLexical: instr => (
            OnAST: (Move: GetAccu To: (builder Register: instr register Depth: instr depth)).
            cleared <- true.
        );
        visitBuiltin: instr => ( Accu: (builder Register: 0). OnStack: (builder Builtin: instr key Args: (popN: (instr args)) Varargs: instr varargs) );
        visitSend: instr => OnStack: (builder Send: instr key Args: (popN: (instr args)) Varargs: instr varargs);
        visitResend: instr => OnStack: (builder Resend: instr key Args: (popN: (instr args)) Varargs: instr varargs);
        visitAssign: instr => ( | v <- stack pop | OnStack: (builder Assign: v To: stack pop Slot: instr key));
        visitReturn: instr => OnAST: (builder Return: stack pop Depth: instr depth);
        visitClosure: instr => Accu: (builder Block: (((decompiler Decompiler) clone) initWithFunction: instr code ~ buildAST));

        buildAST => (
            |
                expr  <- function instructions,
            |
            
            [ :break |
                expr accept: self;
                expr next yes: [ :v | expr <- v ] no: [ break value ].
            ] repeatWithBreak.
          ^ (compound size == 1) if: [ compound at: 0 ] else: [ builder Compound: compound ]
        );
    };
}
