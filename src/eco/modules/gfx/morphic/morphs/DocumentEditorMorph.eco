{
    static with inherited _ = std Clonable;
    with inherited own Morph = $ Morph;

    protected caret,
    protected lineCache,
    protected program;

    with inherited trait = {
        static with inherited _ = std Trait;

        own mod = {
            static with inherited _ = std Module;

            own ElementTrait = {
                static with inherited _ = std Trait;

                render: renderer => self;

                ifPoint: p InBoundsDo: block => self;
            };

            own ChangeColorElement = {
                static with inherited _ = std Clonable;
                with inherited ElementTrait = $ ElementTrait;

                protected r,
                protected g,
                protected b;

                with inherited trait = {
                    static with inherited _ = std Trait;

                    initR: _r G: _g B: _b => (
                        r <- _r.
                        g <- _g.
                        b <- _b.
                      ^ self
                    );

                    initColor: color => initR: (color r) G: (color g) B: (color b);

                    render: renderer => (
                        renderer setR: r G: g B: b.
                      ^ self
                    );
                };
            };

            own CharacterElement = {
                static with inherited _ = std Clonable;
                with inherited ElementTrait = $ ElementTrait;

                protected xpos,
                protected ypos,
                protected width,
                protected height,
                protected content,
                offset;

                with inherited trait = {
                    static with inherited _ = std Trait;

                    initWithContent: _content Offset: _offset X: _xpos Y: _ypos W: _width H: _height => (
                        content <- _content.
                        xpos    <- _xpos.
                        ypos    <- _ypos.
                        width   <- _width.
                        height  <- _height.
                        offset  <- _offset.
                      ^ self
                    );

                    render: renderer => (
                        renderer drawChar: content X: xpos Y: ypos.
                      ^ self
                    );

                    ifPoint: p InBoundsDo: block => (
                        (p x < xpos) if: [ ^ self ].
                        (p x > (xpos + width)) if: [ ^ self ].
                        (p y < ypos) if: [ ^ self ].
                        (p y > (ypos + height)) if: [ ^ self ].
                      ^ block value(self)
                    );
                };
            };

            own ReferenceElement = {
                static with inherited _ = std Clonable;
                with inherited ElementTrait = $ ElementTrait;

                protected xpos,
                protected ypos,
                protected width,
                protected height,
                offset;

                with inherited trait = {
                    static with inherited _ = std Trait;

                    initWithOffset: _offset X: _xpos Y: _ypos W: _width H: _height => (
                        xpos   <- _xpos.
                        ypos   <- _ypos.
                        width  <- _width.
                        height <- _height.
                        offset <- _offset.
                      ^ self
                    );

                    render: renderer => (
                        renderer setR: 131 G: 240 B: 244.
                        renderer fillRectX: (xpos + 4) Y: (ypos + 4) W: (width - 8) H: (height - 8).
                        renderer setColor: (renderer theme textColor).
                      ^ self
                    );

                    ifPoint: p InBoundsDo: block => (
                        (p x < xpos) if: [ ^ self ].
                        (p x > (xpos + width)) if: [ ^ self ].
                        (p y < ypos) if: [ ^ self ].
                        (p y > (ypos + height)) if: [ ^ self ].
                      ^ block value(self)
                    );
                };
            };

            own CursorElement = {
                static with inherited _ = std Clonable;
                with inherited ElementTrait = $ ElementTrait;

                protected xpos,
                protected ypos,
                protected w,
                protected h;

                with inherited trait = {
                    static with inherited _ = std Trait;

                    initWithX: _xpos Y: _ypos W: _w H: _h => (
                        xpos <- _xpos.
                        ypos <- _ypos.
                        w    <- _w.
                        h    <- _h.
                      ^ self
                    );

                    render: renderer => (
                        renderer setR: 255 G: 0 B: 0.
                        renderer drawRectX: xpos Y: ypos W: w H: h.
                        renderer setColor: (renderer theme textColor).
                      ^ self
                    );
                };
            };

            own DocumentProgram = {
                static with inherited _ = std Clonable;

                protected elements,
                protected lineOffsets;

                minWidth <- 0,
                minHeight <- 0;

                with inherited trait = {
                    static with inherited _ = std Trait;

                    init => (
                        elements    <- std util newVector.
                        lineOffsets <- std util newVector.
                      ^ self
                    );

                    minWidth: mw => minWidth <- mw;
                    minHeight: mh => minHeight <- mh;

                    addElement: element => (
                        elements add: element.
                      ^ self
                    );

                    addLineOffset: offset => (
                        lineOffsets add: offset.
                      ^ self
                    );

                    findLineForYOffset: offset => (
                        | line <- (lineOffsets size) - 1 |
                        
                        lineOffsets reverseDo: [ :lineOffset |
                            (lineOffset <= offset) if: [ ^ line ].
                            line <- line - 1.
                        ].

                      ^ 0
                    );

                    render: renderer => (
                        elements do: [ :element |
                            element render: renderer
                        ]
                    );

                    findElementAtPoint: point => (
                        elements do: [ :element |
                            element ifPoint: point InBoundsDo: [ :e | ^ Yes: e ]
                        ].
                      ^ No
                    );
                };
            };
        };

        initWithDocument: _document => (
            $(Morph) init.
            caret     <- _document newCaret.
            lineCache <- std util newVector.
            program   <- No.
            refreshLineCache.
          ^ self
        );

        document => caret document;

        refreshLineCache => (
            lineCache clear.
            (document lines) into: lineCache.
          ^ self
        );

        repositionCursor => (
            caret reposition.
          ^ self
        );

        documentChanged => (
            program <- No.
            refreshLineCache.
            repositionCursor.
            layoutChanged.
            renderDirty.
          ^ self
        );

        protected buildProgram(renderer) => (
            | prog <- (mod DocumentProgram) new |

            prog addElement: ((mod ChangeColorElement) clone initColor: (renderer theme textColor)).

            | cx <- caret x, cy <- caret y |

            |
                offset <- 0, 
                x      <- 0,
                y      <- 0,
                xOff   <- 0,
                yOff   <- 0,
                minWidth  <- 0,
                minHeight <- 0,
            |
            lineCache do: [ :line |
                | m <- renderer charHeight: ($'newline') |
                x    <- 0.
                xOff <- 0.

                prog addLineOffset: yOff.

                line do: [ :item |
                    | dx <- 0, dy <- 0 |

                    item ifCharacter: [ :c |
                        |
                            cw <- renderer charWidth: (c content),
                            ch <- renderer charHeight: (c content)
                        |
                        prog addElement: ((mod CharacterElement) clone initWithContent: (c content) Offset: offset X: xOff Y: yOff W: cw H: ch).
                        dx <- cw.
                        dy <- ch. 
                    ].
                    item ifReference: [ :r |
                        prog addElement: ((mod ReferenceElement) clone initWithOffset: offset X: xOff Y: yOff W: 16 H: 16).
                        dx <- 16.
                        dy <- 16.
                    ].

                    "Draw the caret"
                    ([x == cx] and: [y == cy]) if: [
                        prog addElement: ((mod CursorElement) clone initWithX: xOff Y: yOff W: dx H: dy).
                    ].

                    xOff <- xOff + dx.
                    m    <- m max: dy.

                    x      <- x      + 1.
                    offset <- offset + 1.
                ].

                "Draw the if it is at the end of the line"
                ([x == cx] and: [y == cy]) if: [
                    prog addElement: ((mod CursorElement) clone initWithX: xOff Y: yOff W: 1 H: m).
                ].

                yOff   <- yOff + m.

                y      <- y      + 1.
                offset <- offset + 1.  "A line usually ends with a newline -- this is a little assumption-based hack"

                minWidth  <- minWidth  max: xOff.
                minHeight <- minHeight + m.
            ].

            prog minWidth: minWidth.
            prog minHeight: minHeight.

            program <- Yes: prog.

          ^ self
        );

        baseMinWidth => (
            program yes: [ :prog | prog minWidth ]
                     no: [         0             ]
        );

        baseMinHeight => (
            program yes: [ :prog | prog minHeight ]
                     no: [         0              ]
        );

        renderImplOn: renderer => (
            program no: [ buildProgram(renderer) ].
            (program yes) render: renderer.
            $(Morph) renderImplOn: renderer.
        );

        protected moveCaretTo: offset => (
            caret moveTo: offset.
            program <- No.
            renderDirty.
          ^ self
        );

        protected moveCaretToX: x Y: y => (
            ([y < 0] or: [y >= lineCache size])
                if: [ ^ self ].
            | line <- lineCache at: y |
            moveCaretTo: ((line start + (x max: 0)) min: (line end)).
          ^ self
        );

        protected insertText: text => (
            caret insertText: text.
            documentChanged.
          ^ self
        );

        protected insertNewline => (
            insertText: '\n'.
            documentChanged.
          ^ self
        );

        protected insertReference: object => (
            caret insertReference: object.
            documentChanged.
          ^ self
        );

        protected backspace => (
            caret backspace.
            documentChanged.
          ^ self
        );

        clear => (
            document clear.
            documentChanged.
          ^ self
        );

        handleKey: key At: point HandMorph: hand => (
            key ifLeft:  [ moveCaretToX: ((caret x) - 1) Y: (caret y). ^ true ].
            key ifRight: [ moveCaretToX: ((caret x) + 1) Y: (caret y). ^ true ].
            key ifUp:    [ moveCaretToX: (caret x) Y: ((caret y) - 1). ^ true ].
            key ifDown:  [ moveCaretToX: (caret x) Y: ((caret y) + 1). ^ true ].

            key ifBackspace: [ backspace.                    ^ true ].
            key ifEnter:     [ insertNewline.                ^ true ].
            key ifHome:      [ moveCaretToX: 0 Y: (caret y). ^ true ].
            "key ifEnd:       [ moveCaretToX: ((lines at: (caret y)) text size) Y: (caret y). ^ true ]."
            key ifTab:       [ insertText: ' ' * (4 - ((caret x) mod: 4)).                   ^ true ].


            key ifPaste: [
                (hand clipboard) yes: [ :v | insertReference: v ].
              ^ true
            ].

            key keyText yes: [ :text |
                insertText: text.
              ^ true
            ].

          ^ false
        );

        protected moveCursorToPixel: pixel => (
            program yes: [ :prog |
                (prog findElementAtPoint: pixel)
                    yes: [ :element | moveCaretTo: (element offset). ^ self ].
                | lineNumber <- (prog findLineForYOffset: (pixel y)) |
                moveCaretToX: 100000 Y: lineNumber. "TOOD: Properly go to end of line"
            ].
        );

        handleClick: click At: point HandMorph: hand => (
            moveCursorToPixel: point.
          ^ true
        );

        writeOn: w => w << 'a document editor morph';
    };
}
