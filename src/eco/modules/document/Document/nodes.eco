{
    "
        Nodes Module
    "
    static with inherited _ = std Module;

    own SnipTrait = {
        static with inherited _ = std Trait;
        with inherited SizedIndexable = std util traits SizedIndexable;

        protected module = $;

        protected indexOutOfBoundsError => 'Index out of bounds.' throw;

        ifItemSnip: block => self;
        ifStringSnip: block => self;
        ifCompoundSnip: block => self;

        at: index => indexOutOfBoundsError;
        size => 0;
        splitAt: index => indexOutOfBoundsError;

        isAtomicSnip => true;

        insertSnip: snip at: index => (
            (index == 0) if: [ ^ module MakeCompoundSnip(snip, self) ].
            (index == self size) if: [ ^ module MakeCompoundSnip(self, snip) ].
            indexOutOfBoundsError
        );

        appendSnip: snip => insertSnip: snip at: size;

        removeSnipAt: index => indexOutOfBoundsError;

        tryJoinWith: other => No;

        compress => self;

        nesting => 0;

        writeOn: w => w << 'a snip';
    };

    own ItemSnip = {
        static with inherited _ = std Clonable;
        with inherited SnipTrait = $ SnipTrait;

        item;

        with inherited trait = {
            static with inherited _ = std Trait;

            initWithItem: _item => (
                item <- _item;
              ^ self
            );

            ifItemSnip: block => block value(self);

            at: index => (
                (index == 0) if: [ ^ item ].
                indexOutOfBoundsError
            );
            size => 1;

            tryJoinWith: other => (
                item ifNewline: [ ^ No ].
                other ifItemSnip: [ :otherItemSnip |
                    | otherItem <- otherItemSnip item |
                    item ifNewline: [ ^ No ].
                    otherItem ifCharacter: [ :otherCharacter |
                        item ifCharacter: [ :character |
                            | sw <- (std io StringWriter) new |
                            sw << character content.
                            sw << otherCharacter content.
                          ^ Yes: (module StringSnip: (sw build))
                        ].
                    ].
                ].
                other ifStringSnip: [ :otherStringSnip |
                    item ifCharacter: [ :character |
                        | sw <- (std io StringWriter) new |
                        sw << character content.
                        sw << otherStringSnip content.
                      ^ Yes: (module StringSnip: (sw build))
                    ].
                ].
              ^ No
            );

            writeOn: w => w << 'an item snip(' << item << ')';
        };
    };

    ItemSnip: item => ItemSnip clone initWithItem: item;


    own StringSnip = {
        static with inherited _ = std Clonable;
        with inherited SnipTrait = $ SnipTrait;

        content;

        with inherited trait = {
            static with inherited _ = std Trait;

            initWithContent: _content => (
                content <- _content;
              ^ self
            );

            ifStringSnip: block => block value(self);

            at: index => module CharacterItem: (content at: index);
            size => content size;

            splitAt: index => (
                (module StringSnip: (content substringTo: index))
              & (module StringSnip: (content substringFrom: index))
            );

            insertSnip: snip at: index => (
                ([index > 0] and: [index < self size]) if: [
                    ^ module MakeCompoundSnip(
                        (module StringSnip: (content substringTo: index)),
                        snip,
                        (module StringSnip: (content substringFrom: index))
                    )
                ].
              ^ $(SnipTrait) insertSnip: snip at: index
            );

            tryJoinWith: other => (
                other ifItemSnip: [ :otherItemSnip |
                    | item <- otherItemSnip item |
                    item ifNewline: [ ^ No ].
                    item ifCharacter: [ :character |
                        | sw <- (std io StringWriter) new |
                        sw << content.
                        sw << character content.
                      ^ Yes: (module StringSnip: (sw build))
                    ].
                ].
                other ifStringSnip: [ :otherStringSnip |
                  ^ Yes: (module StringSnip: (content + otherStringSnip content))
                ].
              ^ No
            );

            writeOn: w => w << 'a string snip(' << content << ')';
        };
    };

    StringSnip: string => StringSnip clone initWithContent: string;


    own CompoundSnip = {
        static with inherited _ = std Clonable;
        with inherited SnipTrait = $ SnipTrait;

        snips, size, nesting;

        with inherited trait = {
            static with inherited _ = std Trait;

            initWithSnips: _snips => (
                snips <- _snips.
                | csize <- 0, cnesting <- 0 |
                snips do: [ :snip |
                    csize    <- (csize + snip size).
                    cnesting <- (cnesting max: snip nesting)
                ].
                size    <- csize.
                nesting <- (cnesting + 1).
              ^ self
            );

            ifCompoundSnip: block => block value(self);

            isAtomicSnip => false;

            at: index => (
                | i <- 0 |
                snips do: [ :snip |
                    | size <- snip size |
                    (index < (i + size)) if: [ ^ snip at: (index - i) ];
                    i <- (i + size)
                ].
                indexOutOfBoundsError
            );

            insertSnip: snip at: index => (
                |
                    i <- 0,
                    newSnips <- std util newVector,
                    done <- false
                |
                snips do: [ :oldSnip |
                    | size <- oldSnip size |
                    ([done not] and: [index < (i + size)]) if: [
                        ([oldSnip isAtomicSnip] and: [[oldSnip size == 1] and: [index == i]])
                              if: [ newSnips add: snip. newSnips add: oldSnip.                ]
                            else: [ newSnips add: (oldSnip insertSnip: snip at: (index - i)). ].
                        done <- true.
                    ] else: [
                        newSnips add: oldSnip.
                    ].
                    i <- (i + size)
                ].
                (done not) if: [ newSnips add: snip ].
              ^ module MakeOptimizedCompoundSnipFromArray(newSnips)
            );

            removeSnipAt: index => (
                |
                    i <- 0,
                    newSnips <- std util newVector,
                    done <- false
                |
                snips do: [ :oldSnip |
                    | size <- oldSnip size |
                    ([done not] and: [index < (i + size)]) if: [
                        (oldSnip size > 1) if: [
                            newSnips add: (oldSnip removeSnipAt: (index - i)).
                        ].
                        done <- true
                    ] else: [
                        newSnips add: oldSnip
                    ].
                    i <- (i + size)
                ].
              ^ module CompoundSnip: newSnips
            );

            tryJoinWith: other => (
                other ifCompoundSnip: [ :otherCompoundSnip |
                    | newSnips <- std util newVector |
                    snips into: newSnips.
                    otherCompoundSnip snips into: newSnips.
                  ^ Yes: (module CompoundSnip: newSnips)
                ].
              ^ No
            );

            compress => (
                (snips size == 0) if: [ ^ self ].
                (snips size == 1) if: [ ^ (snips at: 0) compress ].

                |
                    newSnips <- std util newVector,
                    current  <- No
                |

                snips do: [ :snip |
                    current yes: [ :c |
                        | r <- c tryJoinWith: snip |
                        r yes: [ :joined | current <- r ]
                           no: [ newSnips add: c. current <- Yes: snip ]
                    ] no: [
                        current <- Yes: snip.
                    ]
                ].

                current yes: [ :c | newSnips add: c ].

              ^ module CompoundSnip: newSnips
            );

            writeOn: w => (
                w << 'a compound snip('.
                snips do: [ :snip | w << snip << ', ' ].
                w << ')'
            );
        };
    };

    CompoundSnip: snips => CompoundSnip clone initWithSnips: snips;
    MakeCompoundSnip(...) => CompoundSnip: (std util newArray(...));
    MakeOptimizedCompoundSnipFromArray(snips) => (
        (snips size == 0) if: [ ^ CompoundSnip: snips ].
        (snips size == 1) if: [ ^ snips at: 0 ].
        (snips size > 8) if: [
            |
                snips1 <- std util newVector,
                snips2 <- std util newVector
            |
            snips do: [ :snip |
                (snips1 size < (snips size / 2))
                      if: [ snips1 add: snip ]
                    else: [ snips2 add: snip ].
            ].
          ^ CompoundSnip: std util newArray(
                MakeOptimizedCompoundSnipFromArray(snips1 asArray),
                MakeOptimizedCompoundSnipFromArray(snips2 asArray)
            )
        ].
      ^ CompoundSnip: snips
    );
    MakeOptimizedCompoundSnip(...) => MakeOptimizedCompoundSnipFromArray(std util newArray(...));


    own ItemTrait = {
        static with inherited _ = std Trait;

        ifCharacter: block => self;
        ifReference: block => self;
        ifNewline: block => self;

        ifChar: block => ifCharacter: [ :c | block value(c content) ];
        ifRef: block => ifReference: [ :r | block value(r content) ];

        writeOn: w => w << 'an item';
    };

    own CharacterItem = {
        static with inherited _ = std Clonable;
        with inherited ItemTrait = $ ItemTrait;

        content;

        with inherited trait = {
            static with inherited _ = std Trait;

            initWithContent: _content => (
                content <- _content;
              ^ self
            );

            ifCharacter: block => block value(self);
            ifNewline: block => (content == $'newline') if: [ block value(self) ] else: [ self ];
        
            writeOn: w => w << 'a character item(' << content << ')';
        };
    };

    CharacterItem: character => CharacterItem clone initWithContent: character;


    own ReferenceItem = {
        static with inherited _ = std Clonable;
        with inherited ItemTrait = $ ItemTrait;

        content;

        with inherited trait = {
            static with inherited _ = std Trait;

            initWithContent: _content => (
                content <- _content;
              ^ self
            );

            ifReference: block => block value(self);

            writeOn: w => w << 'a reference item(' << content << ')';
        };
    };

    ReferenceItem: reference => ReferenceItem clone initWithContent: reference;


    Text: text => StringItem clone initWithContent: text;
    Reference: reference => ReferenceItem clone initWithContent: reference;
}
