
{
    static with inherited _ = std Clonable;

    scope;

    with inherited trait = {
        static with inherited _ = std Trait;
        protected compiler = $package;
        protected ast      = $package optimizer ast;

        protected writer => scope lexicalBase writer;


        protected In: scope => (compiler ScopedCompiler) clone initWithScope: scope;


        initWithScope: _scope => (
            scope <- _scope.
          ^ self
        );


        compileConstant: expr => (
            writer writeConst: (expr constant).
        );

        compileBlock: expr => (
            (In: (scope newLexical)) compile: (expr code).

            writer writeDelayedClosure: $[ :(writer, expr) |
                writer finishWithArgs: (expr args) Varargs: (expr varargs)
            ] bind(writer, expr).
        );

        compileCompound: expr => (
            expr instructions do: [ :instr |
                compile: instr.
            ].
        );
        
        compileReturn: expr => (
            writer writeReturn: (scope lexicalDepth).
        );

        compileScope: expr => (
            "
                TODO: Introduce labels for beginning and end of scope.
            "
            (scope context entryLabel) yes: [ :label | placeJumpLabel: label ].
            compile scope body.
            (scope context exitLabel) yes: [ :label | placeJumpLabel: label ].
        );

        compileBuiltin: expr => (
            expr args do: [ :arg | compile: arg. writer writePush. ].
            expr writeBuiltin: (expr message) Args: (expr args size) Varargs: (expr varargs).
        );

        compileSend: expr => (
            expr args do: [ :arg | compile: arg. writer writePush. ].
            expr writeSend: (expr message) Args: (expr args size) Varargs: (expr varargs).
        );

        compileAssignment: expr => (
            | lhs <- expr lhs, rhs <- expr rhs |

            "TODO: Switch on lhs type, and perform the necessary action."
        );

        compileSlotAssignment: expr => (
            compile: lhs.
            writer writePush.
            compile: rhs.
            writer writeAssign: slot.
        );

        compileJump: expr => (
            "TODO: Forward jump to label"
            compile: (expr returnValue).
            scope lookupLabel: (expr label) ifFound: [ :offset :depth |
                writer writeJumpTo: offset Depth: depth.
            ] ifNotFound: [
                (std sys error) ThrowMessage: 'Unable to find label!'.
            ].
        );

        compileLabel: expr => (
            placeJumpLabel: (expr label).
        );

        compile: expr => (
            Switch: (expr type)
              ~ case: ast types Constant       do: [ compileConstant:       expr ]
              "TODO: ValueRef"
              ~ case: ast types Compound       do: [ compileCompound:       expr ]
              ~ case: ast types Block          do: [ compileBlock:          expr ]
              ~ case: ast types Scope          do: [ compileScope:          expr ]
              ~ case: ast types Builtin        do: [ compileBuiltin:        expr ]
              ~ case: ast types Send           do: [ compileSend:           expr ]
              "TODO: Resend"
              ~ case: ast types Assignment     do: [ compileAssignment:     expr ]
              ~ case: ast types SlotAssignment do: [ compileSlotAssignment: expr ]
              ~ case: ast types Return         do: [ compileReturn:         expr ]
              ~ case: ast types Jump           do: [ compileJump:           expr ]
              ~ case: ast types JumpLabel      do: [ compileLabel:          expr ]
            ~ default: [ (std sys error) ThrowMessage: 'Unable to compile expression: Type not supported' ]
        );

        writeOn: w => w << 'a scoped compiler';
    };
}
