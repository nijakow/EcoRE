
{
    static with inherited _ = std Clonable;

    protected boundedPresentables,
    protected cachedWidth <- 0,
    protected cachedHeight <- 0;

    with inherited trait = {
        static with inherited _ = std Trait;
        protected presentation = $package;
        protected geometry => (presentation app) math geometry;

        init => (
            boundedPresentables <- std util newVector.
          ^ self
        );

        minWidth => cachedWidth;
        minHeight => cachedHeight;

        presentObject: object Bounds: bounds Presentation: presentation => (
          ^ presentPresentableObject: (presentation associateWith: object) Bounds: bounds
        );

        presentPresentableObject: object Bounds: bounds => (
            boundedPresentables add: (presentation PresentedObject clone initWithPresentableObject: object Bounds: bounds).
            cachedWidth  <- cachedWidth max: (bounds x + bounds w).
            cachedHeight <- cachedHeight max: (bounds y + bounds h). 
          ^ self
        );

        presentPresentableObject: object At: offset => (
            presentPresentableObject: object Bounds: (geometry rectangle Origin: offset W: object minWidth H: object minHeight).
          ^ self
        );

        presentPresentableObject: object => (
            presentPresentableObject: object At: (geometry point X: 0 Y: 0).
          ^ self
        );

        boundedPresentableObjectsDo: block => (
            boundedPresentables do: [ :each | block value(each) ].
          ^ self
        );

        boundedPresentableObjectsAt: offset Do: block => (
            boundedPresentables do: [ :each |
                (each bounds containsPoint: offset) if: [ block value(each) ].
            ].
          ^ self
        );

        renderOn: renderer => (
            boundedPresentables do: [ :each |
                (each presentableObject) renderOn: renderer Bounds: (each bounds)
            ].
        );

        renderOn: renderer MousePos: mousePos => (
            renderOn: renderer.

            renderer setColor: (renderer theme lineColor).

            boundedPresentableObjectsAt: mousePos Do: [ :each |
                renderer drawRect: each bounds.
            ].
        );

        writeOn: w => w << 'a presenter';
    };
}
