
{
    static with inherited _ = std Module;
    protected libpython <- $package;

    own PyObject = {
        static with inherited _ = std Clonable;

        ptr;

        with inherited trait = {
            static with inherited _ = std Trait;
            protected libpython <- $package;

            initWithPtr: _ptr => (
                ptr <- _ptr.
                std reflect EnableFinalization: self.
              ^ self
            );

            incref => (
                libpython funcs IncRef: ptr.
              ^ self
            );

            decref => (
                (libpython lib Py_DecRef yes) value(ptr).
              ^ self
            );

            pull => self;

            finalize => decref;

            writeOn: w => w << 'a PyObject';
        };
    };

    own PyNone = {
        static with inherited _ = std Clonable;
        with inherited own PyObject = $ PyObject;

        with inherited trait = {
            static with inherited _ = std Trait;
            
            initWithPtr: _ptr => (
                $(PyObject) initWithPtr: _ptr.
              ^ self
            );

            writeOn: w => w << 'PyNone';
        };
    };

    own PyType = {
        static with inherited _ = std Clonable;
        with inherited own PyObject = $ PyObject;

        with inherited trait = {
            static with inherited _ = std Trait;
            
            initWithPtr: _ptr => (
                $(PyObject) initWithPtr: _ptr.
              ^ self
            );

            typecheck: obj => (libpython funcs TypeCheck: (obj ptr) Against: ptr);

            writeOn: w => w << 'a PyType';
        };
    };

    own PyModule = {
        static with inherited _ = std Clonable;
        with inherited own PyObject = $ PyObject;

        with inherited trait = {
            static with inherited _ = std Trait;
            
            initWithPtr: _ptr => (
                $(PyObject) initWithPtr: _ptr.
              ^ self
            );

            writeOn: w => w << 'a PyModule';
        };
    };

    own PyUnicode = {
        static with inherited _ = std Clonable;
        with inherited own PyObject = $ PyObject;

        with inherited trait = {
            static with inherited _ = std Trait;
            
            initWithPtr: _ptr => (
                $(PyObject) initWithPtr: _ptr.
              ^ self
            );

            pull => (libpython funcs UnicodeGrabString: ptr);

            writeOn: w => w << 'a PyUnicode';
        };
    };

    Object: ptr => (
        (libpython funcs IsNone: ptr) if: [ ^ PyNone ].
        (libpython funcs IsType: ptr) if: [ ^ (PyType clone) initWithPtr: ptr ].
        (libpython funcs IsModule: ptr) if: [ ^ (PyModule clone) initWithPtr: ptr ].
        (libpython funcs IsUnicode: ptr) if: [ ^ (PyUnicode clone) initWithPtr: ptr ].
      ^ (PyObject clone) initWithPtr: ptr
    );

    From: ecoobj => (
        (ecoobj isString) if: [ ^ Object: (libpython funcs NewUnicodeFromEcoString: ecoobj) ].
        'Can not convert Eco object to Python object!' throw.
    );


    Init => (
        PyNone initWithPtr: (libpython lib Py_None yes).
      ^ self
    );
}
