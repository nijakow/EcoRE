
{
    static with inherited _ = std Module;
    with app <- $package;

    own morphs = {
        static with inherited _ = std Module;

        own ModulePresentationMorph = {
            static with inherited _ = std Clonable;
            static with inherited own Morph = (($package gfx morphic) morphs) Morph;

            with inherited trait = {
                static with inherited _ = std Trait;

                init => (
                    $(Morph) initWithManyChildren.
                  ^ self
                );

                renderOn: renderer => (
                    renderer setColor: (renderer theme backgroundColor).
                    renderer fillRectX: 0 Y: 0 W: width H: height.

                    renderer setColor: (renderer theme lineColor).
                    renderer drawRectX: 0 Y: 0 W: width H: height.

                    0 to: height by: 10 do: [ :y |
                        0 to: width by: 10 do: [ :x |
                            renderer drawPointX: x Y: y.
                        ].
                    ].

                    renderer withClipW: width H: height Do: [
                        $(Morph) renderOn: renderer.
                    ].
                );

                handleRemoveMorph: morph => (
                    (morph meta: #'ecosphere.eve.morphs.ValueMorph.value') yes: [ :v |
                        (std io out << 'Removed value: ' << v) newline commit.
                      ^ true
                    ].
                  ^ true
                );

                handleDropMorph: morph At: point Meta: meta => (
                    (morph meta: #'ecosphere.eve.morphs.ValueMorph.value') yes: [ :v |
                        | gb <- globalOffset, mgb <- morph globalOffset |
                        (tryAdd: morph) -> [
                            (std io out << 'Added value: ' << v) newline commit.
                            morph moveTo: (mgb - gb).
                          ^ true
                        ].
                    ].
                  ^ false
                );

                handleScrollX: sx Y: sy At: point HandMorph: hand => (
                    (xLayout isRigid) if: [
                        rigidWidth: (width + (25 * sx)).
                    ].
                    (yLayout isRigid) if: [
                        rigidHeight: (height + (25 * sy)).
                    ].
                    layoutChanged.
                  ^ true
                );
            };
        };

        own ValueMorph = {
            static with inherited _ = std Clonable;
            static with inherited own Morph = (($package gfx morphic) morphs) Morph;

            animationStart <- 0,
            entered        <- false;

            with inherited trait = {
                static with inherited _ = std Trait;
                app <- $package;

                init => (
                    $(Morph) initWithOneChild.
                    layouter: (morphic layouters Stack) new;
                  ^ self
                );

                renderImplOn: renderer => (
                    "
                        Draw angle-shaped lines in every corner of the morph.
                    "

                    |
                        lower                  <- entered if: 0.0 else: 5.0,
                        upper                  <- entered if: 5.0 else: 0.0,
                        animationProgress      <- (renderer animator) linearValueBetween: lower And: upper StartingAt: animationStart Duration: 0.25,
                        animationDelta         <- animationProgress asInt,
                        negativeAnimationDelta <- animationDelta negate
                    |

                    |
                        d  <- ((width min: height) / 4) min: 20,
                        sx <- negativeAnimationDelta,
                        sy <- negativeAnimationDelta,
                        ex <- width - 1 + animationDelta,
                        ey <- height - 1 + animationDelta,
                        sdx <- (sx + d),
                        sdy <- (sy + d),
                        edx <- (ex - d),
                        edy <- (ey - d)
                    |

                    renderer setR: (renderer theme accentColor r)
                                G: (renderer theme accentColor g)
                                B: (renderer theme accentColor b)
                                A: 32.
                    
                    renderer fillRectX: 0 Y: 0 W: width H: height.

                    renderer setColor: (renderer theme lineColor).

                    renderer drawLineX: sx Y: sy X: sdx Y: sy.
                    renderer drawLineX: sx Y: sy X: sx  Y: sdy.

                    renderer drawLineX: edx Y: sy X: ex Y: sy.
                    renderer drawLineX: ex  Y: sy X: ex Y: sdy.

                    renderer drawLineX: sx Y: edy X: sx  Y: ey.
                    renderer drawLineX: sx Y: ey  X: sdx Y: ey.

                    renderer drawLineX: edx Y: ey X: ex Y: ey.
                    renderer drawLineX: ex Y: edy X: ex Y: ey.

                    $(Morph) renderImplOn: renderer.
                );

                handleHandEnter: hand => (
                    entered        <- true.
                    animationStart <- ((morphic misc animation) Animator) now.
                  ^ false
                );

                handleHandExit: hand => (
                    entered        <- false.
                    animationStart <- ((morphic misc animation) Animator) now.
                  ^ false
                );

                handleClick: click At: point HandMorph: hand => (
                    (click isMiddle) if: [
                        (meta: #'ecosphere.eve.morphs.ValueMorph.value') yes: [ :v | 
                            (app framework actions open) OutlinerForObject: v.
                        ].
                      ^ true
                    ].
                    hand grab: self.
                  ^ true
                );

                handleDropMorph: morph At: point Meta: meta => (
                    "Just for experimental purposes: This is how you can check if the dropped morph is a ValueMorph."
                    (morph meta: #'ecosphere.eve.morphs.ValueMorph.value') yes: [ :v |
                        (std io out << 'Dropped value: ' << v) newline commit.
                      ^ false
                    ].
                  ^ false
                );

                writeOn: w => w << 'a value morph';
            };
        };

        "A morph that calls 'remove' on every object that is dropped to it. Can have multiple children."
        own PaperBinMorph = {
            static with inherited _ = std Clonable;
            static with inherited own Morph = (($package gfx morphic) morphs) Morph;

            with inherited trait = {
                static with inherited _ = std Trait;

                texture <- (($package gfx eve) TextureFromPath: (here / 'trashcan.png'));

                init => (
                    $(Morph) initWithOneChild.
                  ^ self
                );

                baseMinWidth => texture width;
                baseMinHeight => texture height;

                renderImplOn: renderer => (
                    renderer drawTexture: texture X: 0 Y: 0.
                    $(Morph) renderImplOn: renderer.
                );

                handleDropMorph: morph At: point Meta: meta => (
                    morph remove.                    
                  ^ true
                );

                writeOn: w => w << 'a paper bin morph';
            };
        };
    };

    protected MakePresentationMorphFor: v Ui: ui => (
        | sw <- (std io StringWriter) new |

        sw << v.
        
      ^ ui Label: sw build
    );

    protected MakeValueMorphFor: v Ui: ui => (
        | m <- (morphs ValueMorph) new |

        m add: (ui Padding(5, MakePresentationMorphFor: v Ui: ui)).

      ^ m
    );

    protected MakeModuleMorphUi: ui => (
        | m <- (morphs ValueMorph) new, mp <- morphs ModulePresentationMorph new |

        m add: (ui Padding(5, mp)).

        mp rigidWidth: 300.
        mp rigidHeight: 200.

        m xLayout: ((app gfx morphic) layouts ShrinkWrap).
        m yLayout: ((app gfx morphic) layouts ShrinkWrap).

      ^ m
    );

    ValueMorphFor: v Ui: ui => (
        | m <- MakeValueMorphFor: v Ui: ui |

        m meta: #'ecosphere.eve.morph.property.type' is: #'ecosphere.eve.morphs.ValueMorph'.
        m meta: #'ecosphere.eve.morphs.ValueMorph.value' is: v.

      ^ m
    );

    OpenValueMorphFor: v => (framework actions open) ui BuildAndOpen: [ :ui | ValueMorphFor: v Ui: ui ];
    OpenModuleMorph => (framework actions open) ui BuildAndOpen: [ :ui | MakeModuleMorphUi: ui ];

    OpenPaperBinMorph => (framework actions open) ui BuildAndOpen: [ :ui |
        | m <- ((app gfx morphic) morphs ClampFrameMorph) new |

        m add: ui Padding(5, ((morphs PaperBinMorph) new)).

        m xLayout: ((app gfx morphic) layouts ShrinkWrap).
        m yLayout: ((app gfx morphic) layouts ShrinkWrap).

        m
    ];

    Main => (
        OpenValueMorphFor: 42.
        OpenValueMorphFor: 'Hello World'.
        OpenValueMorphFor: (std os files here).
        OpenModuleMorph.
      ^ self
    );
}
