
std Module
{
    EmitMorph <- ($package core) NewBehavior
                    ~ name: 'an emit morph'
                    ~ presenterFunction: $[ :stream :kernel | stream emit: ((kernel state) payload) ]
                    ~ build;
    
    FunctionEmitMorph <- ($package core) NewBehavior
                            ~ name: 'a function emit morph'
                            ~ presenterFunction: $[ :stream :kernel | ((kernel state) payload) value(stream, kernel) ]
                            ~ build;

    LabelMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core) NewBehavior
                      ~ name: 'a label morph'
                      ~ presenterFunction: $[ :(polymorphic) :stream :kernel |
                            |
                                caption <- ((kernel state) payload),
                                color   <- ((stream context) theme) textColor,
                                text    <- ((polymorphic core objects) Text)
                                                Caption: caption
                                                  Color: color
                            |
                            stream emit: text.
                        ] bind($package)
                      ~ build;

        Text: text => Behavior link: text;
    };

    FlexMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core) NewBehavior
                      ~ name: 'a flex morph'
                      ~ on: (($package event) predicates AddMorph) do: $[ :kernel :event |
                            ((kernel state) payload) add: (event body).
                            kernel changed.
                        ]
                      ~ on: (($package event) predicates DropMorph) do: $[ :context :event |
                            | kernel <- context kernel, body <- event body, x <- context x, y <- context y |
                            
                            [ :break |
                                (context morph) childrenReverseDo: [ :each |
                                    ((each bounds) containsX: x Y: y) if: [
                                        ((kernel state) payload)
                                            insert: (body kernel)
                                            before: (each kernel).
                                        break value.
                                    ].
                                ].

                                ((kernel state) payload) add: (body kernel).
                            ] withBreak.

                            kernel changed.
                        ]
                      ~ disposeFunction: $[ :kernel :other |
                            ((kernel state) payload) remove: other.
                            kernel changed.
                        ]
                      ~ presenter:
                          {
                            isa std Singleton;
    
                            with inherited PresenterTrait <- (($package core morph) behavior presenting) PresenterTrait;
    
                            protected calculatePreferredExtentForMorph(morph, orientation, flexSize) => (
                                | layout <- morph layoutForOrientation: orientation |
    
                                (layout flexible?)   -> [ ^ flexSize ].
                                (layout shrinkWrap?) -> [ ^ morph minPositiveExtentForOrientation: orientation ].
    
                              ^ std sys error ThrowMessage: 'Unknown layout type'
                            );
    
                            drawOn: stream Kernel: kernel => (
                                |
                                    orientation          <- ((kernel state) payload) orientation,
                                    morphs               <- ((kernel state) payload) morphs,
                                    mainAxisOrientation  <- orientation,
                                    crossAxisOrientation <- orientation opposite,
                                    mainAxisSize         <- 0,
                                    crossAxisSize        <- 0,
                                    flexCount            <- 0,
                                    morphCount           <- morphs size,
                                    assignedSize         <- 0,
                                |
    
                                "Compute the size of the main axis and the cross axis."
                                morphs do: [ :morph |
                                    |
                                        morphMainAxisExtent  <- (morph minPositiveExtentForOrientation: mainAxisOrientation),
                                        morphCrossAxisExtent <- (morph minPositiveExtentForOrientation: crossAxisOrientation),
                                    |
    
                                    mainAxisSize  <- mainAxisSize + morphMainAxisExtent.
                                    crossAxisSize <- crossAxisSize max: morphCrossAxisExtent.
    
                                    (morph layoutForOrientation: mainAxisOrientation) flexible?
                                      ~ if: [ flexCount <- flexCount + 1 ]
                                      else: [ assignedSize <- assignedSize + morphMainAxisExtent ].
                                ].
    
                                |
                                    flexSize <- (flexCount zero?) if: [ 0 ] else: [ ((mainAxisSize - assignedSize) asFloat / flexCount asFloat) asInt ],
                                    w        <- mainAxisOrientation selectX: mainAxisSize  Y: crossAxisSize,
                                    h        <- mainAxisOrientation selectX: crossAxisSize Y: mainAxisSize,
                                |
    
                                stream withGraphicsAtX: 0 Y: 0 W: w H: h Do: [ :graphics |
                                    |
                                        offset <- 0,
                                    |
    
                                    morphs do: [ :morph |
    
                                        |
                                            morphMainAxisExtent     <- calculatePreferredExtentForMorph(morph, mainAxisOrientation, flexSize),
                                            morphCrossAxisExtent    <- calculatePreferredExtentForMorph(morph, crossAxisOrientation, crossAxisSize),
                                            bounds <- (polymorphic math geometry Rectangle)
                                                        X: (mainAxisOrientation selectX: offset Y: 0)
                                                        Y: (mainAxisOrientation selectX: 0      Y: offset)
                                                        W: (mainAxisOrientation selectX: morphMainAxisExtent  Y: morphCrossAxisExtent)
                                                        H: (mainAxisOrientation selectX: morphCrossAxisExtent Y: morphMainAxisExtent),
                                        |
    
                                        graphics in: bounds put: morph.
    
                                        offset <- offset + morphMainAxisExtent.
                                    ].
                                ].
    
                              ^ self
                            );
    
                            writeOn: w => w << 'the flex presenter';
                          }
                      ~ build;
        
        Payload :: Classlike
        {
            Instance :: Clonable
            {
                |
                    orientation,
                    morphs
                |

                {
                    protected polymorphic <- $package;

                    initWithOrientation: o => (
                        orientation <- o.
                        morphs      <- std util newVector.
                      ^ self
                    );

                    add:    morph => morphs add:    morph;
                    remove: morph => morphs remove: morph;

                    insert: morph before: other => morphs insert: morph before: other;
                    insert: morph after:  other => morphs insert: morph after:  other;
                }
            };

            Orientation: orientation => (Instance clone) initWithOrientation: orientation;
        };

        ForOrientation: orientation => (Behavior link: (Payload Orientation: orientation));

        Horizontal => ForOrientation: (polymorphic math geometry orientation) Horizontal;
        Vertical   => ForOrientation: (polymorphic math geometry orientation) Vertical;
    };

    MarginMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core) NewBehavior
                      ~ name: 'a margin morph'
                      ~ presenter:
                          {
                            isa std Singleton;
    
                            with inherited PresenterTrait <- ($package core morph behavior presenting) PresenterTrait;
    
                            protected calculatePreferredExtentForMorph(morph, orientation, extentLimits, margin) => (
                                extentLimits no: [ ^ (morph minExtentForOrientation: orientation) ].
                                
                                | layout <- morph layoutForOrientation: orientation |
    
                                (layout flexible?)   -> [ ^ ((extentLimits yes) dimensionForOrientation: orientation) ].
                                (layout shrinkWrap?) -> [ ^ (morph minExtentForOrientation: orientation) ].
    
                              ^ std sys error ThrowMessage: 'Unknown layout type'
                            );
    
                            drawOn: stream Kernel: kernel => (
                                (((kernel state) payload) child) yes: [ :morph |
                                    |
                                        margin  <- ((kernel state) payload) margin,
                                        extent  <- stream maybeExtent,
                                        extent2 <- extent yes: [ :e | Yes: ((polymorphic math geometry) Point X: (e x - (margin * 2)) Y: (e y - (margin * 2))) ] no: [ No ],
                                        w       <- calculatePreferredExtentForMorph(morph, ((polymorphic math geometry) orientation) Horizontal, extent2, margin),
                                        h       <- calculatePreferredExtentForMorph(morph, ((polymorphic math geometry) orientation) Vertical,   extent2, margin),
                                        bounds  <- ((polymorphic math geometry) Rectangle)
                                                        X: margin
                                                        Y: margin
                                                        W: w
                                                        H: h,
                                        ourBounds <- ((polymorphic math geometry) Rectangle)
                                                           X: 0
                                                           Y: 0
                                                      Extent: (extent yes: [ :e | e ] no: [ ((polymorphic math geometry) Point X: (bounds w + (margin * 2)) Y: (bounds h + (margin * 2)))])
                                    |
    
                                    stream withGraphicsInBounds: ourBounds Do: [ :graphics |
                                        graphics in: bounds put: morph.
                                    ].
    
                                  ^ self
                                ].
                            );
    
                            writeOn: w => w << 'the margin presenter';
                          }
                      ~ build;
        
        Payload :: Classlike
        {
            Instance :: Clonable
            {
                |
                    margin <- 0,
                    child  <- No
                |

                {
                    protected polymorphic <- $package;

                    initWithMargin: m => (
                        margin <- m.
                        child  <- No.
                      ^ self
                    );

                    child: c => child <- Yes: c;
                }
            };

            Margin: margin => (Instance clone) initWithMargin: margin;
        };

        Margin: margin => (Behavior link: (Payload Margin: margin));
        Margin: margin Child: child => (Behavior link: (Payload Margin: margin ~ child: child));
    };


    FrameMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core) NewBehavior
                      ~ name: 'a frame morph'
                      ~ presenterFunction: $[ :(polymorphic) :stream :kernel |
                            ((kernel state payload) child) yes: [ :child |
                                |
                                    origin <- ((polymorphic math geometry) Point) Origin,
                                    extent <- child minExtent
                                |
                                stream withGraphicsDo: [ :graphics |
                                    |
                                        rect <- (polymorphic core objects) Rectangle
                                                    Bounds: (origin extent: extent)
                                                     Color: ((graphics context) theme) lineColor
                                    |
                                    graphics at: origin put: child.
                                    graphics at: origin put: rect.
                                ].
                            ].
                        ] bind($package)
                      ~ build;
        
        Payload :: Classlike
        {
            Instance :: Clonable
            {
                |
                    child <- No
                |

                {
                    protected polymorphic <- $package;

                    child: c => child <- Yes: c;
                }
            };

            New => Instance new;
        };

        New      => (Behavior link: (Payload New));
        Child: c => (
            | p <- Payload New |
            p child: c.
          ^ (Behavior link: p)
        );
    };

    ButtonMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core) NewBehavior
                      ~ name: 'a button morph'
                      ~ presenterFunction: $[ :(polymorphic) :stream :kernel |
                            ((kernel state payload) child) yes: [ :child |
                                stream emit: child.
                            ].
                        ] bind($package)
                      ~ on: (($package event) predicates MouseClick) do: $[ :a :b |
                                (std io out << 'Clicked the button! ') newline commit.
                        ]
                      ~ build;
        
        Payload :: Classlike
        {
            Instance :: Clonable
            {
                |
                    child <- No
                |

                {
                    protected polymorphic <- $package;

                    child: c => child <- Yes: c;
                }
            };

            New => Instance new;
        };

        New      => (Behavior link: (Payload New));
        Child: c => (
            | p <- Payload New |
            p child: c.
          ^ (Behavior link: p)
        );
    };
}
