
std Module
{
    with app = $;

    core   :: (here / 'core'   / '_.eco') importIn: self;
    color  :: (here / 'color'  / '_.eco') importIn: self;
    event  :: (here / 'event'  / '_.eco') importIn: self;
    morphs :: (here / 'morphs' / '_.eco') importIn: self;


    DriverWrapperMorph :: Clonable {
        with inherited own Morph = ($package gfx morphic) morphs Morph;

        |
            driver <- No,
            
            protected cachedCursorX <- 0,
            protected cachedCursorY <- 0
        |

        {
            driver: d => (
                driver <- Yes: d.
                renderDirty.
              ^ self
            );

            renderImplOn: renderer => (
                driver yes: [ :theDriver | 
                    |
                        mousePos         <- (world yes) handMorph globalOffset,
                        relativeMousePos <- mousePos - globalOffset
                    |

                    updateX: (relativeMousePos x)
                          Y: (relativeMousePos y).

                    [
                        (theDriver) tick.
                        (theDriver rootPaper) renderOn: renderer.
                    ] catch: [ :ex |
                        (std io out << 'Oops! Something went wrong in polymorphic2!') newline commit.
                    ].
                ].

              ^ self
            );

            protected movedToX: x Y: y => (
                cachedCursorX <- x.
                cachedCursorY <- y.

                (driver yes)
                    mouseMovedToX: x
                                Y: y.
                
              ^ self
            );

            protected updateX: x Y: y => (
                [ cachedCursorX != x ] or: [ cachedCursorY != y ]
                  ~ if: [ movedToX: x Y: y ].
              ^ self
            );

            handleClick: click At: point HandMorph: hand => (
                updateX: (point x) Y: (point y).        
                (driver yes) mouseClicked: click.
              ^ true
            );

            handleKey: key At: point HandMorph: hand => (
                updateX: (point x) Y: (point y).
                (driver yes) keyPressed: key.
                (driver yes) keyReleased: key.
              ^ true
            );

            handleScrollX: sx Y: sy HandMorph: hand => (
                (driver yes) mouseScrolledByX: sx Y: sy.
              ^ true
            );

            writeOn: w => w << 'a driver wrapper morph';
        }
    };


    Test => (
        |
            driver <- ((core world) Driver) New
        |

        driver run.

        ((driver world) node) dumpOn: (std io out).

        (framework actions open) ui BuildAndOpen: [ :ui |
            ui Window(450, 450,
                ui Clipped(
                    (DriverWrapperMorph new) driver: driver
                )
            )
        ]
    );
}
