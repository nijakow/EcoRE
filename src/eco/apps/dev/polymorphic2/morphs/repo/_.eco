
std Module
{
    TestMorph <- ($package core morph Behavior) New
                ~ presenter:
                    {
                        isa std Singleton;

                        with inherited PresenterTrait <- ($package core morph behavior presenting) PresenterTrait;

                        drawOn: stream Kernel: kernel => (
                            stream emit: ((polymorphic core objects Rectangle) X: 0 Y: 0 W: 64 H: 64).
                          ^ self
                        );

                        writeOn: w => w << 'the test presenter';
                    };
    
    EmitMorph <- ($package core morph Behavior) New
                ~ presenter:
                    {
                        isa std Singleton;

                        with inherited PresenterTrait <- ($package core morph behavior presenting) PresenterTrait;

                        drawOn: stream Kernel: kernel => (
                            stream emit: ((kernel state) payload).
                          ^ self
                        );

                        writeOn: w => w << 'the emit presenter';
                    };

    FlexMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core morph Behavior) New
                  ~ presenter:
                      {
                        isa std Singleton;

                        with inherited PresenterTrait <- ($package core morph behavior presenting) PresenterTrait;

                        protected calculatePreferredExtentForMorph(morph, orientation, flexSize) => (
                            | layout <- morph layoutForOrientation: orientation |

                            (layout flexible?)   -> [ ^ flexSize ].
                            (layout shrinkWrap?) -> [ ^ morph minExtentForOrientation: orientation ].

                          ^ std sys error ThrowMessage: 'Unknown layout type'
                        );

                        drawOn: stream Kernel: kernel => (
                            |
                                orientation          <- ((kernel state) payload) orientation,
                                morphs               <- ((kernel state) payload) morphs,
                                mainAxisOrientation  <- orientation,
                                crossAxisOrientation <- orientation opposite,
                                mainAxisSize         <- 0,
                                crossAxisSize        <- 0,
                                flexCount            <- 0,
                                morphCount           <- morphs size,
                                assignedSize         <- 0,
                            |

                            "Compute the size of the main axis and the cross axis."
                            morphs do: [ :morph |
                                |
                                    morphMainAxisExtent  <- (morph minExtentForOrientation: mainAxisOrientation),
                                    morphCrossAxisExtent <- (morph minExtentForOrientation: crossAxisOrientation),
                                |

                                mainAxisSize  <- mainAxisSize + morphMainAxisExtent.
                                crossAxisSize <- crossAxisSize max: morphCrossAxisExtent.

                                (morph layoutForOrientation: mainAxisOrientation) flexible?
                                  ~ if: [ flexCount <- flexCount + 1 ]
                                  else: [ assignedSize <- assignedSize + morphMainAxisExtent ].
                            ].

                            |
                                flexSize <- (flexCount zero?) if: [ 0 ] else: [ ((mainAxisSize - assignedSize) asFloat / flexCount asFloat) asInt ],
                                w        <- mainAxisOrientation selectX: mainAxisSize  Y: crossAxisSize,
                                h        <- mainAxisOrientation selectX: crossAxisSize Y: mainAxisSize,
                            |

                            stream withGraphicsAtX: 0 Y: 0 W: w H: h Do: [ :graphics |
                                |
                                    offset <- 0,
                                |

                                morphs do: [ :morph |

                                    |
                                        morphMainAxisExtent     <- calculatePreferredExtentForMorph(morph, mainAxisOrientation, flexSize),
                                        morphCrossAxisExtent    <- calculatePreferredExtentForMorph(morph, crossAxisOrientation, crossAxisSize),
                                        bounds <- (polymorphic math geometry Rectangle)
                                                    X: (mainAxisOrientation selectX: offset Y: 0)
                                                    Y: (mainAxisOrientation selectX: 0      Y: offset)
                                                    W: (mainAxisOrientation selectX: morphMainAxisExtent  Y: morphCrossAxisExtent)
                                                    H: (mainAxisOrientation selectX: morphCrossAxisExtent Y: morphMainAxisExtent),
                                    |

                                    graphics in: bounds put: morph.

                                    offset <- offset + morphMainAxisExtent.
                                ].
                            ].

                          ^ self
                        );

                        writeOn: w => w << 'the flex presenter';
                      };
        
        Payload :: Classlike
        {
            Instance :: Clonable
            {
                |
                    orientation,
                    morphs
                |

                {
                    protected polymorphic <- $package;

                    initWithOrientation: o => (
                        orientation <- o.
                        morphs      <- std util newVector.
                      ^ self
                    );
                }
            };

            Orientation: orientation => (Instance clone) initWithOrientation: orientation;
        };

        ForOrientation: orientation => (Behavior link: (Payload Orientation: orientation));

        Horizontal => ForOrientation: (polymorphic math geometry orientation) Horizontal;
        Vertical   => ForOrientation: (polymorphic math geometry orientation) Vertical;
    };

    MarginMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core morph Behavior) New
                  ~ presenter:
                      {
                        isa std Singleton;

                        with inherited PresenterTrait <- ($package core morph behavior presenting) PresenterTrait;

                        drawOn: stream Kernel: kernel => (
                            (((kernel state) payload) child) yes: [ :morph |
                                |
                                    margin <- ((kernel state) payload) margin,
                                    extent <- morph minExtent,
                                    w      <- (extent x) + (margin * 2),
                                    h      <- (extent y) + (margin * 2),
                                |

                                stream withGraphicsAtX: 0 Y: 0 W: w H: h Do: [ :graphics |
                                    |
                                        bounds <- (polymorphic math geometry Rectangle)
                                                    X: margin
                                                    Y: margin
                                                    W: extent x
                                                    H: extent y,
                                    |

                                    graphics in: bounds put: morph.
                                ].

                              ^ self
                            ].
                        );

                        writeOn: w => w << 'the margin presenter';
                      };
        
        Payload :: Classlike
        {
            Instance :: Clonable
            {
                |
                    margin <- 0,
                    child  <- No
                |

                {
                    protected polymorphic <- $package;

                    initWithMargin: m => (
                        margin <- m.
                        child  <- No.
                      ^ self
                    );

                    child: c => child <- Yes: c;
                }
            };

            Margin: margin => (Instance clone) initWithMargin: margin;
        };

        Margin: margin => (Behavior link: (Payload Margin: margin));
    };
}
