
std Module
{
    TestMorph <- ($package core) NewBehavior
                    ~ presenterFunction: $[ :(polymorphic) :stream :kernel | stream emit: ((polymorphic core objects Rectangle) X: 0 Y: 0 W: 64 H: 64) ] bind($package)
                    ~ build;

    TestMorph2 <- ($package core) NewBehavior
                    ~ presenterFunction: $[ :(polymorphic) :stream :kernel |
                          stream
                              ~ << 'Look at me'
                              ~ newline
                              ~ << '  as I can fly!!!'.
                      ] bind($package)
                    ~ build;
    
    TestMorph3_Point <- ($package core) NewBehavior
                          ~ presenterFunction: $[ :(polymorphic) :stream :kernel |
                                stream << 'Point!' ~ newline.
                                stream withGraphicsDo: [ :graphics |
                                    graphics at: ((polymorphic math geometry) Point Origin) put: (((polymorphic core objects) FilledCircle) Radius: 3 Color: (((polymorphic color colors) Red))).
                                ].
                          ] bind($package)
                          ~ build;
    
    TestMorph3 <- ($package core) NewBehavior
                    ~ presenterFunction: $[ :(polymorphic) :stream :kernel |
                          stream withGraphicsDo: [ :graphics |
                                0 to: 9 do: [ :i |
                                    |
                                        v1  <- ((i / (10 asFloat)) * 3.14159 * 2) sin,
                                        v2  <- (((i + 1) / (10 asFloat)) * 3.14159 * 2) sin,
                                        vp1 <- ((v1 negate * 50) + 50) asInt,
                                        vp2 <- ((v2 negate * 50) + 50) asInt,
                                        p   <- ((polymorphic math geometry) Point X: i * 25 Y: vp1)
                                    |
                                    graphics at: p put: (((polymorphic core objects) Line) End: ((polymorphic math geometry) Point X: 25 Y: (vp2 - vp1))).
                                    graphics at: p put: (((polymorphic morphs) repo TestMorph3_Point) link).
                                ]
                          ].
                      ] bind($package)
                    ~ build;
    
    TestMorph3_1 <- ($package core) NewBehavior
                      ~ presenterFunction: $[ :(polymorphic) :stream :kernel |
                            |
                                Point <- (polymorphic math geometry) Point,
                                PointMorph <- (polymorphic morphs) repo TestMorph3_Point
                            |

                            stream withGraphicsDo: [ :graphics |
                                | n <- 10, r <- 50 |

                                1 to: n do: [ :i |
                                    |
                                        d <- ((i / (n asFloat)) * 3.14159 * 2),
                                        x <- (d sin * r) asInt,
                                        y <- (d cos * r) asInt,
                                    |

                                    graphics at: (Point X: x Y: y)
                                            put: (PointMorph link).
                                ].
                            ].
                      ] bind($package)
                      ~ build;
    
    TestMorph4 <- ($package core) NewBehavior
                    ~ presenterFunction: $[ :(polymorphic) :stream :kernel |
                |
                    r      <- 5,
                    circle <- ((polymorphic core objects) FilledCircle Radius: r)
                |

                1 to: 5 do: [ :i | (stream << i) newline ].

                stream emit: ((polymorphic core objects Text) Caption: 'Hello World!').

                stream emit: circle.
                stream emit: circle.

                stream withRoom: ((polymorphic math geometry) Point X: 100 Y: 100) ForGraphicsDo: [ :graphics |
                    graphics at: ((polymorphic math geometry) Point X:   0 Y:   0) put: ((polymorphic core objects) Rectangle Bounds: (graphics bounds)).
                    graphics at: ((polymorphic math geometry) Point X:  50 Y:  50) put: ((polymorphic core objects) FilledCircle Radius: 25).
                ].

                stream emit: circle.
                stream emit: (((polymorphic morphs) repo FrameMorph) Child: (((polymorphic morphs) repo TestMorph2) link)).
                stream newline.

                1 to: 25 do: [ :i |
                    stream emit: circle.
                    ((i mod: 5) == 0) if: [
                        stream newline.
                    ].
                ].

                stream newline.

                | behavior <- ((polymorphic core morph) Behavior) New |

                stream emit: (behavior link).
                stream emit: circle.
                stream emit: (behavior link).
                stream emit: circle.
                stream newline.
                stream emit: circle.
                stream emit: (behavior link).
                stream emit: circle.
                stream emit: (behavior link).
                stream newline.

                (
                    stream emit: (((polymorphic morphs) repo FrameMorph) Child: (
                        ((polymorphic morphs) repo FlexMorph) Horizontal
                          ~ add: (((polymorphic morphs) repo TestMorph) link)
                          ~ add: (((polymorphic morphs) repo TestMorph) link)
                          ~ add: (
                                  ((polymorphic morphs) repo FlexMorph) Vertical
                                    ~ add: (((polymorphic morphs) repo TestMorph) link)
                                    ~ add: (((polymorphic morphs) repo TestMorph) link)
                                    ~ add: (((polymorphic morphs) repo TestMorph) link)
                                    ~ add: (
                                        | flex3 <- ((polymorphic morphs) repo FlexMorph) Horizontal |
    
                                        1 to: 4 do: [ :i |
                                            flex3 add: (((polymorphic morphs) repo EmitMorph) link: ((polymorphic core objects) FilledCircle Radius: ((11 - i) * 3))).
                                        ].
    
                                        flex3
                                    )
                                    ~ add: (((polymorphic morphs) repo TestMorph) link)
                                    ~ add: (
                                        ((polymorphic morphs) repo FlexMorph) Horizontal
                                        ~ add: (((polymorphic morphs) repo TestMorph2) link)
                                        ~ add: (((polymorphic morphs) repo FrameMorph) Child: (((polymorphic morphs) repo TestMorph2) link))
                                        ~ add: (((polymorphic morphs) repo TestMorph2) link)
                                    )
                          )
                          ~ add: (((polymorphic morphs) repo TestMorph) link)
                    )).
                    stream emit: (((polymorphic core objects) Text) Caption: 'Some text :D').
                    stream newline.
                ).

                (
                    |
                        margin1  <- ((polymorphic morphs) repo MarginMorph) Margin: 10,
                    |

                    (margin1 state) payload
                    ~ child: (((polymorphic morphs) repo EmitMorph) link: ((polymorphic core objects) FilledCircle Radius: 25)).
                    
                    stream emit: margin1.
                ).

                stream emit: (((polymorphic morphs) repo EmitMorph) link: ((polymorphic core objects) FilledCircle Radius: 25)).
                stream newline.
                stream emit: ((polymorphic core objects) FilledCircle Radius: 25).
                stream emit: ((polymorphic core objects) FilledCircle Radius: 25).
                stream newline.

                stream withGraphicsDo: [ :graphics |
                    (graphics maybeBounds) yes: [ :bnds |
                        graphics at: ((polymorphic math geometry) Point X:  0 Y:  0)
                                put: ((polymorphic core objects) Rectangle Bounds: (bnds) Color: ((polymorphic color) colors Red)).

                        graphics at: ((polymorphic math geometry) Point X: (bnds w / 2) Y: (bnds h / 2))
                                put: ((polymorphic core objects) FilledCircle Radius: 25 Color: ((polymorphic color) colors Red)).
                    ].
                ].

                (
                    |
                        flex <- ((polymorphic morphs) repo FlexMorph) Horizontal
                                ~ add: (((polymorphic morphs) repo EmitMorph) link: (((polymorphic core objects) FilledCircle) Radius: 5 Color: ((polymorphic color) colors Red)))
                                ~ add: (((polymorphic morphs) repo EmitMorph) link: (((polymorphic core objects) FilledCircle) Radius: 5 Color: ((polymorphic color) colors Red)))
                                ~ add: (((polymorphic morphs) repo EmitMorph) link: (((polymorphic core objects) FilledCircle) Radius: 5 Color: ((polymorphic color) colors Red)))
                    |

                    stream emit: flex.
                ).

                stream emit: (((polymorphic morphs) repo TestMorph3) link).
                stream newline.
                stream emit: (((polymorphic morphs) repo TestMorph3_1) link).
                stream emit: (((polymorphic morphs) repo TestMorph3_1) link).
                stream newline.
                stream emit: (((polymorphic morphs) repo TestMorph3_1) link).
                    ] bind($package)
                    ~ build;
    
    EmitMorph <- ($package core) NewBehavior
                    ~ presenterFunction: $[ :stream :kernel | stream emit: ((kernel state) payload) ]
                    ~ build;
    
    FunctionEmitMorph <- ($package core) NewBehavior
                            ~ presenterFunction: $[ :stream :kernel | ((kernel state) payload) value(stream, kernel) ]
                            ~ build;

    FlexMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core) NewBehavior
                      ~ on: (($package event) predicates AddMorph) do: $[ :kernel :event |
                                ((kernel state) payload) add: (event body).
                                kernel changed.
                        ]
                      ~ presenter:
                          {
                            isa std Singleton;
    
                            with inherited PresenterTrait <- ($package core morph behavior presenting) PresenterTrait;
    
                            protected calculatePreferredExtentForMorph(morph, orientation, flexSize) => (
                                | layout <- morph layoutForOrientation: orientation |
    
                                (layout flexible?)   -> [ ^ flexSize ].
                                (layout shrinkWrap?) -> [ ^ morph minExtentForOrientation: orientation ].
    
                              ^ std sys error ThrowMessage: 'Unknown layout type'
                            );
    
                            drawOn: stream Kernel: kernel => (
                                |
                                    orientation          <- ((kernel state) payload) orientation,
                                    morphs               <- ((kernel state) payload) morphs,
                                    mainAxisOrientation  <- orientation,
                                    crossAxisOrientation <- orientation opposite,
                                    mainAxisSize         <- 0,
                                    crossAxisSize        <- 0,
                                    flexCount            <- 0,
                                    morphCount           <- morphs size,
                                    assignedSize         <- 0,
                                |
    
                                "Compute the size of the main axis and the cross axis."
                                morphs do: [ :morph |
                                    |
                                        morphMainAxisExtent  <- (morph minExtentForOrientation: mainAxisOrientation),
                                        morphCrossAxisExtent <- (morph minExtentForOrientation: crossAxisOrientation),
                                    |
    
                                    mainAxisSize  <- mainAxisSize + morphMainAxisExtent.
                                    crossAxisSize <- crossAxisSize max: morphCrossAxisExtent.
    
                                    (morph layoutForOrientation: mainAxisOrientation) flexible?
                                      ~ if: [ flexCount <- flexCount + 1 ]
                                      else: [ assignedSize <- assignedSize + morphMainAxisExtent ].
                                ].
    
                                |
                                    flexSize <- (flexCount zero?) if: [ 0 ] else: [ ((mainAxisSize - assignedSize) asFloat / flexCount asFloat) asInt ],
                                    w        <- mainAxisOrientation selectX: mainAxisSize  Y: crossAxisSize,
                                    h        <- mainAxisOrientation selectX: crossAxisSize Y: mainAxisSize,
                                |
    
                                stream withGraphicsAtX: 0 Y: 0 W: w H: h Do: [ :graphics |
                                    |
                                        offset <- 0,
                                    |
    
                                    morphs do: [ :morph |
    
                                        |
                                            morphMainAxisExtent     <- calculatePreferredExtentForMorph(morph, mainAxisOrientation, flexSize),
                                            morphCrossAxisExtent    <- calculatePreferredExtentForMorph(morph, crossAxisOrientation, crossAxisSize),
                                            bounds <- (polymorphic math geometry Rectangle)
                                                        X: (mainAxisOrientation selectX: offset Y: 0)
                                                        Y: (mainAxisOrientation selectX: 0      Y: offset)
                                                        W: (mainAxisOrientation selectX: morphMainAxisExtent  Y: morphCrossAxisExtent)
                                                        H: (mainAxisOrientation selectX: morphCrossAxisExtent Y: morphMainAxisExtent),
                                        |
    
                                        graphics in: bounds put: morph.
    
                                        offset <- offset + morphMainAxisExtent.
                                    ].
                                ].
    
                              ^ self
                            );
    
                            writeOn: w => w << 'the flex presenter';
                          }
                      ~ build;
        
        Payload :: Classlike
        {
            Instance :: Clonable
            {
                |
                    orientation,
                    morphs
                |

                {
                    protected polymorphic <- $package;

                    initWithOrientation: o => (
                        orientation <- o.
                        morphs      <- std util newVector.
                      ^ self
                    );

                    add: morph => morphs add: morph;
                }
            };

            Orientation: orientation => (Instance clone) initWithOrientation: orientation;
        };

        ForOrientation: orientation => (Behavior link: (Payload Orientation: orientation));

        Horizontal => ForOrientation: (polymorphic math geometry orientation) Horizontal;
        Vertical   => ForOrientation: (polymorphic math geometry orientation) Vertical;
    };

    MarginMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core) NewBehavior
                      ~ presenter:
                          {
                            isa std Singleton;
    
                            with inherited PresenterTrait <- ($package core morph behavior presenting) PresenterTrait;
    
                            protected calculatePreferredExtentForMorph(morph, orientation, extentLimits, margin) => (
                                extentLimits no: [ ^ (morph minExtentForOrientation: orientation) ].
                                
                                | layout <- morph layoutForOrientation: orientation |
    
                                (layout flexible?)   -> [ ^ ((extentLimits yes) dimensionForOrientation: orientation) ].
                                (layout shrinkWrap?) -> [ ^ (morph minExtentForOrientation: orientation) ].
    
                              ^ std sys error ThrowMessage: 'Unknown layout type'
                            );
    
                            drawOn: stream Kernel: kernel => (
                                (((kernel state) payload) child) yes: [ :morph |
                                    |
                                        margin  <- ((kernel state) payload) margin,
                                        extent  <- stream maybeExtent,
                                        extent2 <- extent yes: [ :e | Yes: ((polymorphic math geometry) Point X: (e x - (margin * 2)) Y: (e y - (margin * 2))) ] no: [ No ],
                                        w       <- calculatePreferredExtentForMorph(morph, ((polymorphic math geometry) orientation) Horizontal, extent2, margin),
                                        h       <- calculatePreferredExtentForMorph(morph, ((polymorphic math geometry) orientation) Vertical,   extent2, margin),
                                        bounds  <- ((polymorphic math geometry) Rectangle)
                                                        X: margin
                                                        Y: margin
                                                        W: w
                                                        H: h,
                                        ourBounds <- ((polymorphic math geometry) Rectangle)
                                                           X: 0
                                                           Y: 0
                                                      Extent: (extent yes: [ :e | e ] no: [ ((polymorphic math geometry) Point X: (bounds w + (margin * 2)) Y: (bounds h + (margin * 2)))])
                                    |
    
                                    stream withGraphicsInBounds: ourBounds Do: [ :graphics |
                                        graphics in: bounds put: morph.
                                    ].
    
                                  ^ self
                                ].
                            );
    
                            writeOn: w => w << 'the margin presenter';
                          }
                      ~ build;
        
        Payload :: Classlike
        {
            Instance :: Clonable
            {
                |
                    margin <- 0,
                    child  <- No
                |

                {
                    protected polymorphic <- $package;

                    initWithMargin: m => (
                        margin <- m.
                        child  <- No.
                      ^ self
                    );

                    child: c => child <- Yes: c;
                }
            };

            Margin: margin => (Instance clone) initWithMargin: margin;
        };

        Margin: margin => (Behavior link: (Payload Margin: margin));
        Margin: margin Child: child => (Behavior link: (Payload Margin: margin ~ child: child));
    };


    FrameMorph :: Module
    {
        protected polymorphic <- $package;

        Behavior <- ($package core) NewBehavior
                      ~ presenterFunction: $[ :(polymorphic) :stream :kernel |
                            ((kernel state payload) child) yes: [ :child |
                                |
                                    origin <- ((polymorphic math geometry) Point) Origin,
                                    extent <- child minExtent
                                |
                                stream withGraphicsDo: [ :graphics |
                                    |
                                        rect <- (polymorphic core objects) Rectangle
                                                    Bounds: (origin extent: extent)
                                    |
                                    graphics at: origin put: child.
                                    graphics at: origin put: rect.
                                ].
                            ].
                        ] bind($package)
                      ~ build;
        
        Payload :: Classlike
        {
            Instance :: Clonable
            {
                |
                    child <- No
                |

                {
                    protected polymorphic <- $package;

                    child: c => child <- Yes: c;
                }
            };

            New => Instance new;
        };

        New      => (Behavior link: (Payload New));
        Child: c => (
            | p <- Payload New |
            p child: c.
          ^ (Behavior link: p)
        );
    };
}
