
{
    isa std Classlike;

    Instance :: Clonable
    {
        |
            extent             <- No,
            realWidth          <- 0,
            realHeight         <- 0,
            presentations,
            cachedMorphs,
            node
        |

        {
            protected polymorphic <- $package;

            initWithMaybeExtent: _extent => (
                extent             <- _extent.
                presentations      <- std util newVector.
                cachedMorphs       <- std util newVector.
                node               <- ((polymorphic core morph) tree nodes) VoidNode.
                realWidth          <- 0.
                realHeight         <- 0.
              ^ self
            );

            maybeExtent => extent;
            realExtent  => (polymorphic math geometry Point) X: realWidth Y: realHeight;

            node: n => node <- n;

            resize: newExtent => (
                extent     <- newExtent.
                realWidth  <- realWidth max: (extent x).
                realHeight <- realWidth max: (extent y).
              ^ self
            );

            presentationsDo: block => presentations do: block;
            morphsDo: block => (
                presentationsDo: [ :presentation |
                    (presentation morphPresentation?)
                      ~ if: [ block value(presentation morph) ]
                ].
              ^ self
            );

            lookupKernel: kernel => (
                cachedMorphs forEach: [ :i :each |
                    (each kernel == kernel) if: [
                        cachedMorphs erase: i.
                      ^ Yes: each
                    ].
                ].
              ^ No
            );

            claimBounds: bounds => (
                | bottomRight <- bounds bottomRight |

                realWidth  <- realWidth  max: bottomRight x.
                realHeight <- realHeight max: bottomRight y.

              ^ self
            );

            add: presentation => (
                presentation connectToParentNode: node. "Connect the node of the presented object to the paper's node..."
                claimBounds: presentation bounds.
                presentations add: presentation.
              ^ self
            );

            clear => (
                "Clear the old morph cache, if it exists."
                ((cachedMorphs empty?) not) if: [
                    "TODO: Maybe we might have to call a few destructors here?"
                    cachedMorphs <- std util newVector.
                ].

                "Throw out the old presentations, but keep the references to the morphs."
                presentations do: [ :each |
                    each disconnectFromParentNode. "TODO: Move this up into the morph cache clearing part?"
                    (each morphPresentation?) if: [
                        cachedMorphs add: (each morph).
                    ].
                ].

                presentations clear.

                realWidth  <- 0.
                realHeight <- 0.

              ^ self
            );

            clearAndReset => (
                self clear.
                self extent <- No.
              ^ self
            );

            emitter => (polymorphic core stream Emitter) Paper: self;
            stream  => (polymorphic core stream Stream) Emitter: emitter;

            renderOn: renderer => (
                presentations do: [ :each | each renderOn: renderer ].
              ^ self
            );

            "For now, ignore viewport and just render everything."
            renderOn: renderer Viewport: viewport => renderOn: renderer;

            writeOn: w => w << 'a paper';
        }
    };

    Extent: extent => (Instance clone) initWithMaybeExtent: (Yes: extent);
    New            => (Instance clone) initWithMaybeExtent: No;
}
