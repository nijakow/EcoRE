
{
    isa std Classlike;

    Instance :: Clonable
    {
        |
            bounds,
            kernel,
            paper,

            node
        |

        {
            protected polymorphic <- $package;

            initWithKernel: k Bounds: b Paper: p => (
                kernel <- k.
                bounds <- b.
                paper  <- p.
                node   <- (((polymorphic core morph) tree nodes) MorphNode) Morph: self.

                paper node: node. "Set the paper's node to a MorphNode pointing to us..."

              ^ self
            );

            initWithKernel: kernel Bounds: bounds => initWithKernel: kernel Bounds: bounds Paper: ((polymorphic core paper Paper) New);

            iAmDirty => (
                world yes: [ :w | w iAmDirty: self ].
              ^ self
            );

            changed => (
                world yes: [ :w | w iHaveChanged: self ].
              ^ self
            );

            protected enterWorld: world => (
                world addMorph: self.
                kernel addMorph: self.
                world iAmDirty: self.
              ^ self
            );

            protected exitWorld: world => (
                kernel removeMorph: self.
                world removeMorph: self.
              ^ self
            );

            connectToParentNode: parentNode => (
                node reparent: parentNode.
                world yes: [ :w | enterWorld: w ].
              ^ self
            );

            disconnectFromParentNode => (
                paper clear. "Clear the paper, so that all children are purged."
                world yes: [ :w | exitWorld: w ].
                node disconnect.
              ^ self
            );

            parent      => node parent;
            parentMorph => parent yes: [ :p | p maybeMorph ];

            world => node world;

            childrenDo: block => (
                "This is a bit of a hack, but it works like a charm :D"
                paper presentationsDo: [ :presentation |
                    (presentation morphPresentation?)
                      ~ if: [ block value(presentation morph) ]
                ].
              ^ self
            );

            protected internalRedraw => (
                kernel drawOnStream: (paper stream) Instance: self.
              ^ self
            );

            redrawInPlace => (
                paper clear.
                internalRedraw.
              ^ self
            );
            redrawFreely  => (
                | extent <- paper realExtent |
                
                paper clearAndReset.
                
                internalRedraw.

                "If the size of the paper has changed, we need to forward the change to the parent presentation."
                (((paper realExtent) equalsPoint: extent) not) -> [
                    parentMorph yes: [ :p |
                        p changed.
                    ].
                ].
              ^ self
            );

            renderAtOffset: offset On: renderer => (
                renderer withPushedRelativeOffset: offset Do: [
                    paper renderOn: renderer.
                ].
              ^ self
            );
            
            writeOn: w => w << 'a morph';
        }
    };

    Kernel: kernel Bounds: bounds Paper: paper => (Instance clone) initWithKernel: kernel Bounds: bounds Paper: paper;
    Kernel: kernel Bounds: bounds              => (Instance clone) initWithKernel: kernel Bounds: bounds;
}
