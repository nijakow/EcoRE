
{
    isa std Classlike;

    Instance :: Clonable
    {
        |
            behavior,
            state,
            protected morphs,
            protected cachedMinBounds
        |
        
        {
            protected polymorphic <- $package;

            initWithBehavior: b State: s => (
                behavior        <- b.
                state           <- s.
                morphs          <- std util newVector.
                cachedMinBounds <- No.
              ^ self
            );

            name    => behavior name;
            payload => state payload;

            emitOnStream: stream                => stream emitMorphKernel: self;
            emitOnGraphics: graphics At: offset => graphics at: offset PutMorph: self;
            emitOnGraphics: graphics In: bounds => graphics in: bounds PutMorph: self;

            protected calcMinBounds => (behavior presenter) minBoundsOfKernel: self;

            protected maybeSaveMinBounds => (
                (behavior caching?) if: [
                    cachedMinBounds <- Yes: calcMinBounds.
                ].
              ^ self
            );

            minBounds => (
                cachedMinBounds  no: [ maybeSaveMinBounds ].
                cachedMinBounds yes: [ :cm | ^ cm ].
              ^ calcMinBounds
            );
            minWidth => minBounds w;
            minHeight => minBounds h;
            minExtent => minBounds extent;
            minExtentForOrientation: orientation => (
                (orientation horizontal?) -> [ ^ minWidth  ].
                (orientation vertical?)   -> [ ^ minHeight ].
              ^ std sys error ThrowMessage: 'Unknown orientation!'
            );

            layoutForOrientation: orientation => ((polymorphic core morph) behavior layouting) ShrinkWrap;

            drawOnStream: stream                    => ( (behavior presenter) drawOn: stream Kernel: self. ^ self );
            drawOnStream: stream Instance: instance => drawOnStream: stream;

            drawOnPaper: paper => drawOnStream: (paper stream);

            drawOnEmptyPaper => (
                | paper <- (polymorphic core paper Paper) New |

                drawOnPaper: paper.

              ^ paper
            );

            instantiateInBoundsInfo: bounds WithPaper: paper => ((polymorphic core morph) Morph) Kernel: self BoundsInfo: bounds Paper: paper;
            instantiateInBoundsInfo: bounds                  => ((polymorphic core morph) Morph) Kernel: self BoundsInfo: bounds;

            offsetBy: offset => ((polymorphic core morph) BoundsInfo) Bounds: minBounds Offset: offset;

            addMorph: morph => (
                morphs add: morph.
              ^ self
            );

            removeMorph: morph => (
                morphs remove: morph.
              ^ self
            );

            clearCaches => (
                cachedMinBounds <- No.
              ^ self
            );

            changed => (
                clearCaches.
                morphs do: [ :each |
                    each kernelChangeCallback.
                ].
              ^ self
            );

            add: kernel => (
                | event <- (polymorphic event events) AddMorph: kernel | 
                (behavior dispatcher) handle: event context: self.
              ^ self
            );

            writeOn: w => w << 'a morph kernel';
        }
    };

    Behavior: behavior State: state => (Instance clone) initWithBehavior: behavior State: state;
}
