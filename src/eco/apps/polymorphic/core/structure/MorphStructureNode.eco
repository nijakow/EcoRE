
{
    static with inherited _ = std Classlike;

    own Instance = {
        static with inherited _ = std Clonable;

        morph, parentInfo, childrenInfo;

        protected currentOffset,
        protected currentDimension;

        protected cachedBounds,
        protected cachedGlobalBounds;

        protected cachedLayoutingConstraints;

        with inherited trait = {
            static with inherited _ = std Trait;
            protected polymorphic = $package;
            protected Point => ((polymorphic core) math geometry) Point;

            initWithMorph: _morph => (
                morph              <- _morph.
                parentInfo         <- ((polymorphic core) structure parent) NoParent.
                childrenInfo       <- ((polymorphic core) structure children) ManyChildren.
                currentOffset      <- Point X: 0 Y: 0.
                currentDimension   <- Point X: 0 Y: 0.
                cachedBounds       <- No.
                cachedGlobalBounds <- No.
                cachedLayoutingConstraints <- No.
              ^ self
            );

            childrenDo:        aBlock => childrenInfo do:        aBlock;
            childrenReverseDo: aBlock => childrenInfo reverseDo: aBlock;

            allChildrenDo: aBlock => childrenDo: [ :child |
                aBlock value(child).
                child allChildrenDo: aBlock
            ];

            relativeOffset => currentOffset;
            dimension      => currentDimension;
            width          => dimension x;
            height         => dimension y;

            bounds => (
                cachedBounds no: [ cachedBounds <- Yes: (((polymorphic core) math geometry) rectangle Origin: relativeOffset W: width H: height) ].
              ^ cachedBounds yes
            );

            globalBounds => (
                cachedGlobalBounds no: [ cachedGlobalBounds <- Yes: ((parentInfo hasParent) if: [ bounds translateBy: (parentInfo morph) structure globalBounds origin ] else: [ bounds ]) ].
              ^ cachedGlobalBounds yes
            );

            globalOffset => globalBounds origin;

            invalidateCaches => (
                cachedBounds       <- No.
                cachedGlobalBounds <- No.
                cachedLayoutingConstraints <- No.
                childrenDo: [ :child | (child structure) invalidateCaches ].
              ^ self
            );

            reshape: rect => reshapeX: (rect x) Y: (rect y) W: (rect w) H: (rect h);
            reshapeX: x Y: y W: w H: h => (
                currentOffset    <- Point X: x Y: y.
                currentDimension <- Point X: w Y: h.
                layoutChanged.
              ^ self
            );

            moveToX: x Y: y => reshapeX: x Y: y W: width H: height;
            moveTo: point => moveToX: (point x) Y: (point y);

            resizeToW: w H: h => reshapeX: (relativeOffset x) Y: (relativeOffset y) W: w H: h;


            "
                Layouting
            "
            protected baseMinWidth => ((morph behavior) layouter) minWidthForMorph: morph;
            protected baseMinHeight => ((morph behavior) layouter) minHeightForMorph: morph;

            protected baseMinSizeForOrientation: orientation => (
                orientation selectX: baseMinWidth Y: baseMinHeight
            );

            layoutChanged => (
                invalidateCaches.
                "TODO"
            );
            isLayoutDirty => cachedLayoutingConstraints isNo;

            protected isLayoutDirtyForConstraints: constraints => (
                cachedLayoutingConstraints yes: [ :c |
                    (c equalsPoint: constraints) if: [
                      ^ false
                    ]
                ].
              ^ true
            );

            forceLayoutWithConstraints: constraints => (
                cachedLayoutingConstraints <- Yes: constraints.
                (morph behavior layouter) layoutMorph: morph Constraints: constraints.
            );
            forceLayoutInPlace => forceLayoutWithConstraints: dimension;

            layoutWithConstaints: constraints => (
                (isLayoutDirtyForConstraints: constraints) if: [
                    forceLayoutWithConstraints: constraints.
                ].
            );
            layoutInPlace => layoutWithConstaints: dimension;

            layoutWithoutConstraints => (
                layoutWithConstaitns: (Point X: (minWidth) Y: (minHeight))
            );
            layoutWithHintedConstraints: hint => (
                layoutWithConstraints: (Point X: ((hint x) max: (minWidth))
                                              Y: ((hint y) max: (minHeight)))
            );


            writeOn: w => w << 'a polymorph structure node';
        };
    };

    NewForMorph: morph => Instance clone initWithMorph: morph;
}
