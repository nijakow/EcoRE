
{
    static with inherited _ = std Classlike;

    own Instance = {
        static with inherited _ = std Clonable;

        morph, parentInfo, childrenInfo;

        protected currentOffset,
        protected currentDimension;

        protected xLayout,
        protected yLayout;

        protected cachedBounds,
        protected cachedGlobalBounds;

        protected cachedLayoutingConstraints;

        with inherited trait = {
            static with inherited _ = std Trait;
            protected polymorphic = $package;
            protected Point => ((polymorphic core) math geometry) Point;

            initWithMorph: _morph Behavior: behavior => (
                morph              <- _morph.
                parentInfo         <- ((polymorphic core) structure parent) NoParent.
                childrenInfo       <- ((polymorphic core) structure children) Many.
                currentOffset      <- Point X: 0 Y: 0.
                currentDimension   <- Point X: 0 Y: 0.
                xLayout            <- behavior defaultHorizontalLayout.
                yLayout            <- behavior defaultVerticalLayout.
                world              <- No.
                cachedBounds       <- No.
                cachedGlobalBounds <- No.
                cachedLayoutingConstraints <- No.
              ^ self
            );

            "
                World and Tree
            "
            world => parentInfo world;

            parentInfo: newParent => parentInfo <- newParent;

            parent => (
                parentInfo ifParent: [ :p | Yes: p ].
              ^ No
            );

            childrenDo:        aBlock => childrenInfo do:        aBlock;
            childrenReverseDo: aBlock => childrenInfo reverseDo: aBlock;

            allChildrenDo: aBlock => childrenDo: [ :child |
                aBlock value(child).
                child allChildrenDo: aBlock
            ];

            add: child => (
                child remove.
                childrenInfo addChild: child.
                (child structure) onAdd.
                "TODO: Event handling"
              ^ self
            );

            protected isLinked => parentInfo hasParent;  "This method checks if we are linked to a parent morph."

            protected unlink => (
                "
                    TODO: How are we going to handle unlinking from the world?
                "
                (isLinked) if: [
                    (self structure) onRemove.
                    parentInfo removeChild: self.
                    parentInfo: ((polymorphic core) structure parent) NoParent.
                    "TODO: Event handling"
                ].
              ^ self
            );

            remove => unlink;

            replaceWith: replacement => parentInfo replaceChild: self With: replacement;

            onAdd    => ( invalidateCaches. world yes: [ :w | (w manager) notifyAdd:    self ]. "TODO: Handle event" );  "TODO: Invalidate caches, notify world, event handling"
            onRemove => ( invalidateCaches. world yes: [ :w | (w manager) notifyRemove: self ]. "TODO: Handle event" );  "TODO: Invalidate caches, notify world, event handling"


            "
                Position and Size
            "
            relativeOffset => currentOffset;
            dimension      => currentDimension;
            width          => dimension x;
            height         => dimension y;

            extentForOrientation: orientation => dimension dimensionForOrientation: orientation;

            bounds => (
                cachedBounds no: [ cachedBounds <- Yes: (((polymorphic core) math geometry) rectangle Origin: relativeOffset W: width H: height) ].
              ^ cachedBounds yes
            );

            globalBounds => (
                cachedGlobalBounds no: [ cachedGlobalBounds <- Yes: ((parentInfo hasParent) if: [ bounds translateBy: (parentInfo morph) structure globalBounds origin ] else: [ bounds ]) ].
              ^ cachedGlobalBounds yes
            );

            globalOffset => globalBounds origin;

            invalidatePositionCaches => (
                cachedBounds       <- No.
                cachedGlobalBounds <- No.
              ^ self
            );

            invalidateCaches => (
                invalidatePositionCaches.
                cachedLayoutingConstraints <- No.
                childrenDo: [ :child | (child structure) invalidateCaches ].
              ^ self
            );

            reshape: rect => reshapeX: (rect x) Y: (rect y) W: (rect w) H: (rect h);
            reshapeX: x Y: y W: w H: h => (
                currentOffset    <- Point X: x Y: y.
                currentDimension <- Point X: w Y: h.
                invalidatePositionCaches.
              ^ self
            );

            moveToX: x Y: y => reshapeX: x Y: y W: width H: height;
            moveTo: point => moveToX: (point x) Y: (point y);

            resizeToW: w H: h => reshapeX: (relativeOffset x) Y: (relativeOffset y) W: w H: h;
            resizeTo: point => resizeToW: (point x) H: (point y);


            "
                Layouting
            "
            layoutForOrientation: orientation => orientation selectX: xLayout Y: yLayout;

            protected baseMinWidth => ((morph behavior) layouter) minWidthForMorph: morph;
            protected baseMinHeight => ((morph behavior) layouter) minHeightForMorph: morph;

            protected baseMinSizeForOrientation: orientation => (
                orientation selectX: baseMinWidth Y: baseMinHeight
            );

            layoutChanged => (
                invalidateCaches.
                world yes: [ :w | (w manager) needsLayout: self ].
              ^ self
            );
            isLayoutDirty => cachedLayoutingConstraints isNo;

            protected isLayoutDirtyForConstraints: constraints => (
                cachedLayoutingConstraints yes: [ :c |
                    (c equalsPoint: constraints) if: [
                      ^ false
                    ]
                ].
              ^ true
            );

            forceLayoutWithConstraints: constraints => (
                cachedLayoutingConstraints <- Yes: constraints.
                (morph behavior layouter) layoutMorph: morph Constraints: constraints.
            );
            forceLayoutInPlace => forceLayoutWithConstraints: dimension;

            layoutWithConstaints: constraints => (
                (isLayoutDirtyForConstraints: constraints) if: [
                    forceLayoutWithConstraints: constraints.
                ].
            );
            layoutInPlace => layoutWithConstaints: dimension;

            layoutWithoutConstraints => (
                layoutWithConstaints: (Point X: (minWidth) Y: (minHeight))
            );
            layoutWithHintedConstraints: hint => (
                layoutWithConstraints: (Point X: ((hint x) max: (minWidth))
                                              Y: ((hint y) max: (minHeight)))
            );


            writeOn: w => w << 'a polymorph structure node';
        };
    };

    NewForMorph: morph Behavior: behavior => Instance clone initWithMorph: morph Behavior: behavior;
}
